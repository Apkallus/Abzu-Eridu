从程序的角度看，计算机内存是一个存储数据的巨大空间。
就像街道上的房屋一样，内存的每个部分都有一个数字*地址*，并且这些数字（大部分）是连续的。
现代计算机拥有海量内存，而典型现代程序的内存视图实际上存在大量空隙（可以理解为：街道上尚未建造房屋的区域，因此这些地址被跳过）。
但这些都只是细节：关键在于，计算机将数据（主要是顺序地）存储在内存中。

在本关卡中，我们将练习访问存储在内存中的数据。
我们该如何做到这一点？
回想一下，要将一个值移入寄存器，我们曾执行类似这样的操作：

```assembly
mov rdi, 31337
```

执行后，`rdi` 的值变为 `31337`。
很好。
那么，我们可以使用相同的指令来访问内存！
该指令有另一种格式，它将第二个参数用作要访问的内存地址！
假设我们的内存布局如下：

```text
  Address │ Contents
+────────────────────+
│ 31337   │ 42       │
+────────────────────+
```

要访问内存地址 31337 处的内容，你可以这样做：

```assembly
mov rdi, [31337]
```

当 CPU 执行此指令时，它当然理解 `31337` 是一个*地址*，而不是原始值。
如果你将指令想象成一个人告诉 CPU 该做什么，并且沿用我们的"街道房屋"类比，那么指令/人并不是直接递给 CPU 数据，而是*指向街道上的一栋房屋*。
CPU 随后会前往该地址，按响门铃，打开前门，将里面的数据拖出来，并将其放入 `rdi`。
因此，此上下文中的 `31337` 是*内存地址*，用于*指向*存储在该内存地址的数据。
此指令执行后，存储在 `rdi` 中的值将是 `42`！

让我们将其付诸实践！
我已经将一个秘密数字存储在内存地址 `133700` 处，如下所示：

```text
  Address │ Contents
+────────────────────+
│ 133700  │ ???      │
+────────────────────+
```

你必须检索这个秘密数字，并将其用作程序的退出代码。
为此，你必须将其读入 `rdi`，如果你还记得的话，`rdi` 的值是 `exit` 的第一个参数，并被用作退出代码。
祝你好运！
----

*注意*：要解决此挑战，你必须将输出的可执行二进制文件或汇编代码 `.s` 文件传递给 `/challenge/check`。
