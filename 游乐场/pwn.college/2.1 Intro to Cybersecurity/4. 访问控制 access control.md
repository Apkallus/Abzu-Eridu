# 访问控制漏洞利用

针对 POSIX/Unix 自主访问控制模型（DAC）的各种访问控制问题进行漏洞利用，并回答关于强制访问控制模型（MAC）的问题。



- ACL  
    ls -l 末尾出现 +：表示该文件/目录存在 ACL（或其他扩展权限信息）。
    - 对象：  
        **文件/目录**访问（r/w/x、遍历、默认继承）
    - 模型：
        DAC（自主访问控制）扩展
    - 细节：
        ACL 有个 `mask` 会“限制”除 owner 以外的命名用户/组与所属组权限
    - 命令：
        - `getfacl <file>` 查看 ACL 明细
            - `-R, --recursive`：
                递归查看目录下所有条目
            - `-p, --absolute-names`：
                输出绝对路径（递归时更好用）
            - `-c, --omit-header`：
                省略头部注释（脚本处理方便）

            - 常见典型行：
                - `user::rwx`：文件 owner 的权限
                - `user:alice:rw-`：命名用户 alice 的权限（ACL 的价值所在）
                - `group::r-x / group:dev:rw-`：文件所属组 / 命名组
                - `mask::r-x`：mask（掩码），会“卡住”除 owner 之外的用户/组权限上限
                - `other::---`：其他人权限
                - `default:user:alice:...`：目录的默认 ACL（新建子文件/目录时继承）

                常见意外：给了 user:alice:rw-，但实际生效是 rw- ∧ mask，所以看起来“没生效”。
        - `setfacl`
            - `-m, --modify ACLSPEC`：添加/修改条目
                ACLSPEC 常见写法：
                - `u:alice:rw`（命名用户）
                - `g:dev:rx`（命名组）
                - `m::r`（设置 mask）
            - `--set ACL`：用给定 ACL 整体覆盖
            - `-x, --remove ACLSPEC`：删除指定条目
            - `-b, --remove-all`：删除所有访问 ACL（回到纯 rwx）
            - `-R`：递归（对目录树批量设置时）
- Capabilities
    Capabilities 分两类：文件 capabilities（filecap）和进程 capabilities（进程运行时携带）。
    - 对象：  
        **进程**特权操作（绑定低端口、改网络配置、加载内核模块等）
    - 模型：
        root 特权拆分后的内核权限模型
    - 命令：
        - `getcap <binary>` 
            查看可执行**文件** capabilities
            - `-r, --recursive DIR` 
                递归查目录

            - 输出：
                `/path/prog cap_net_bind_service=ep` 
                含义：该文件执行时可获得 `cap_net_bind_service`，集合标志是 `e/p/i`。
                - `e` = Effective：执行后立即生效
                - `p` = Permitted：允许集合（上限）
                - `i` = Inheritable：可继承集合（和后续 exec/ambient 等联动）

        - `setcap` 
            设置/移除文件 capabilities
            - `setcap 'cap_xxx=+ep' FILE`：
                给文件加 capability
            - `setcap -r FILE`：
                移除该文件所有 capability
        - `capsh`
            - `capsh --print`：
                打印当前进程 capability 状态（含 bounding set 等）
        - `getpcaps PID`：
            查看某个**进程**的 capabilities

## 挑战

### 级别1

由你拥有且具有不同权限的标志
- 对文件所有者修改以及文件权限修改的示例

### 级别2

由你拥有且具有不同权限的标志
- 对文件组修改以及文件权限修改的示例

### 级别3

由你拥有且具有不同权限的标志
- 对文件权限修改的应用

### 级别4

*setuid* 是如何工作的？

### 级别5

*setuid* 和 *cp* 命令如何协同工作？
- cp 命令参数的探索

### 级别6

由不同组拥有的标志
- 提供目标组的密码，切换到目标组

### 级别7

由你拥有且具有不同权限的标志（多用户环境）
- 提供目标用户的密码，切换到目标用户

### 级别8

由其他用户拥有的标志

### 级别9

由其他用户拥有的标志

### 级别10

由某个组拥有的标志
- 查询组文件或访问库获得组中的用户信息

### 级别11

利用多个用户查找标志

### 级别12

利用多个用户查找标志

### 级别13

一个不带分类的强制访问控制问题
- 控制模型问答

### 级别14

五个不带分类的强制访问控制问题

### 级别15

一个带分类的强制访问控制问题

### 级别16

五个带分类的强制访问控制问题

### 级别17

在一秒内自动回答20个带分类的强制访问控制问题
- 级别使用字典、分类使用集合比较
    - 读同级/低级与子集
    - 写高级与超集
    - 注意空集的处理

### 级别18

在一秒内自动回答64个带分类的强制访问控制问题

### 级别19

在一秒内自动回答128个具有随机级别和分类的强制访问控制问题
