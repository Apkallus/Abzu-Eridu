# 密码学

解决各种密码学挑战，从基础知识开始，逐步深入高级概念！
本模块假定您已掌握 数据处理编码(/fundamentals/data-dealings)的相关知识。

## 对称密码学 Symmetric Cryptography

### 异或运算

说来也怪，我们将从不起眼的[*异或*](https://en.wikipedia.org/wiki/exclusive_or)运算符开始我们的密码学之旅。异或是你在安全领域（*尤其*是在密码学中）会遇到的最常见的[*位运算符*](https://en.wikipedia.org/wiki/logical_connective)之一。

有几个术语需要解释一下...

**按位运算**。记得在 处理数据(/fundamentals/data-dealings/)中我们提到过，计算机用二进制思考！也就是说，它们以二进制来概念化数字，所以像 `9` 这样的数字会表示为 `1001`。异或运算一次处理一对比特位，如果两个比特位不同（一个是 `1`，另一个是 `0`），则结果为 `1`；如果它们相同（都是 `1` 或都是 `0`），则结果为 `0`。然后这个操作独立地应用于每一对比特位，并将结果拼接起来。例如，十进制数 `9` (`1001`) 与十进制数 `5` (`0101`) 进行异或运算，得到 `1100`（十进制 12）。

**密码学**。为什么异或在密码学中如此常见？因为在密码学中，它具有[*自反性*](https://en.wikipedia.org/wiki/exclusive_or#properties)！也就是说（这里使用 `^` 表示异或，这与许多编程语言一致），`5 ^ 9 == 12`，并且 `12 ^ 9 == 5`。如果数字 `9` 是一个只有你我知道的密钥，我可以通过用 `9` 对消息进行异或来发送给你，而你同样可以通过用 `9` 对消息进行异或来恢复原始消息！显然，我们也可以通过我加 9、你减 9 的方式来实现这个特性，而不使用异或，但这需要更复杂的电路和额外的比特位（例如，处理 `1111 + 0001 == 10000` 中的"进位"），而异或则没有这个问题（`1111 ^ 0001 == 1110`）。

在本关卡中，你将学习使用异或！我们会给你一个共享的*密钥*，让你将一个秘密数字与它进行 `xor` 运算，并期望你能够恢复出原始数字。

----

**提示：** 使用 Python 的 `^` 运算符来对整数进行异或操作！

### 十六进制异或

当然，正如你在 处理数据(/fundamentals/data-dealings)中学到的那样，我们倾向于将计算机内存中的值表示为*十六进制*。
如果你不记得那是什么，请返回去复习那些关卡。
否则，请在此处继续练习一些十六进制异或操作！

### ASCII 异或

密码学领域的许多工作都涉及加密*文本*。
正如你可能（再次！）从 处理数据(/fundamentals/data-dealings)中回忆的那样，这些文本会根据编码标准（如 ASCII 或 UTF-8）映射到特定的字节值。
这里我们将坚持使用 ASCII，但这些概念同样适用于其他编码。

酷的是，由于 ASCII 将字节值分配给字符，我们可以执行像异或这样的操作！
这对密码学具有明显的影响。

在本关卡中，我们将逐字节探讨这些影响。
挑战将每次给你一个字母，以及一个用于"解密"（即进行异或运算）的密钥。
你需要给出异或运算的结果。
例如：

```sh
hacker@dojo:~$ /challenge/run
Challenge number 0...
- Encrypted Character: A
- XOR Key: 0x01
- Decrypted Character?
```

你会如何解决这个问题？
你可以使用 `man ascii` 命令并查找 A 对应的条目：

```none
Oct   Dec   Hex   Char
──────────────────────
101   65    41    A
```

所以 A 的十六进制值是 `0x41`。
你需要将其与 `0x01` 进行异或运算
这里的结果将是：`0x41 ^ 0x01 == 0x40`，并且，根据 `man ascii`：

```none
Oct   Dec   Hex   Char
──────────────────────
100   64    40    @
```

它是 @ 字符！

```sh
hacker@dojo:~$ /challenge/run
Challenge number 0...
- Encrypted Character: A
- XOR Key: 0x01
- Decrypted Character? @
Correct! Moving on.
```

现在轮到你了！
你能通过异或运算得到标志吗？

### ASCII 字符串异或

好的，现在你已经知道如何对 ASCII 字符进行异或运算了。
这是我们构建第一个密码系统的关键一步，但现在我们需要对整个 ASCII 字符串进行异或运算！
让我们来试试看。

就像 Python 提供 `^` 运算符来对整数进行异或运算一样，一个名为 PyCryptoDome 的 Python 库提供了一个名为 `strxor` 的函数来对两个字符串进行异或运算。
你可以在 Python 中使用 `from Crypto.Util.strxor import strxor` 来导入它。

对两个字符串进行异或运算是逐字节进行的，就像对两个字节进行异或运算是逐位进行的一样。
所以，借用之前的一个例子：

```sh
hacker@dojo:~$ python
>>> from Crypto.Util.strxor import strxor
>>> strxor(b"AAA", b"16/")
b'pwn'
```

你可以用 ASCII 表自己验证：A ^ 1 是 p，A ^ 6 是 w，A ^ / 是 n。
我们刚刚用*密钥* `16/` 解开了*密文* `AAA`，得到了*明文* `pwn`。

在这个挑战中，你将连续多次进行这个操作：就像之前的挑战一样，但这次是针对字符串！
祝你好运！

----

**注意事项：**
这些引号前面的 `b` 是什么？
Python 默认的字符串表示形式（例如 `"AAA"`）是 [*Unicode*](https://en.wikipedia.org/wiki/Unicode)，与例如拉丁字母表不同，Unicode 包含了人类已知的所有字符（包括拉丁字母表）！
这意味着单个字符可以有数千个不同的值（撰写本文时，Unicode 包含了 154,998 个字符！），从 "A" 到 "💩"。

不幸的是，一个 8 比特的字节只能容纳 `2**8 == 256` 个不同的值，这对于 ASCII（拉丁字母表中没有那么多字母/数字等）来说足够了，但对于 Unicode 来说还不够。
Unicode 使用不同的编码方式进行*编码*，例如我们之前提到的 [UTF-8](https://en.wikipedia.org/wiki/UTF-8)。
UTF-8 被设计成与 ASCII 向后兼容——"A" 就是 0x41，而像 "💩" 这样的字符需要*四个*字节：`f0 9f 92 a9`！

基本上，`ASCII` 之于`拉丁字母表`就如同 `UTF-8` 之于 `Unicode`，并且正如拉丁字母表是 Unicode 的子集一样，ASCII 也是 UTF-8 的子集。
很神奇吧。

总之，Python 的普通字符串（以及通常从终端获取的 `input()`）是 Unicode 的，但有些函数，比如 `strxor`，消耗和产生的是*字节*。
你可以像上面我做的那样，通过在引号前加上 `b`（代表**字**节）并使用 ASCII 或十六进制编码（例如，`b"AAA"` 和 `b"A\x41\x41"` 是等价的）来直接指定它们，或者你可以使用 UTF-8 将 Unicode 字符串*编码*为字节，像这样：`"AAA".encode() == b"AAA"` 或 `"💩".encode() == b"\xf0\x9f\x92\xa9"`。
你也可以将结果字节*解码*回 Unicode 字符串：`b"AAA".decode() == "AAA"` 或 `b"\xf0\x9f\x92\xa9".decode() == "💩"`。

这件事*进一步*复杂化，因为 UTF-8 无法将任意字节转换为 Unicode。
例如，`b'\xb0'.decode()` 会引发异常。
你可以通过放弃默认的 UTF-8 并使用一种前 Unicode 时代的非编码编码，比如来自计算远古时代的 "[latin](https://en.wikipedia.org/wiki/ISO/IEC_8859-1)"/ISO-8859-1 来解决这个问题：`b'\xb0'.decode('latin')`。
虽然 ISO-8859-1 最初早于 Unicode，但它的 Python 实现会转换为 Unicode 字符串。
但是，请记住这种编码*不同于* UTF-8：`b"\xb0".encode('latin").decode() == b'\xc2\xb0'`。
你必须保持一致，使用相同的编码进行解码和编码：`b"\xb0".encode('latin").decode(latin1) == b"\xb0"`。

总之，所有这些听起来很可怕，但这主要是对未来的一个警告。
对于*本*关卡，我们非常小心地选择了字符，因此你不会遇到这些问题。

**警告：**
Python 的字符串与字节的情况很糟糕，并且最终*会*咬到你（哈哈！）。
无法避免陷阱——即使我们使用 Python 多年，它们仍然会困扰我们，所以你只需要学会自己爬起来，掸掸灰尘，修复代码，然后继续前进。
有了足够的经验，你会从因为字符串/字节混淆而浪费*整整几天*来调试，进步到只浪费*整整几个小时*。

### 一次性密码本

在这个挑战中，你将解密一个使用[一次性密码本](https://en.wikipedia.org/wiki/One-time_pad)加密的秘密。
虽然简单，但这是最安全的加密机制，前提是 a) 你能安全地传输密钥，并且 b) 你*只*使用该密码本*一次*。
它也是最简单的加密机制：你只需将明文的比特与密钥的比特逐位进行*异或*运算即可！

这个挑战使用一次性密码本加密了标志，然后给了你密钥。
幸运的是，一次性密码本是一种*对称*密码系统：也就是说，你使用相同的密钥进行加密和解密，因此你拥有解密标志所需的一切！

----

**有趣的事实：** 一次性密码本是人类能够*证明*其是完美安全的*唯一*密码系统。
如果你能安全地传输密钥，并且只将其用于一条消息，那么即使攻击者拥有无限的计算能力，也无法破解它！
我们还无法为任何其他密码系统做出这样的证明。

### 一次性密码本篡改

所以，一次性密码本被证明是安全的……但仅限于*机密性*方面！
它实际上并不保证任何关于完整性的内容。
这个挑战问你：如果你可以在传输过程中*篡改*消息会怎样？
思考一下异或运算的工作原理，看看你能否得到标志！
- 由明文与密文可得到使用异或的密钥

### 多次性密码本

之前的挑战给了你一次性密码本（密钥）来解密密文。
如果你不知道这个一次性密码本，并且它只被使用过一次，那么之前的挑战将是无法解决的！
在这个关卡中，我们将探讨如果违反了后一个条件（即密钥被多次使用）会发生什么。
这次你不会得到密钥，但我们会允许你加密任意多的消息。
你能解密出标志吗？

----
**提示：** 深入思考异或运算的工作原理，并考虑它是一个具有分配律、交换律和结合律的运算...
**提示：** 我们推荐使用 Python 编写你的解决方案，并利用我们在挑战中使用的 `strxor` 函数！这会让事情变得简单得多。

### 高级加密标准（AES）

所以，一次性密码本在被重复使用时就会失效。
这并不理想：考虑到在传输密钥时需要多么小心，如果密钥能够用于不止一条消息，那将会更好！

于是，[*高级加密标准*](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)（AES）登场了。
AES 相对较新：于 2001 年登上舞台。
与一次性密码本类似，AES *也*是对称的：使用相同的密钥进行加密和解密。
与一次性密码本不同，AES 在使用相同密钥加密多条消息时仍能保持安全性。

在这个挑战中，你将解密一个使用高级加密标准（AES）加密的秘密。
AES 是一种所谓的"分组密码"，一次加密一个 16 字节（128 位）的明文"分组"。
因此，`AAAABBBBCCCCDDDD` 将是一个单独的明文分组，它会被加密成一个单独的密文分组。

AES *必须*对完整的分组进行操作。
如果明文*短于*一个分组（例如，`AAAABBBB`），它将被*填充*到分组大小，然后对填充后的明文进行加密。

不同的 AES"模式"定义了当明文长度超过一个分组时的处理方法。
在这个挑战中，我们使用最简单的模式："[*电子密码本*](<https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_(ECB)>)"（ECB）。
在 ECB 模式中，每个分组使用相同的密钥独立加密，然后简单地拼接在一起。
因此，如果你要加密像 `AAAABBBBCCCCDDDDEEEEFFFFGGGGHHHH` 这样的内容，它将被分成两个明文分组（`AAAABBBBCCCCDDDD` 和 `EEEEFFFFGGGGHHHH`），分别进行加密（假设结果分别是 `UVSDFGIWEHFBFFCA` 和 `LKXBFVYASLJDEWEU`），然后拼接起来（得到密文 `UVSDFGIWEHFBFFCALKXBFVYASLJDEWEU`）。

这个挑战将给你经过 AES 加密的标志以及用于加密它的密钥。
我们不会深入探讨 AES 的内部原理，即它实际是如何加密原始字节的。
相反，我们将学习 AES 的不同*应用*，以及它们在实践中是如何被破解的。
如果你对学习 AES 的内部原理感兴趣，我们强烈推荐 [CryptoHack](https://cryptohack.org/courses/)，这是一个专注于密码学具体细节的绝佳学习资源！

现在，去解密标志并得分吧！
- 设置密码对象后，使用`decrypt` 进行解密，需对明文/密文设置填充对齐

----
提示：
我们在本关卡中使用 [PyCryptoDome](https://www.pycryptodome.org/) 库来实现加密。
你需要阅读其文档来弄清楚如何实现你的解密！

### 实用资源

- [逐字节 ECB 模式解密](https://node-security.com/posts/cryptography-byte-by-byte-ecb-decryption/)（与我们探讨的背景略有不同）

### AES-ECB-选择明文攻击

尽管 AES 加密算法的核心被认为是安全的（但并未被*证明*是安全的：目前还没有人能够做到这一点！不过在其使用的 20 多年里，也尚未有人能实质性破解该加密算法），但这个核心一次只能加密 128 位（16 字节）的分组。
要在实践中实际*使用* AES，必须在其之上构建一个*密码系统*。
在之前的关卡中，我们使用了 AES-[ECB](<https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_(ECB)>) 密码系统：这是一种电子密码本密码，其中每个分组都使用相同的密钥独立加密。
这个系统相当简单，但正如我们将要发现的，它极易受到某类攻击。
密码系统需要满足非常高的[*密文不可区分性*](https://en.wikipedia.org/wiki/Ciphertext_indistinguishability)标准。
也就是说，一个没有密码系统密钥的攻击者，不应该能够根据被加密的明文来区分成对的密文。
例如，如果攻击者查看密文 `UVSDFGIWEHFBFFCA` 和 `LKXBFVYASLJDEWEU`，并且能够确定后者是由明文 `EEEEFFFFGGGGHHHH` 产生的（或者，实际上，能够推算出关于明文的*任何*信息！），那么该密码系统就被认为是已被攻破。
即使攻击者已经知道部分或全部明文（这种情况被称为[已知明文攻击](https://en.wikipedia.org/wiki/Known-plaintext_attack)），*或者甚至能够控制部分或全部明文*（这种情况被称为[选择明文攻击](https://en.wikipedia.org/wiki/Chosen-plaintext_attack)），这个特性也必须成立！
ECB 容易受到已知明文攻击和选择明文攻击。
因为每个分组都使用相同的密钥加密，且没有其他修改，攻击者可以观察到具有相同明文的不同分组所产生的相同密文。
此外，如果攻击者能够选择或获知与某些分组相关联的明文，他们就可以精心构建一个从已知明文到已知密文的映射，并将其用作查找表来解密其他匹配的密文！
在这个关卡中，你将做的就是这件事：你将构建一个从密文到选定明文的密码本映射，然后利用它来解密标志。
祝你好运！

- 并不是构建巨型彩虹表来匹配每段密文。而是由于可选flag字符串偏移，而逐字节提取1字节+15字节填充的模式，对字符集进行密码本创建
- 使用pwntool来进行命令交互的模式匹配

----
提示：
你可能会发现自动化与此挑战的交互很有帮助。
你可以使用 `pwntools` 这个 Python 包来实现。
可以参考一位 pwn.college 同学整理的 [这份 pwntools 速查表](https://gist.github.com/anvbis/64907e4f90974c4bdd930baeb705dedf)！

### AES-ECB-选择明文攻击-HTTP

好的，现在我们将在一个*稍微更真实的场景*中尝试这种攻击。
你能回忆起你的 SQL 语句来执行攻击并恢复标志吗？

- `sql = f'SELECT {query} FROM secrets'`
- 使用 `substr` 提取一字节

----
提示：
记住，你可以通过执行 `SELECT 'my_plaintext'` 来让 select 语句返回选定的明文！

### AES-ECB-选择明文攻击-HTTP (base64)

由于历史原因，不同的编码方式往往在不同场景中得到广泛应用。

例如，在Web环境中，编码二进制数据的标准方法是base64，这是一种您在 数据处理(/fundamentals/data-dealings)章节中学习过的编码方式。
现在请运用这项技能，调整您之前的解决方案以适配base64编码！

您会（再次）注意到，base64不像十六进制那样便于推理。
为什么人们还要使用它呢？
一个原因在于：每个字节需要*两个*十六进制字母进行编码，而base64每3个字节仅使用4个字母进行编码。
这意味着，例如当通过网络传输每个字母（其本身也是一个字节）时，base64的效率略高一些。
另一方面，由于不规整的位边界，base64处理起来较为棘手！

在后续的模块中，挑战可能会根据我们的需求随意使用十六进制或base64编码。
能够处理这两种编码方式至关重要！

- `<b>Results:</b><pre>{b64encode(ct).decode()}</pre>`
    python的base64输入输出为bytes，仅需encode后base64解码。  
    然而此处的AES-ECB选择明文攻击使用每个字符对应的独特密文构建密码本，无论编码格式如何均为独特字符串，无需使用base64解码

### AES-ECB-选择明文攻击-后缀

好的，现在让我们稍微增加复杂度以提升现实性。
通常您很难直接按需构造明文查询。
然而，较常见的情况是您能够将某些数据的*尾端*隔离到独立的块中，这在ECB模式下会带来严重问题。
本挑战将探讨这一概念，用“对末尾部分字节进行加密”的能力替代直接查询flag子字符串的能力。

请向我们证明您依然能解决这个问题！

```py
if (choice := int(input("Choice? "))) == 1:
    pt = input("Data? ").strip().encode()
elif choice == 2:
    length = int(input("Length? "))
    pt = flag[-length:]
```
- 如提示，获取最后一个字节的方式与之前获取第一个字节相同，每次获得一个新明文字符则添加到已知明文字符串，继续爆破

----
**提示：**
请记住，一旦恢复flag末尾的某些部分，您就可以利用已知部分的前缀构建新的代码本，并继续对前一个字节重复此攻击！

### AES-ECB-选择明文攻击-前缀

好的，现在让我们稍微增加复杂度。
直接截取目标数据末尾并随意操作的情况并不常见。
然而，*更*常见的是能够在机密数据加密前*预置*选定明文的能力。
如果您精心构造预置数据，使其将机密数据的末尾*推入*一个新的块中，就相当于成功将其隔离，效果与直接截取相同！

请在此挑战中实践这一方法。
核心攻击方式与之前相同，只是需要更多的数据调整工作。

```py
if (choice := int(input("Choice? "))) == 1:
    pt = input("Data? ").strip().encode()
elif choice == 2:
    pt = input("Data? ").strip().encode() + flag

padded_pt = pad(pt, cipher.block_size) if len(pt)%cipher.block_size else pt
```

- 每次仅回显一个分块16字节的密文
- 提供了初始的测试代码以显示推入新块所需的字符数
- 将大密文串分割为列表
- 在使用填充获得倒数第一个块之后（1未知+15填充），倒数第二个块应当使用已知的第一个块的15字节作为已知填充（1未知+15已知字节）。
- 本质仍为每次取得1个未知字节

----

提示：
请注意，典型的pwn.college flag长度通常超过50字节。
这相当于四个块（三个完整块加一个部分块），长度可能略有变化。
您需要尝试预置多少字节才能将末尾的单个字符推入独立的块中。

提示：
请记住每个块的长度为16字节！
在泄露最后16字节后，您将需要处理倒数第二个块，依此类推。

### AES-ECB-选择明文攻击-前缀-2

之前的挑战忽略了一个非常重要的概念：[*填充*](<https://en.wikipedia.org/wiki/Padding_(cryptography)#Byte_padding>)。
AES具有128位（16字节）的块大小。
这意味着算法的输入*必须*为16字节长，任何短于此长度的输入都必须在加密前通过向明文添加数据的方式进行*填充*以达到16字节。
当密文被解密时，结果必须进行*去除填充*（例如，必须移除添加的填充字节）以恢复原始明文。

*如何*进行填充是一个有趣的问题。
例如，您可以使用空字节（`0x00`）进行填充。
但如果您的数据末尾本身就包含空字节呢？
它们在去除填充过程中可能会被错误地移除，导致得到的明文与原始明文不同！
这显然不是理想的情况。

一种填充标准（可能也是最流行的）是PKCS7，它简单地使用值等于所填充字节数量的字节来填充输入。
如果向15字节的输入添加1个字节，则该字节的值为`0x01`；向14字节的输入添加2个字节则填充`0x02 0x02`；向1字节的输入添加15个字节则所有填充字节的值均为`0x0f`。
在去除填充时，PKCS7会查看块中最后一个字节的值，并移除相应数量的字节。
很简单！

但是等等...
如果恰好加密了16字节的明文（即不需要填充），但明文的最后一个字节的值是`0x01`呢？
如果放任不管，PKCS7在去除填充时会切掉那个字节，导致我们得到一个损坏的明文。
对此的解决方法略显迂回：如果明文的最后一个块恰好是16字节，我们会添加一个*完全*由填充字节组成的块（例如，16个填充字节，每个的值为`0x10`）。
PKCS7在去除填充时会移除整个块，这样虽然牺牲了一点数据量，但明文的完整性得以保留。

无论如何，之前的挑战明确禁用了这最后一种情况，这导致当您尝试将第一个后缀字节推入其自己的块时，会弹出一个充满填充字节的"诱饵"密文块。
本挑战则正确地实现了填充。
请留意那个"诱饵"块，去解决它吧！

- 注意，明文与flag加密的两种方式均需应对新增的填充段

----
**注意：**
只有当明文的最后一个块正好填满16字节时，才会出现全填充块。
当再追加一个字节时它会消失（被包含明文字节的新填充块取代），但当新块的长度达到16字节时，它又会重新出现。

### AES-ECB-选择明文攻击-前缀-小首领

这是AES-ECB-CPA模式下的*小头目*挑战。
您不再有简单的方法来构建代码本：必须在*前缀*中构建它。
如果您能根据已知机密数据的多少来调整自身前缀数据的长度，就可以控制整个数据块，而这正是您所需的全部条件！
除此之外，攻击方式保持不变。
祝您好运！

```py
pt = bytes.fromhex(input("Data? ").strip()) + flag
```
- 此处修改了数据类型，修改之前的函数内参数类型则无需修改其余部分
- 手动设置类似自动填充的字节（如，1测试字符+15个0xf），取第一段来构建密码本
- 即 `测试字符+可变长度的块填充` 取第一块以得到密码本  

### AES-ECB-选择明文攻击-前缀-首领

好的，是时候面对AES-ECB-CPA的*最终Boss*了！
你能对一个加密的秘密存储Web服务器执行此攻击吗？
让我们拭目以待！

```py
pt = b"|".join(post["content"] for post in db.execute("SELECT content FROM posts ORDER BY ROWID DESC").fetchall())
```
- 格式为 `输入|flag`

----

注意：
请注意，与之前的关卡不同，本关卡接收base64格式的数据！

### AES-密码分组链接模式（CBC）

好的，希望我们已经达成共识，ECB是一种糟糕的分组密码模式。
现在让我们来探索一种不那么糟糕的模式：[密码块链接（CBC）](<https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Cipher_block_chaining_(CBC)>)。
CBC模式按顺序加密块，在加密第N个明文块之前，会先将其与前一个密文块（第N-1块）进行XOR运算。
在解密时，解密第N个密文块后，会将该解密结果（但仍处于XOR状态）与前一个密文块（第N-1块）再次进行XOR运算，以恢复原始的第N个明文块。
对于第一个块，由于没有“前一个”块可用，CBC密码系统会生成一个称为[*初始化向量（IV）*](https://en.wikipedia.org/wiki/Initialization_vector)的随机初始块。
IV用于与第一个明文块进行XOR运算，并随消息一起传输（通常附加在消息开头）。
这意味着，如果你在CBC模式下加密一个明文块，你可能会得到*两*个“密文”块：IV和你实际的那个密文块。

所有这些意味着，当你更改明文的任何部分时，这些更改会通过基于XOR的链接传播到所有后续的密文块，从而为这些块保持了*密文不可区分性*。
这将阻止你执行前几个挑战中的*选择明文前缀攻击*。
此外，每次重新加密时，即使使用相同的密钥，也会使用一个新的（随机的）IV，这将导致更改传播到所有块，这意味着你更早关卡中基于采样的CPA攻击也将失效。

听起来很不错，对吧？
CBC相对于ECB唯一相关的*劣势*是加密必须按顺序进行。
对于ECB，你可以只加密消息的最后一部分（如果你只需要发送这部分）。
而对于CBC，你必须从头开始加密消息。
在实践中，这往往不是问题，并且永远不应该选择ECB而放弃CBC。

本关卡只是对CBC的一个快速了解。
我们将使用CBC模式加密flag。
去解密它吧！
- 加密：（IV或密文 ^ 明文）->加密到密文
- 解密：密文->解密^（IV或密文）->明文

### AES-密码分组链接模式篡改

基于CBC的密码系统在解密后，会与前一个块的*密文*进行XOR运算以恢复该块的明文。
这样做有多重原因，包括：

1.  正是这个XOR操作使其区别于ECB模式，而我们已经见识过ECB是多么容易出错。
2.  如果它与前一个块的*明文*进行XOR而不是密文，其有效性将取决于明文本身（例如，如果明文全是空字节，XOR将不起作用）。除了降低链接的有效性外，这还可能泄露关于明文的信息（这在密码系统中是绝对不允许的）！
3.  如果它与前一个块的*明文*进行XOR而不是密文，CBC的“随机访问”特性将会丢失。接收方必须恢复前一个块的明文才能解密当前块，而要恢复前一个块又需要恢复更前一个块，如此递归直至IV。

不幸的是，在消息可能于传输过程中被修改的情况下（设想：拦截通信），精明的攻击者可以通过将精心挑选的值XOR进第N-1块的密文，来直接影响第N块解密后的明文结果。
这将损坏第N-1块（因为它会解密成乱码），但根据具体情况，这种损坏或许是可以接受的。
此外，对IV执行此操作允许攻击者在不损坏任何块的情况下，直接XOR第一个块的明文！

用安全术语来说，CBC（并不完美，我们将在后续挑战中看到）保留了*保密性*，但并未保留*完整性*：消息可能被攻击者篡改！

我们将在本关卡中探索这一概念，一个任务分发器会将加密的任务分发给任务执行器。
你能强制其泄露flag吗？

- CBC解密时，对密文使用key解密后，再使用前一个块的密文进行异或。
    即，由于密文解密后的异或字符串不变，操纵IV或密文可对异或字符串进行逐位/字节篡改
- 爆破或计算差异后直接得到IV，可控IV，已知明文

```
IV ^ 明文 = 异或串
IV ^ 异或串 = 明文
设计IV ^ 异或串 = 目标明文

由于使用key解密后的异或串相同：
IV ^ 明文 = 设计IV ^ 目标明文
目标明文 = (IV ^ 明文) ^ 设计IV
设计IV = (IV ^ 明文) ^ 目标明文
```
即，mask相同（或，IV^明文即为mask），于是可直接计算出设计IV


### AES-密码分组链接模式调整大小

所以现在你可以在*不知道密钥*的情况下修改 AES-CBC 加密数据了！但你很幸运：`sleep` 和 `flag!` 的长度相同。如果你想实现不同的长度该怎么办呢？

- 之前使用`pad()`自动填充则无需修改代码

---- 
**提示：** 别忘了填充！填充是如何工作的？

### 实用资源

- [深入探讨填充预言攻击](https://www.nccgroup.com/us/research-blog/cryptopals-exploiting-cbc-padding-oracles/)
- [一些填充预言攻击实践](https://paddingoracle.github.io/)

### AES-密码分组链接模式-填充预言攻击-部分分组

所以你可以操纵填充了...
如果你在前一个挑战的某处搞砸了并创建了一个无效的填充，你可能已经注意到工作进程*崩溃*了，并报错提示填充不正确！

事实证明，这一次崩溃*完全*破坏了 AES-CBC 密码体系的机密性，使得攻击者无需密钥即可解密消息。让我们深入探究一下...

回想一下，PKCS7 填充会添加 N 个值为 N 的字节，因此如果添加了 11 个填充字节，它们的值就是 `0x0b`。
在去除填充时，PKCS7 会读取最后一个字节的值 N，确保最后 N 个字节（包括最后一个字节）都具有相同的值 N，然后移除这些字节。
如果值 N 大于块大小，或者并非所有字节的值都是 N，包括 PyCryptoDome 在内的大多数 PKCS7 实现都会报错。

思考一下你在前一个关卡中处理填充时需要多么小心，这要求你必须知道你想要移除的字母。
如果你不知道那个字母怎么办？
你对要与它进行异或操作的值进行随机猜测，在 256 次尝试中会有 255 次导致错误（当然，前提是你正确处理了其余的填充）。而在那唯一一次没有报错的情况下，通过知道最终的填充值必须是什么以及你的异或值是什么，你就可以恢复出该字母的值！
这就是所谓的 [*填充提示攻击*](https://en.wikipedia.org/wiki/Padding_oracle_attack)，得名于那个告诉你填充是否正确的“神谕”（错误信息）！

当然，一旦你移除（并得知）明文的最后一个字节，倒数第二个字节就变成了最后一个字节，于是你又可以攻击它了！

那么，你还在等什么呢？
去把 flag 恢复出来吧！

- 查看提供的动画指南资源以获得更多信息
- 使用 PKCS7 的填充提示作为是否命中的信息  
    - 可控的内容为IV或前一块的密文。
    - 尝试使用设计作为IV或前一块的密文，对后一块的最后一字节进行爆破时，若未出现异常则对应填充为`0x1`（填充一字节的填充值为 `0x1`）。  
        - 当前直接控制爆破值以及由错误提示得知的对应填充值 `爆破值^未知异或字节=填充值`
        - 未知异或串的最后一个字节已经可由两个已知字段计算 `未知异或字节=爆破值^填充值`
    - 尝试对后一块的倒数第二字节进行爆破时，目标为2个填充字节`0x2`，倒数第一个字节对应`0x2`的密文值由之前步骤获得的已知异或字节计算。对倒数第二字节进行爆破时，若未出现异常则对应填充为`0x2`。使用相同方式得到倒数第二字节的未知异或字节。
    - 从最后一个字节开始，向前逐渐将未知异或字节转为已知异或字节，过程中使用已知异或字节构造出未知异或字节的测试向量（如，由`0x1`获得的抑或字节构建`0x2`异或字节）
    - 得到整块的异或串后，由于前一块的密文已知，于是`后一块的明文=异或串^前一块的密文`

- 使用pwn库读取时，为避免遗留/多余的内容，在输出后循环`p.recvline(timeout=0.1)`读取所有内容来清理干净
- 此处使用了两种填充不正确的提示 `Padding is incorrect` `padding is incorrect`
- 可能在倒数第一个字节存在多个对应（`0x1` `0x2`），打印出所有候选项，在失败时尝试其他。或者 `0x0 ^ 0x1` 可能得到的假 `0x1` 需排除。

----

**趣味事实：**
防止填充提示攻击的唯一方法就是避免存在一个“填充提示”。
根据应用的不同，这可能出乎意料地棘手：失败状态很难对应用程序的用户/攻击者完全隐藏，并且对于某些应用来说，填充失败是唯一的错误来源！
此外，即使错误本身对用户/攻击者隐藏，也常常可以*间接推断*出来（例如，通过检测填充错误与填充成功两种情况之间的时间差异）。

**资源：**
你可能会发现一些动画/交互式的填充提示攻击演示很有用：

- [来自 CryptoPals 的动画入门指南](https://www.nccgroup.com/us/research-blog/cryptopals-exploiting-cbc-padding-oracles/)
- [另一个动画入门指南](https://dylanpindur.com/blog/padding-oracles-an-animated-primer/)
- [一个交互式的填充提示攻击探索工具](https://paddingoracle.github.io/)

### AES-密码分组链接模式-填充预言攻击-完整分组

之前的挑战让你通过滥用末尾的填充来解密一个部分块。
但如果一个块是“满”的，即长度为 16 字节，会发生什么呢？
让我们以一个明文 `AAAABBBBCCCCDDDD`（16 字节长）为例来探讨一下！
如你所知，在这种情况下，PKCS7 会添加*一整个块*的填充！
填充后我们看到的将是：

| 明文块 1        | 明文块 2 (呃，只是填充！)                                                      |
|-----------------|------------------------------------------------------------------------------|
| `AAAABBBBCCCCDDDD` | `\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10` |

经过加密后，我们将得到三个密文块：

| 密文块 1 | 密文块 2                     | 密文块 3             |
|----------|------------------------------|----------------------|
| IV       | 加密后的 `AAAABBBBCCCCDDDD` | 加密后的填充块       |

如果你知道明文长度与块长度对齐（如上例所示），那么你*已经知道*最后一个块的明文了（它只是填充字节！）。
一旦你知道它全是填充，你就可以丢弃它，并开始攻击*倒数第二个*块（在这个例子中就是密文块 2）！
你将尝试篡改明文的最后一个字节（通过修改与之异或的 IV），直到填充验证成功，然后利用这一点恢复（并能够控制）最后一个字节，再继续后续操作。
这仍然是同样的填充提示攻击（POA），但攻击目标变成了*倒数第二个*块，因为最后一个块全是填充！
- 将之前的单块处理程序修改为多块（仅需将之前的部分转为函数，然后在新的main中分块后调用）

### AES-密码分组链接模式-填充预言攻击-多分组

让我们把前两个挑战的内容结合起来。
之前的关卡只有一个密文块（无论它最初就是如此，还是你通过丢弃全填充块迅速达到此状态），因此，你可以通过修改与该块异或的 IV 来操纵其解密后的明文。

这一关加密的是真正的 flag，因此包含多个实际含有数据的密文块。
请记住，要操纵第 N 个块的解密，你必须修改第 N-1 个密文块。
对于第一个块，这个可修改的对象就是 IV；但对于后续的块，它就不是 IV 了！

这是本模块中*最具挑战性的关卡之一*，但只要你一步一步来，就能理清思路。
那么，你还在等什么呢？
去把 flag 恢复出来吧！
- 之前已经实现多块处理，无需修改

### AES-密码分组链接模式-填充预言攻击-加密

你可能会觉得难以置信，但是... 填充提示攻击（Padding Oracle Attack）不仅能让你解密任意消息：它还能让你*加密*任意数据！
这听起来太疯狂了，像是假的，但它是真的。
想一想：你已经证明了可以通过篡改前一个密文块来修改当前块的解密字节。
不幸的是，这会导致前一个块解密出一堆乱码。
但这真的很糟糕吗？
你可以利用填充提示攻击来精确恢复出这些乱码的值，然后再去篡改更前一个块，把这些乱码明文“修复”成你想要的有效数据！
如此反复，你就可以在不知道密钥的情况下，精心构造出完全由你控制、任意长度的合法密文！
当你追溯到 IV 时，只需把它当作一个普通的密文块来处理（比如，在它前面放一个假的 IV，然后照常解密）并继续操作即可！
简直不可思议。

现在，你已经掌握了完成本次挑战所需的知识。
去吧，去伪造你的消息，拿到 flag！

- 结合之前两种：篡改明文、填充提示。  
- 篡改n块明文，得到n-1块乱码密文
- 填充提示可得到n-1密文对应的中间异或串
- 除第n块外的其他块均由 `n-1异或串 ^ n-1段目标明文 = n-2段密文` 得到密文
- 填充提示可得到n-2及其他段密文对应的中间异或串

- 目标明文分段时记得向上取整而不是整除

----

**趣味事实：**
尽管填充提示攻击在 [2002 年](https://www.iacr.org/archive/eurocrypt2002/23320530/cbc02_e02d.pdf) 就被发现了，但直到 2010 年研究人员才 [发现了这种任意加密的能力](https://static.usenix.org/events/woot10/tech/full_papers/Rizzo.pdf)。
想象一下在那 8 年里，网络是多么脆弱！
不幸的是，填充提示攻击*至今*仍然是一个问题。
在 Web 基础设施中，每隔几个月就会出现新的填充提示漏洞，截至本文撰写时，[最新的一个就在几周前](https://www.cvedetails.com/cve/CVE-2024-45384/)！

### AES-密码分组链接模式-填充预言攻击-加密-2

现在，你之前是从一个有效的输入（加密的 `sleep` 命令）开始的。
如果你*零个*有效的输入呢？
事实证明，这套攻击方法依然有效！

为什么呢？
随机数据解密后会得到...另一串随机数据。
这串数据很可能存在填充错误。
你可以像之前一样控制 IV，来找出正确的第 16 个字节进行异或操作，从而修复这个填充错误。这样，你就得到了一个代表 15 字节随机消息的合法密文。
对你来说，这个随机消息和 `sleep` 命令没有本质区别：后续的攻击步骤是完全一样的！

现在就去试试吧。
没有调度器，只有你和 flag。

- 在之前挑战代码的分支中，将n段的sleep获取n段异或串后，得到n-1段的乱码密文修改为：  
    n段时对随机数据使用填充提示，得到n段的异或串，使用此异或串与明文得到n-1段密文（即，将之前的分支修改为调用一次填充提示函数，再异或）。


## 非对称密码学 Asymmetric Cryptography

- 查看模块视频与幻灯片

### Diffie-Hellman 密钥交换（DHKE）

所以，你现在（希望如此！）已经理解了高级加密标准（AES）的用途以及其中的各种难点，但有一个问题我们尚未考虑。如果人物A（通常被称为 [Alice](https://en.wikipedia.org/wiki/alice_and_bob)）想要加密一些数据并通过AES发送给人物B（通常被称为Bob），他们必须首先协商一个密钥。如果Alice和Bob能当面见面，一方可以把密钥写下来交给另一方。但这很少发生——通常情况下，密钥必须远程建立，Alice和Bob分别位于一个（尚未加密的！）网络连接的两端。在这些常见情况下，Alice和Bob必须安全地生成一个密钥，即使他们正在被窃听（想象一下：网络嗅探）！

有趣的是：通常，窃听者被称为Eve。一种在非秘密信道上生成秘密密钥的“经典而可靠”的算法是 [Diffie-Hellman密钥交换](https://en.wikipedia.org/wiki/diffie%e2%80%93hellman_key_exchange)（DHKE）！DHKE利用数学的力量（特别是有限域）来生成密钥。让我们一步步来看：

1.  首先，Alice和Bob商定一个大的质数 `p` 来定义他们的有限域（例如，所有后续操作都在 *模 `p`* 下进行：一个数值范围从 `0` 到 `p-1` 然后循环的上下文），以及一个*原根* `g`，并在公开场合交换它们，乐意让Eve看到。
2.  接着，Alice和Bob各自生成一个*秘密*数字（Alice的为 `a`，Bob的为 `b`）。这些数字永远不会共享。
3.  Alice计算 `A = (g ** a) mod p`（`g` 的 `a` 次方模 `p`），Bob计算 `B = (g ** b) mod p`。Alice和Bob在公开场合交换 `A` 和 `B`。
4.  此时，Eve将拥有 `p`、`g`、`A` 和 `B`，但无法恢复出 `a` 或 `b`。如果不是在有限域中，通过以 `g` 为底的对数可以轻易恢复：`log_g(A) == a` 且 `log_g(B) == b`。然而，在模运算下的有限域中这行不通，因为从概念上讲，我们无法有效确定 `g ** a` 这个计算从 `p-1` 到 `0` “循环”了多少次，而这正是计算对数所必需的。这种在有限域中的对数问题被称为 [离散对数](https://en.wikipedia.org/wiki/discrete_logarithm) 问题，除非使用量子计算机，否则没有有效的解决方法。量子计算机解决这个问题的能力是它们对密码学构成最直接威胁的原因。
5.  Alice计算 `S = (B ** a) mod p`，由于 `B` 是 `(g ** b) mod p`，这得到 `S = ((g ** b) ** a) mod p`，或者应用初中数学，`S = (g ** (b*a)) mod p`。Bob计算 `S = (A ** b) mod p`，由于 `A` 是 `(g ** a) mod p`，这得到 `S = (g ** (a*b)) mod p`。由于 `a*b == b*a`，Bob和Alice计算出的 `S` 值是相等的！
6.  Eve *无法* 计算 `S`，因为Eve没有 `a` 或 `b`。Eve可以计算 `A ** B == g ** a ** g ** b`，但这并不能让Eve更接近 `S`！Eve也可以计算 `A * B == (g ** a) * (g ** b) == g ** (a+b)`，但这仍然不是Bob和Alice得到的 `S == g ** (a*b)`。Eve运气不佳！

因为 `A` 和 `B` 是公开的，它们被称为*公钥*，而 `a` 和 `b` 则是*私钥*。此外，你可能注意到在本关卡中我们使用的质数 `p` 是硬编码的，实际上，针对不同的比特长度存在推荐的DHKE [标准质数](https://datatracker.ietf.org/doc/html/rfc3526)。这些质数的标准化使得Alice和Bob只需发布 `A` 和 `B`（尽管在实际应用中，为了支持在某些场景下使用不同的 `p`，`p` 通常也会被传输）。

在这个挑战中，你将执行一次Diffie-Hellman密钥交换。祝你好运！

### Diffie-Hellman 密钥交换转 AES 加密

你可能已经注意到，Diffie-Hellman（DH）实际上并不能直接让你加密数据：它的全部作用就是为Alice和Bob双方**生成**一个相同的秘密值。
这个值是无法**被选择的**，Alice和Bob得到的 `s` 是由 `a`、`b`、`p` 和 `g` 的值唯一确定的！

这种单一秘密的特性并不一定是DHKE的缺点。
这正是它的设计目的：让你交换一个秘密以供后续使用。

那么，Alice和Bob究竟如何使用DHKE来交换信息呢？
答案就在它的名字里：Diffie-Hellman**密钥交换**。
当然，这个秘密值可以被用作（例如）对称密码的**密钥**，Alice和Bob之间的信息就可以用那个密码进行加密了！

凭借你掌握的DHKE知识，你现在将构建一个类似于真实应用的**密码系统**！
你将使用DHKE来协商一个AES密钥，而本关卡将使用该密钥来加密flag。
解密它，然后赢得胜利！

### RSA 1

Diffie-Hellman（DH）允许Alice和Bob在没有预共享秘密信息的情况下，生成一个单一的（但不可控的）共享秘密。
接下来，我们将学习另一种密码系统——[RSA（Rivest–Shamir–Adleman）](<https://en.wikipedia.org/wiki/RSA_(cryptosystem)>)加密算法，它允许Alice和Bob在没有预共享秘密信息的情况下，生成任意数量的可控消息！

RSA巧妙地利用了模幂运算（你在DH中已经体验过）和 [欧拉定理](https://en.wikipedia.org/wiki/Euler%27s_theorem) 的相互作用，赋予了Bob或Alice对整个有限域的*非对称*控制权。
Alice生成两个质数 `p` 和 `q`，*并对它们保密*，然后将它们相乘得到 `n = p*q`。Alice发布 `n` 以定义一个模 `n` 的有限域。
欧拉定理以及对 `p` 和 `q` 的了解，赋予了Alice（*且仅Alice一人*）在这个特定域内的完全能力（这与DH不同，在DH中所有参与者在域内具有同等能力！）。

欧拉定理告诉我们，在模 `p*q` 的域中，*指数*上的运算（例如 `m**(e*d) mod n` 中的 `e*d`）是在 `(p-1)*(q-1)` 的域中进行的。
这个定理的*原因*涉及一些高等数学知识，老实说，没几个人能完全理解，但其结论却非常有趣。
对于Alice来说（由于知道 `p` 和 `q`），计算 `(p-1)*(q-1)` 是轻而易举的事，但对其他任何人来说都是不可能的（假设 `p` 和 `q` 足够大），因为人类目前缺乏一种能高效分解大质数乘积的算法！

还记得 `m**(e*d) mod n` 指数中的 `e*d` 吗？
对于任意一个 `e`，只要知道了 `(p-1)*(q-1)`，Alice就能计算出一个 `d`，使得 `e*d == 1`。
虽然这看起来很简单，但这正是RSA的核心所在。
Alice选择一个数 `e`（通常是一个较小的数以减少计算开销，但也不能太小以免引发某些安全问题），然后计算出相应的乘法逆元 `d`。
这就引出了对明文 `m` 的加密过程（`m**e mod n == c`）以及解密过程！`c**d mod n == (m**e)**d mod n == m**(e*d) mod n == m**1 mod n == m`。
与DH那种单一且不可控的 `s` 不同，RSA的消息 `m` 可以是任意选定的（只要大小不超过 `n`，因为该域无法表示更大的数字）。

RSA是*非对称*的。
Alice将 `n` 和 `e` 作为公钥公开，而将 `d` 作为私钥保密。
知道了 `n` 和 `e`，Bob就可以加密消息并发送给Alice，而只有Alice能够解密它们。
由于 `e*d == d*e`，Alice*可以*用 `d` 来加密消息，但既然 `e` 是公开的，*任何人都能*解密这些消息。
这听起来可能有点奇怪，但这在某些场景下很有用，例如，可以用来证明某条消息只能来自Alice，因为只有知道 `d` 才能进行这种操作。

要回复Bob，Alice就需要Bob自己的公钥，这将是*Bob的* `n`（与Alice的 `n` 不同，由Bob自己保密的 `p` 和 `q` 生成！）和 `e`（这个值通常是相同的最小安全值，目前是 `65537`，但随着新攻击手段的出现可能会改变）。

在这个挑战中，你将解密一个用RSA（Rivest–Shamir–Adleman）加密的秘密。
这次，为了让你感受整个过程的运作方式，公钥和私钥都会提供给你。
开始吧！

### RSA 2

Alice在模 `n` 下的超能力来自于对 `p` 和 `q` 的了解，以及由此产生的计算 `e` 在指数中的乘法逆元的能力。
每个使用RSA的人都有一个担忧，那就是他们的 `n` 会被分解，攻击者将获得 `p` 和 `q`。

这种担忧并非没有道理。
虽然我们*相信*因数分解是困难的，但我们并没有实际的证据来证明这一点。
明天出现一位“欧拉2.0”，发表一个专门用于分解的算法，也并非完全不可能。
然而，我们*确实*知道，功能完备的量子计算机能够进行因数分解：“欧拉2.0”（实际上是 [Peter Shor](https://en.wikipedia.org/wiki/Peter_Shor)）已经提出了这样的[算法](https://en.wikipedia.org/wiki/Shor%27s_algorithm)！
当量子计算机达到足够的功率水平时，RSA就完蛋了。

在这个挑战中，我们把量子计算机（或者至少是把 `n` 的因子）给了你！
利用它们来解密我们用RSA（Rivest–Shamir–Adleman）加密的flag。

### RSA 3

在本挑战中，你将完成一个RSA挑战-响应。
公钥和私钥都将提供给你。

```py
def input_hex(name):
data = input_(name)
try:
    return int(data, 16)

def level11():
    """
    In this challenge you will complete an RSA challenge-response.
    You will be provided with both the public key and private key.
    """
    key = RSA.generate(2048)

    show_hex("e", key.e)
    show_hex("d", key.d)
    show_hex("n", key.n)

    challenge = int.from_bytes(get_random_bytes(256), "little") % key.n
    show_hex("challenge", challenge)

    response = input_hex("response")
    if pow(response, key.e, key.n) == challenge:
        show("flag", flag.decode())
```
- 只需对challenge数字进行签名，最后使用十六进制格式提交

### RSA 4

在这个挑战中，你将完成一个RSA挑战-响应。你需要提供公钥。

```py
def level12():
    """
    In this challenge you will complete an RSA challenge-response.
    You will provide the public key.
    """
    e = input_hex("e")
    n = input_hex("n")

    if not (e > 2):
        print("Invalid e value (e > 2)", file=sys.stderr)
        exit(1)

    if not (2**512 < n < 2**1024):
        print("Invalid n value (2**512 < n < 2**1024)", file=sys.stderr)
        exit(1)

    challenge = int.from_bytes(get_random_bytes(64), "little")
    show_hex("challenge", challenge)

    response = input_hex("response")
    if pow(response, e, n) == challenge:
        ciphertext = pow(int.from_bytes(flag, "little"), e, n).to_bytes(256, "little")
        show_b64("secret ciphertext", ciphertext)
```
- 生成RSA密钥后以十六进制提交公钥与模数，得到挑战串后签名再提交。
- 挑战程序返回base64编码的公钥加密的flag

### RSA 签名

因此，通过使用 `d`，Alice可以加密数据，而（由于 `n` 和 `e` 包含在公钥中）任何人都可以解密这些数据...
这看起来可能很傻，但它实际上实现了一种我们在本模块中尚未见过的能力：能够向多方证实某条消息确实来自Alice。
这可以看作是一种密码学意义上的笔墨签名，事实上，它就被称为*签名*！

本关卡将探讨RSA签名的一种应用（以及一个陷阱）。
回忆一下 `c == m**e mod n`，并回想初中数学知识 `(x**e)*(y**e) == (x*y)**e`。
这个性质在 `mod n` 下同样成立，你大概能看出这里的问题了...

本关卡为你提供了一个签名预言机（signing oracle）。
去利用它来伪造一条flag命令吧！

- 已知公钥 e 与模数 n
- 挑战程序 dispatcher 对输入使用私钥签名后，编码为base64回显
- 挑战程序 worker 对base64输入使用公钥解密
- 在可任意加密时，使用两个签名相乘获得目标签名以伪造。
- 此处 dispatcher 禁止了直接创造flag的签名，但仍可对目标明文进行“盲化”（可还原的混淆）
    ```py
    # dispatcher
    if b"flag" in command:
        print(f"Command contains 'flag'")
        sys.exit(1)
    ```

    - 设 `m` 为目标明文
        选择一个随机但对 `n` 可逆（互质）的 `r`（盲化后还原），范围`1 < r < n`：
        - `r` 的逆元 `r_inv = r^(-1) mod n`
        - 计算盲化部件 `re = r^e mod n` 
        - 对目标明文进行盲化 `m_blind = (m * re) mod n` 


    - 发送盲化后的数据到预言机
        得到 
        ```
        sig_blind 
            = (m_blind)^d mod n 
            = (m * re)^d mod n 
            = (m * r^e)^d mod n 
            = (m^d * r) mod n
        ```  
        
    - 去盲化
        ```
        sig_blind = (m^d * r) mod n

        (sig_blind * r_inv) mod n
            = (m^d * r*r^(-1)) mod n
            = (m^d) mod n 
            = sig_m
        ```
    
    使用可逆部件盲化被禁止的目标明文后，由预言机加密，再使用逆元消除盲化

    **必须全程 mod n** ：盲化/去盲化都是模乘法，不是普通整数乘除。
    **r 必须可逆**


## 密码学哈希 Cryptographic Hashes

### 安全散列算法 1（SHA-1）

正如你所见，原始的RSA签名是个坏主意，因为它们可以被伪造。
在实践中，人们签署的是事物的[*密码学哈希*](https://en.wikipedia.org/wiki/Cryptographic_hash_function)。
哈希是一种单向函数，它能接收任意长度的输入（例如，几个字节或几千兆字节甚至更多），并输出一个短小的（例如，32字节）哈希值。
对哈希输入的任何更改都会*扩散*并影响到整个输出的密码学哈希值，且这一过程是不可逆的。

因此，安全哈希是原始数据的一个良好代表：如果Alice签署了一条消息的哈希值，那么该消息也可以被视为已被签署。
更好的是，由于哈希是可控可逆或可修改的，攻击者即便能够修改哈希值，也无法在新的消息上伪造签名。

密码学哈希算法的致命弱点是*碰撞*。
如果攻击者能够精心构造两条具有相同哈希值的消息，那么任何依赖该哈希的系统（如上述RSA签名方案）的安全性都可能受到威胁。
例如，比特币的安全性就完全依赖于SHA256的抗碰撞能力...

虽然目前尚未发现SHA256的完整碰撞，但某些应用程序会使用*部分*哈希验证。
这并不是一种好的做法，因为它使得暴力破解碰撞变得更加容易。

在这个挑战中，你将使用安全哈希算法（SHA256）对数据进行哈希。
你需要找到一个小的哈希碰撞。
你的目标是找到一段数据，其哈希值与秘密数据的哈希值相同。
只有SHA256哈希值的前3个字节会被检查。

提高性能：
- 使用 `os.urandom(n)` 或 `secrets.token_bytes(n)` 随机生成字节，而不是生成int再转bytes
- 在判断相等条件处检测3个bytes，而不是3个bytes转换的str

### 安全散列算法 2（SHA-2）

在这个挑战中，你将使用安全哈希算法（SHA256）对数据进行哈希。
你需要完成一个小的*工作量证明*。
你的目标是找到一段响应数据，当这段数据被附加到挑战数据之后并进行哈希运算时，生成的哈希值需要以2个空字节开头。

## 信任

### 传输层安全协议 1（TLS 1）

在这个挑战中，你将处理公钥证书。
你将获得一个自签名的根证书。
同时，你将获得根证书的私钥，并且必须使用该私钥来签署一个用户证书。

- 挑战程序模拟CA
    创建：
    - 生成RSA密钥
    - 创造公钥结构（json）并使用 SHA256 哈希
    - 使用私钥对哈希内容进行签名

    输入：
    * 提交base64编码的数据（json）与签名

    验证：
    - 提交的数据是否使用恰当结构与字段，是否使用白名单CA
    - 通过验证后使用提交的公开信息对flag进行加密

- 提交内容：
    - 自己的证书（名称，公钥信息，签发者），从python字典转为JSON格式，之后按b64输出
    - 签发者对自己的证书的SHA256哈希摘要的RSA签名
        - 程序提供的是CA的证书，于是先b64解码，再对JSON提取

### 传输层安全协议 2（TLS 2）

在这个挑战中，你将扮演服务器，执行一个简化的传输层安全性（TLS）握手。
你将获得Diffie-Hellman参数、一个自签名的根证书以及根证书的私钥。
客户端将请求与特定名称建立一个安全通道，并启动一次Diffie-Hellman密钥交换。
服务器必须完成该密钥交换，并从交换得到的秘密中派生出AES-128密钥。
然后，服务器必须通过这个加密通道，提供由根证书签署的、被请求的用户证书。
最后，服务器必须通过加密通道签署握手消息，以证明其拥有该用户证书的私钥。

- 仍需从b64编码的json内容提取CA的n

```py
a = getrandbits(2048)
A = pow(g, a, p)
show_hex("A", A)

B = input_hex("B")
s = pow(B, a, p)
key = SHA256Hash(s.to_bytes(256, "little")).digest()[:16]
cipher_encrypt = AES.new(key=key, mode=AES.MODE_CBC, iv=b"\0"*16)
cipher_decrypt = AES.new(key=key, mode=AES.MODE_CBC, iv=b"\0"*16)
```
- 交换公开g/p以及自选指数的pow值后，客户端与服务器创建共同秘密
    - 发送自己的自选pow，读取对方的pow，双方将对方的pow为底与自选指数与公开模数一起创建共同秘密

```py
def decrypt_input_b64(name):
    data = input_b64(name)
    try:
        return unpad(cipher_decrypt.decrypt(data), cipher_decrypt.block_size)
    except ValueError as e:
        print(f"{name}: {e}", file=sys.stderr)
        exit(1)

user_certificate_data = decrypt_input_b64("user certificate")
user_certificate_signature = decrypt_input_b64("user certificate signature")
user_signature = decrypt_input_b64("user signature")
```
- 提交证书、证书签名、状态确认签名
    - 设置证书的name字段为程序提供的字符串
    - 与之前挑战相同的使用CA对证书的SHA256哈希进行签名
- 使用AES通信，于是需对内容进行对齐后加密再base64编码


```py
user_signature_data = (
    name.encode().ljust(256, b"\0") +
    A.to_bytes(256, "little") +
    B.to_bytes(256, "little")
)
user_signature_hash = SHA256Hash(user_signature_data).digest()
user_signature_check = pow(
    int.from_bytes(user_signature, "little"),
    user_key["e"],
    user_key["n"]
).to_bytes(256, "little")[:len(user_signature_hash)]

if user_signature_check != user_signature_hash:
    print("Untrusted user: invalid signature", file=sys.stderr)
    exit(1)
```
- 状态确认签名：检查之前步骤的所有内容是否被篡改
    - 服务器对之前内容的hash摘要，使用私钥进行签名。此处客户端对解密后的hash进行截断后（到32位）与计算的hash（32位）比较。但发送时应当发送完整签名