# 逆向工程

欢迎学习逆向工程入门！逆向工程是一项关键技艺，您将在pwn.college的探索之旅中逐步掌握它。本次旅程将从Connor图像格式（cimg）开始。您此前从未听说过cimg，这种格式在现实世界中并不实际存在，但通过本模块的学习，您将借助分析多个版本的cimg渲染二进制文件来*逆向工程*该格式。当您完成最后一关时，将会实现从对cimg一无所知到完全理解它的跨越——这条路径您将在未来面对众多不同程序时反复践行。

### 其他资源

互联网上存在大量与逆向工程相关的资源。
- 入门推荐亚利桑那州立大学Adam Doupe在其[YouTube频道](https://www.youtube.com/watch?v=qgt-0ooafcm&list=PLk06xt3HfpZiMAzj8QUoqc8ivAeBrlZWh)发布的系列黑客挑战实战教程。
- 全面的逆向工程[教程系列](https://github.com/mytechnotalent/reverse-engineering)。

### 实用工具

如幻灯片所述，本作业有许多实用工具！以下为不全面的列表：
* `gdb` 可用于运行和检查程序状态。请查阅调试复习模块，此处也提供快速指南。重要概念：
    * 区分 `step instruction` (`si`) 与 `next instruction` (`ni`)：`si` 会跟随跳转指令进入子程序，`ni` 则直接执行完跳转指令。使用 `si` 可能误入 libc 库代码层，增加调试复杂度。
    * `x/i $rip` 可反汇编下条待执行指令，`display/i $rip` 可设置为每次输入提示时自动显示。支持扩展格式如 `x/2i` 显示两条指令。
    * `disas` 命令反汇编当前函数。
    * gdb 支持脚本化！参考手册了解条件断点和可脚本化断点。
    * 现代二进制文件采用*位置无关*设计，运行时载入内存地址不固定。gdb 默认加载偏移地址为 `0x555555554000`。若 objdump 显示 main 函数地址为 `0x100`，则 gdb 调试时实际地址为 `0x555555554100`。
* `strings` 可列出文件中可打印字符串，用于查找程序校验的固定字符串（如文件名等）。注意可通过参数设置最小输出字符串长度。
* 勿忘 pwntools！需频繁与程序交互时请优先选用。
* `rappel` 可用于分析特定指令功能。
* 逆向工程实战工具（Dojo环境内置）：
    * IDA 是行业标准级逆向工具。
    * Ghidra 作为开源方案直接对标 IDA，广受好评。
    * Binary Ninja 是 IDA 的替代产品。
    * angr-management 是具备高级功能的开源新兴工具。
    * 应急方案：`objdump -d -m intel the_binary` 可反汇编目标文件，其中 `-m intel` 参数输出易读的英特尔语法汇编代码。

## 挑战

### 文件格式：魔数（Python）

道场的前几个挑战将引导您创建首个基础cIMG图像。当然，此举的目的并非创作图像，而是通过逆向其二进制文件，亲身体验理解程序逻辑及数据格式的过程。

本关的 `/challenge/cimg` 二进制文件是一个（初始版本的）图像渲染程序，专门处理cIMG格式。软件通过以下几种方式识别文件格式（例如判断文件是GIF、JPEG还是MP3等）：

1. 文件扩展名  
   即文件名中`.`后的部分：`ZardusSmiling.jpg` 很可能是Zardus微笑的JPEG图像，而 `KanakLaughing.mp3` 可能是Kanak笑声的MP3音频文件。
2. *魔数*  
   文件可能被重命名，或关联文件名丢失（如文件系统部分故障）甚至缺失（如数据流中）。因此多数文件格式会包含可供解析器校验的*魔数*。

您早已接触过许多含魔数的文件。例如处理过的ELF二进制文件均以字节 `\x7fELF` 开头。对人类而言这像有语义的字符串，但计算机将其读取为数字，故得此名。

本挑战要求您制作一个包含正确魔数且扩展名为 `cimg` 的文件。您可通过逆向 `/challenge/cimg` 二进制文件获取该魔数。若成功通过魔数验证，即可获得flag！

注：
- python作为解释型语言的源码
----

**方法建议：**  
以下建议或有助于入门：

- 逆向工程可采用静态分析（如使用IDA等图形化逆向工具分析静态程序）或动态分析（如通过gdb等调试器运行目标程序）。本模块推荐结合使用这两种技术：用图形化工具建立假设（如"程序在某汇编指令地址将输入字节与某些值比较"），再通过gdb验证（如在对应地址设断点，查看比较的寄存器值并与输入关联）。
- **弃用objdump**  
  您可能曾用objdump查看汇编代码。或可凭此通过本关（及下一关），但**若无图形化逆向工具则无法完成本模块**。请以此挑战为契机熟悉图形化逆向工具。
- 复盘成功解法  
  若未同时使用图形化逆向工具和调试器（gdb）即通过本关，请用未使用的工具重新验证解法。此举有助于掌握工具在后续关卡中的应用，建议在所有未同时使用两种工具解决的挑战中进行实践。

### 文件格式：魔数（C）

Now in C!

注：
- 作为第2个挑战，提供了c源码以及二进制文件

### 文件格式：魔数（x86）

Now in x86!

注：
- `gdb --args /challenge/cimg /home/hacker/myimg.cimg` 一种在gdb命令行中带参数启动命令，还可在gdb内的 run 或 start 后添加参数
- 作为第3个挑战，提供了二进制文件
- 复制挑战的二进制文件：
    1. 将二进制文件编码为 Base64 格式  
        `base64 /challenge/cimg > ~/myrun`
    2. 复制base64编码后的字符串到本机
    3. 使用python的base64库解码，还原二进制文件
        `binary_data = base64.b64decode(base64_data)`
- 将二进制文件上传到 `cloud.binary.ninja` 进行静态可视化分析
- 使用gdb动态分析验证

### 读取字节序（Python）

计算机验证*魔数*最便捷的方式是将其视为一个数字。这正是本挑战中 `/challenge/cimg` 所演示的，以便展示这类操作在实际中的典型实现方式。此处使用的*魔数*与之前挑战不同（否则就无需反转二进制！）。反转二进制数据，注意字节序，通过*魔数*检查即可获得flag。
- 注意大小端顺序

### 读取字节序（C）

Now in C!

### 读取字节序（x86）

Now in x86!

### 版本信息（Python）

解析*演进中*的文件格式的程序必须能够判断需要解析的格式版本。这一信息通常直接存储在魔数附近。请思考如何为 `/challenge/cimg` 提供正确的 cimg 版本！

---- 

**写入二进制数据：**  
在本关卡中，您需要创建包含*无法通过键盘输入*的字符的文件。可通过多种方式实现，其中一种方法是编写 Python 脚本生成目标文件：

首先打开待写入的文件：

```python
with open("my-file", "wb") as out_file:
```

其中的 `"wb"` 参数指示 Python 以原始字节写入模式打开 "my-file" 文件。

随后即可进行写入操作。常规文件写入方式如下：

```python
with open("my-file", "wb") as out_file:
    out_file.write(b"HELLO WORLD")
```

可见，常规可输入字符可直接放入 Python 字节字符串进行写入。

对于特殊字符的处理：如前所述，在 Python 字节字符串中可通过 `\x` 转义序列指定原始字节值。例如 \\x41 会生成十六进制值为 0x41 的字节（对应 ASCII 字符 A）。以下示例展示另一种写入方式：

```python
with open("my-file", "wb") as out_file:
  out_file.write(b"HELLO \x57\x4f\x52\x4c\x44")
```

此操作同样会向文件写入 `hello world`！Python 在执行代码时会自动解析字节字符串中的转义序列。

对于非常规字符的生成，例如在 `hello world` 后插入空字节（值为 0）：

```python
with open("my-file", "wb") as out_file:
  out_file.write(b"HELLO \x57\x4f\x52\x4c\x44\x00")
```

空字节与众多难以直接输入的字节值广泛存在于二进制格式和协议中。部分常用字符提供简写转义序列，例如：

```python
assert b"\0" == b"\x00" # our null byte
assert b"\n" == b"\x0a" # a newline
```

此外需对可能干扰 Python 语法的字符进行转义。例如输出 `hello "world"!` 的写法：

```python
with open("my-file", "wb") as out_file:
  out_file.write(b"HELLO \"WORLD\"!")
```

双引号必须转义以避免被识别为字节字符串终止符。

---- 

**写入整数值：**  
文件格式中的部分字节通常以小端序表示整数值。写入时需要将常规整数（如 `5`）转换为二进制表示（取决于变量长度，例如 32 位/4 字节的 `1` 对应 `b"\x05\x00\x00\x00"`）。推荐使用 Python 的 `struct` 包进行整数与原始字节的转换：

```python
with open("my-file", "wb") as out_file:
  # this packs the integer 1337 (0x539 in hex) into four little-endian bytes
  out_file.write(struct.pack("<I", 1337))

  # the above is equivalent to
  out_file.write(b"\x39\x05\x00\x00")

  # this packs the integer 1337 (0x539 in hex) two little-endian bytes
  out_file.write(struct.pack("<H", 1337))

  # the above is equivalent to
  out_file.write(b"\x39\x05")
```

如需了解其他格式说明符，请参阅 [struct 官方文档](https://docs.python.org/3/library/struct.html#format-characters)。

### 版本信息（C）

Now in C!
- 查看结构字段的大小

### 版本信息（x86）

Now in x86!
- 查看结构字段或比较的大小

### 元数据与数据（Python）

让我们继续构建 cIMG 格式。  
图像需要什么？  
尺寸！  
在此指定正确的尺寸，并获取你的旗帜！

### 元数据与数据（C）

Now in C!

### 元数据与数据（x86）

Now in x86!

### 输入限制（Python）

某些程序会对其输入数据施加特定约束。
请继续构建你对 *cIMG* 格式的理解，但需注意 `/challenge/cimg` 在本关卡中对需发送的附加数据所设置的限制。

### 输入限制（C）

Now in C!

### 输入限制（x86）

Now in x86!

### 认识cIMG！（Python）

现在该查看你的第一个 *cIMG* 了！
让程序显示具有正确属性的图像，它将给你旗帜。

### 认识cIMG！（C）

Now in C!

### 认识cIMG！（x86）

Now in x86!

### 基础cIMG（Python）

现在该升级到新版 *cIMG* 格式了，这让我们离取代陈旧乏味的传统网络图像格式更近一步。
请识别差异之处，理解 `/challenge/cimg` 的需求，并获取旗帜！
- 更新了像素格式
    `Pixel = namedtuple("Pixel", ["r", "g", "b", "ascii"])`
- 输出的格式化字符串为终端颜色序列

### 基础cIMG（C）

Now in C!

### 基础cIMG（x86）

Now in x86!

### 内部状态迷你版（C）

程序会维护关于已执行或待执行操作的广泛*内部状态*。  
此版本 `/challenge/cimg` 追踪的状态量远超以往，使其能在授予旗帜前对输入数据施加严格约束。  
请解析程序期望的图像内容并成功得分！

```c
define COLOR_PIXEL_FMT "\x1b[38;2;%03d;%03d;%03dm%c\x1b[0m"
char desired_output[] = "
\x1b[38;2;154;172;010mc\x1b[0m
\x1b[38;2;053;095;225mI\x1b[0m
\x1b[38;2;132;094;067mM\x1b[0m
\x1b[38;2;205;036;086mG\x1b[0m
\x00";
```

----
**方法建议：**  
本挑战会如常处理并显示输入数据，同时维护预期状态进行校验。  
可采用典型逆向工程流程中的以下方法理解输入要求：

1. 解析程序授予旗帜所需的内部状态条件  
   建议结合图形化逆向工具（如 IDA）形成程序处理逻辑的假设，并通过运行时调试器（如 gdb）验证。例如：当程序执行到特定汇编指令时决定是否授予旗帜。先在逆向工具中定位该节点，再通过 gdb 实时验证理解。需重点分析校验数据*含义*（至少宏观层面），通常程序会对比可疑数据（如图像的某种变换结果）与已知合规数据。本例中的合规数据是什么？

2. 分析程序如何将输入数据转化为校验用的可疑数据  
   程序通过特定算法转换输入数据，需理解该算法逻辑。能否通过 gdb 验证假设？能否利用该知识微调输入以改变程序行为（例如让程序在判定失败前多执行几步）？

3. 构建逆向算法  
   多数从 A（输入数据）到 B（被校验的可疑数据）的转换算法可逆推。能否基于第 2 步的结论构建从 B 反推 A 的算法？建议先手动测试算法对程序处理逻辑的影响。

4. 提取程序预期的合规状态数据  
   可通过图形化逆向工具或 gdb 提取程序期待的内部状态并保存至文件。

5. 生成触发预期状态的输入数据  
   将第 3 步的算法应用于第 4 步提取的合规状态，生成能触发目标状态的输入数据。添加必要元数据（如魔数等）后提交至程序即可。

### 内部状态迷你版（x86）

Now in x86!

### 内部状态（C）

Now with a bigger framebuffer!
- 分析格式进行模式匹配  
  `pattern = re.compile(r".+?\[38;2;(.{3});(.{3});(.{3})m(.{1}).+?\[0m")`

```text
.--------------------------------------------------------.
|                                                        |
|                             ___   __  __      ____     |
|                 ___        |_ _| |  \/  |    / ___|    |
|                / __|        | |  | |\/| |   | |  _     |
|               | (__         | |  | |  | |   | |_| |    |
|                \___|       |___| |_|  |_|    \____|    |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
'--------------------------------------------------------'
```

### 内部状态（x86）

Now in x86!
- gdb 保存输出内容到日志文件：
    `set print elements 0` 关闭显示的元素数目限制
    `set logging file gdb_log_output.txt` 设置日志文件
    `set logging on` 日志记录开始
    `set logging off` 日志记录停止

- gdb 导出内存范围的二进制内容到文件：
    `dump binary memory out.bin 起始地址 结束地址`
    - 使用 `info files` 获取 `.rodata` 的末尾作为结束地址
    这将超出预期内容，之后需裁剪

```text
.---------------------------------------------------------------.
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                        ____   |
|          ___                           ___            / ___|  |
|         / __|                         |_ _|  __  __  | |  _   |
|        | (__                           | |  |  \/  | | |_| |  |
|         \___|                          | |  | |\/| |  \____|  |
|                                       |___| | |  | |          |
|                                             |_|  |_|          |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
|                                                               |
'---------------------------------------------------------------'
```

### 文件格式：指令（C）

现在我们将对 *cIMG* 的高层设计做出最终调整。
文件格式通常会为解析程序提供若干*指令*以执行不同操作。
例如在 HTML 文件中，每个标签都是一条指令，会触发渲染引擎执行相应操作。
图像文件亦是如此。
我们将通过为 *cIMG* 引入类似概念，开始探索格式与解析器之间的这种关联。
- 注意新格式

```text
.----------------------------------------------------------.
|                                                          |
|                                                          |
|                                                          |
|                              ___                         |
|                     ___     |_ _|                        |
|                    / __|     | |                         |
|                   | (__      | |      __  __             |
|                    \___|    |___|    |  \/  |     ____   |
|                                      | |\/| |    / ___|  |
|                                      | |  | |   | |  _   |
|                                      |_|  |_|   | |_| |  |
|                                                  \____|  |
|                                                          |
|                                                          |
|                                                          |
'----------------------------------------------------------'
```

### 文件格式：指令（x86）

Now in x86!

```text
.---------------------------------------------------.
|                                                   |
|                                                   |
|                                                   |
|                                                   |
|                                                   |
|                                                   |
|                                                   |
|                                                   |
|                                                   |
|         ___        ___                            |
|        / __|      |_ _|                    ____   |
|       | (__        | |          __  __    / ___|  |
|        \___|       | |         |  \/  |  | |  _   |
|                   |___|        | |\/| |  | |_| |  |
|                                | |  | |   \____|  |
|                                |_|  |_|           |
|                                                   |
|                                                   |
|                                                   |
'---------------------------------------------------'
```

### 补丁指令

支持不同的指令允许实现相当高级的cimg功能。例如，您之前需要通过明确指定所有像素来创建所需图像。然而，随着本层级新增的高级功能，这已不再是必需操作！因此，若您使用过多字节生成正确图像，挑战将不会给予您flag。祝您好运。
- 探索两种数据处理函数
  ```c
  switch (directive_code)
  {
  case 20169:
      handle_20169(&cimg);
      break;
  case 507:
      handle_507(&cimg);
      break;
  ```
- 新增 `read_exact` 读取函数的总数据限制  
  - `void read_exact(int fd, void *dst, int size, char *msg, int exitcode)`
  - `if (total_data > 1340) won = 0;`
- 探索 total_data 的变化
  -  设置display 以持续显示`# 0x4081b0 <total_data>`
  - handle_20169 以输入的4个数据表示一个像素点，于是像素点*4后超出
- 构建 handle_507 的逆向
  - 除新增`宽``高``x` `y`四个字段码到数据段
  - `int __snprintf_chk(char * str, size_t maxlen, int flag, size_t strlen, const char * format);`
    System V AMD64 调用约定下，前 6 个整数/指针参数放在寄存器里（后面的可变参数走栈 push）：
    rdi – str：目标缓冲区
    rsi – maxlen：缓冲区最大长度
    rdx – flag：通常 = 1
    rcx – strlen：编译时认为的缓冲区大小
    r8 – format：格式字符串
    r9 – 第一个变参
  - 以基准坐标 (x, y) 为矩形左上角，外层循环遍历行、内层循环遍历列，映射到帧缓冲中的像素位置来填充一块矩形区域。相当于从 (x, y) 向右下平铺一个像素模式矩形（即，复制一块矩形）。
- 初始化的默认状态为：
  `snprintf(emit_tmp, sizeof(emit_tmp), "\x1b[38;2;%03d;%03d;%03dm%c\x1b[0m", 255, 255, 255, ' ');`
- 关键在于使用新函数复制非默认值部分以减小开销，正如挑战名称打“补丁”，对于不可显示的字符如` `与`\n`颜色可不匹配（不可显示字符的颜色实际无效）
- 使用小样本调试
- 注意bytes各部分构造

```text
.--------------------------------------------------------.
|                                                        |
|                             ___   __  __      ____     |
|                 ___        |_ _| |  \/  |    / ___|    |
|                / __|        | |  | |\/| |   | |  _     |
|               | (__         | |  | |  | |   | |_| |    |
|                \___|       |___| |_|  |_|    \____|    |
|                                                        |
|                                                        |
|                                                        |
|                                                        |
'--------------------------------------------------------'
```

----

**方法建议：**  
本层级需要您在一个文件中创建包含多个指令的cimage。以下建议或许能提供帮助：  
- 前几次尝试很可能会触发错误提示。**请勿仅凭猜测修复错误！** 应结合图形化逆向工具与调试器（gdb）准确理解哪项检查未通过，并调整输入以规避该检查。  
- 手动编写cimage极易出错。建议编写Python脚本来生成cimage。您的脚本应部分模拟解析器库的结构，包含生成cimage头文件的函数，以及支持所需指令的各类函数。这将显著简化本层级及后续层级的操作流程。

### 空间优化

您在上一个层级的解决方案达到了何种优化程度？
若您真正理解了cIMG规范的精妙之处，还能进一步优化……
- 之前仅实现了逐行扫描，若遇到空格则断开。此处最简单的方式是实现手动补丁函数后选择位置。
- 整块字母包含多余空格，选择部分区域

```text
.--------------------------------------------------------------------------.
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                              ___   __  __    ____                        |
|                        ___  |_ _| |  \/  |  / ___|                       |
|                       / __|  | |  | |\/| | | |  _                        |
|                      | (__   | |  | |  | | | |_| |                       |
|                       \___| |___| |_|  |_|  \____|                       |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
'--------------------------------------------------------------------------'
```

### 图像微调

那个最后一关相当棘手。为了补偿你，我们将在这一关给你 flag……以 cimg 的形式！  
- `figlet` 将字符串生成字符图像，之后使用`line.ljust(max_line_length)`对齐每行，然后添加cimg头部。此处头部信息与cimg程序的头部字段不匹配，于是生成`flag.cimg`后修改字段再传递到重构程序即可还原。（虽然有`random.shuffle`但数据包含xy坐标信息）

----  
**提示：** 有几种方法可以解决这一关。我们建议使用十六进制编辑器（例如 `hexedit`）来编辑你的图像！  

----  
**提示：** 该挑战使用 `figlet` 程序生成 flag 字母。如果你在辨别某个特定字母时遇到困难，可以运行 `figlet -fascii9 pwn.college{xyz}` 并将输出结果与你的假设进行对比测试。
- 左右分页的终端进行对比

```text
                                                                             
                                           ""#    ""#                        
 mmmm  m     m m mm           mmm    mmm     #      #     mmm    mmmm   mmm  
 #" "# "m m m" #"  #         #"  "  #" "#    #      #    #"  #  #" "#  #"  # 
 #   #  #m#m#  #   #         #      #   #    #      #    #""""  #   #  #"""" 
 ##m#"   # #   #   #    #    "#mm"  "#m#"    "mm    "mm  "#mm"  "#m"#  "#mm" 
 #                                                               m  #        
 "                                                                ""         
                                                                             
   m""  mmmmm    mmm  mmmmm    mmm                mmmmm    mmm          mmmm 
   #      #        #  #   "# m"   "  mmm   m mm     #    m"   "        m"  "m
 mm"      #        #  #mmm#" #m""#m "   #  #"  #    #    #             #    #
   #      #        #  #      #    # m"""#  #   #    #    #       """   #    #
   #    mm#mm  "mmm"  #       #mm#" "mm"#  #   #  mm#mm   "mmm"         #mm# 
    ""                                                                       
                                                                             
                                                                             
  mmmm          mmmm  m    m mmmmm    m""          mmmm m     m  mmmm    mm  
 #    #  mmmm  m"  "m  #  #  #      mm#mm  m   m  m"  "m "m m"  "   "#   ##  
 "mmmm" #" "#  #    #   ##   """"mm   #    #   #  #    #  "#"       m"  #  # 
 #   "# #   #  #    #  m""m       #   #    #   #  #    #   #      m"    #mm# 
 "#mmm" "#m"#   #mm#" m"  "m "mmm#"   #    "mm"#   #mm#"   #    m#mmmm #    #
         m  #      #                                  #                      
          ""                                                                 
                                                                             
  mmmm                 mmmm  m    m m              mmmm  m    m  mmmm        
 #    # m mm    mmm   m"  "m #    # #             m"  "m "m  m" m"  "m m   m 
 "mmmm" #"  #  "   #  #  m # #mmmm# #             #  m #  #  #  #    #  #m#  
 #   "# #   #  m"""#  #    # #    # #             #    #  "mm"  #    #  m#m  
 "#mmm" #   #  "mm"#   #mm#  #    # #mmmmm   #     #mm#    ##    #mm#  m" "m 
                                                                             
                                                                             
                                                                             
 m    m mmmm   m    m                      mm   m mmm    m    m        mm   m
 ##  ## #   "m ##  ## m   m m     m m   m  #"m  #   #    ##  ## mmmmm  #"m  #
 # ## # #    # # ## #  #m#  "m m m" "m m"  # #m #   #    # ## #    m"  # #m #
 # "" # #    # # "" #  m#m   #m#m#   #m#   #  # #   #    # "" #  m"    #  # #
 #    # #mmm"  #    # m" "m   # #    "#    #   ## mm#mm  #    # #mmmm  #   ##
                                     m"                                      
                                    ""                                       
                                                                             
        mmmmmm       m     m ""m                                             
 m   m  #      mmmmm #  #  #   #                                             
  #m#   #mmmmm    m" " #"# #   "mm                                           
  m#m   #       m"    ## ##"   #                                             
 m" "m  #mmmmm #mmmm  #   #    #                                             
                             ""                                              
                                                                             
                                                        
```
- 区分 0 O G 以及 1 l

### 存储与检索

补丁不错，但精灵图更胜一筹。
你能进一步优化图像大小吗？
- 新增多个处理函数
  ```c
      while (cimg.header.remaining_directives--)
      {
          uint16_t directive_code;
          read_exact(0, &directive_code, sizeof(directive_code), "ERROR: Failed to read &directive_code!", -1);

          switch (directive_code)
          {
          case 1:
              handle_1(&cimg);
              break;
          case 2:
              handle_2(&cimg);
              break;
          case 3:
              handle_3(&cimg);
              break;
          case 4:
              handle_4(&cimg);
              break;
          default:
              fprintf(stderr, "ERROR: invalid directive_code %ux\n", directive_code);
              exit(-1);
          }
      }
  ```
  以及更低的总读取上限
  `if (total_data > 400) won = 0;`
- 新增结构
  ```c
  struct cimg_sprite
  {
      uint8_t height;
      uint8_t width;
      // uint8_t _pad[6]; 1+1+8字节，然而对齐需增加填充
      pixel_bw_t *data;
  };

  struct cimg
  {
      struct cimg_header header;
      unsigned num_pixels;
      term_pixel_t *framebuffer;
      struct cimg_sprite sprites[256];
  };
  ```
- handle_1 初始函数
- handle_2 补丁函数
- handle_3  
  字段，由错误信息得到名称，均为1字节：
  - sprite_id rsp+0x5
  - width rsp+0x6
  - height rsp+0x7

  使用 sprite_id 作为乘积偏移：
  - sprite_id * 16 + &cimg
    - height 到 偏移+0x18
    - width 到 偏移+0x19 
    - data 指针（仅ascii码的矩阵） 偏移+0x20 （0x18的cimg元素，8的cimg_sprite元素 2+ 对齐填充 6）

  分配并读取宽*高个字节，使用data指针指向此处
  
  循环查看所有像素的ascii是否在范围内

  新指针到 `&base[sprite_id] + 0x20)->data`
  - `mov   QWORD PTR [rax+rbp*1+0x20], rbx`

  
- handle_4  
  分配大量栈空间：
  - rsp-0x40000

  字段名：
  - sprite_render_record，读取大小6字节的渲染指令到 rsp+0x9
    从rsp偏移读取，均为1字节
    rsp+0x9 sprite_id
    rsp+0xa 
    rsp+0xb 
    rsp+0xc 

  初始化栈空间：
  - rsp+0xf 开始，使用 rep stosd dword 指令清空栈空间每次4字节 重复 0x10000 次
  （对应之前分配的栈空间）

  rdx+0x18 = &cimg + (rsp+0x9)*16  = &cimg + sprite_id *16
  外循环 0x10000 与 rdx+0x18（height） 的比较，height永远小于0x10000，不进入循环
  - 内循环 rdx+0x19 与 0++ 的比较
    - 偏移 0x10000 * (rdx+0x19)  *4
      分别写入3个字节，或许为rgb(之前的sprite_render_record的元素)
    - rdx+0x20 不可为0，对应错误“ERROR: attempted to render uninitialized sprite!”
      读取1字节 偏移+(rdx+0x20)，写入 偏移+3，或许为ascii。
      

  之后的循环写入
  外循环遍历高，内循环遍历宽。还是之前挑战的 行*宽+列 模式
  - &cimg + sprite_id *16

- handle_4 在 cimg_sprite 设置长宽与字符后，使用 handle_3 注册到数组中。  
  sprite_render_record 记录了注册id用来作为数组索引偏移，也包括rgb以及xy坐标.
  设置像素点信息的长/宽/字符后，使用数据码的id进行索引，xy进行定位

- h2开销为：
  - 字段的4字节
  - 宽* 高 *4
- h3注册开销为：
  - 读取字段的3字节： sprite_id、width、height 各1字节
  - 宽* 高 个ascii码矩形
- h4复用开销为：
  - 读取字段的6字节： sprite_render_record 的六个字段 各1字节
  
- 框外可有效复用外，对中心的复制字母区域的部件进行复用效果不佳。  
  在于h3与h4的特性是注册时仅计算宽*高，多次使用的头部与与数据的开销可能超过直接对一个区域进行覆盖。

```c
struct sprite_render_record {
    uint8_t sprite_id;  // [rsp+0x9]
    uint8_t a;          // [rsp+0xa] 
    uint8_t b;          // [rsp+0xb] 
    uint8_t c;          // [rsp+0xc] 
    uint8_t x0;         // [rsp+0xd]
    uint8_t y0;         // [rsp+0xe]
};
```

```test
 0123456789012345678901234567890123456789012345678901234567890123456789012345
0.--------------------------------------------------------------------------.
1|                                                                          |
2|                                                                          |
3|                                                                          |
4|                                                                          |
5|                                                                          |
6|                                                                          |
7|                                                                          |
8|                                                                          |
9|                              ___   __  __    ____                        |
0|                        ___  |_ _| |  \/  |  / ___|                       |
1|                       / __|  | |  | |\/| | | |  _                        |
2|                      | (__   | |  | |  | | | |_| |                       |
3|                       \___| |___| |_|  |_|  \____|                       |
4|                                                                          |
5|                                                                          |
6|                                                                          |
7|                                                                          |
8|                                                                          |
9|                                                                          |
0|                                                                          |
1|                                                                          |
2|                                                                          |
3'--------------------------------------------------------------------------'
```

### 知识提取

你对cimg格式的掌握程度如何？这是展示你学习成果的绝佳机会！本关的`/challenge/cimg`无法直接给你flag，但我们会提供一个包含flag的cimg文件！
- 微调格式的宽高与定位
  - figlet 输出的字母字符为包含换行符的 8列*8行，或者按照回车判断行的结束

### 高级精灵图

本关卡探讨了在软件功能（此处指*cIMG精灵功能）中增加少量复杂性与其带来的功能改进（使cIMG文件更小！）之间的权衡。我们可能已接近最优cIMG大小，且`/challenge/cimg`将提出极高要求！
- 更新版本号到4
- `mov     edx, 0x9` 更新h4结构到9字节版

```c
struct sprite_render_record { // 9 bytes
    uint8_t sprite_id;  // [rsp+0x16]
    uint8_t a;          // [rsp+0x17] 
    uint8_t b;          // [rsp+0x18] 
    uint8_t c;          // [rsp+0x19] 
    uint8_t base_x; //rsp+0x1a
    uint8_t base_y; //rsp+0x1b
    uint8_t block_width_count;         // [rsp+0x1c]
    uint8_t block_height_count;         // [rsp+0x1d]
    uint8_t exclude_ascii_char; //[rsp+0x1e]
};
```

- 功能分析：  
  h3注册精灵块后，h4在大画布的xy位置按照分块字段的宽高方向的数量进行重复，跳过排除字符
- 在之前的精灵手动函数基础上添加对应的外层 block_width_count 与 block_height_count 循环即可
  - 区分本地数据画布以及应用程序画布的状态，尝试取点后大块写入，重复覆盖以减少次数
  - 可使用空格覆盖以清空多余内容（确保排除项不是空格，否则空格不会写入）

```text
.--------------------------------------------------------------------------.
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                              ___   __  __    ____                        |
|                        ___  |_ _| |  \/  |  / ___|                       |
|                       / __|  | |  | |\/| | | |  _                        |
|                      | (__   | |  | |  | | | |_| |                       |
|                       \___| |___| |_|  |_|  \____|                       |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
|                                                                          |
'--------------------------------------------------------------------------'
```

### 访问资源

随着功能膨胀使软件项目变得越来越复杂，由于过多可变部件的相互作用，漏洞常常趁虚而入。在逆向工程软件的过程中，逆向工程师往往会发现此类漏洞。

这正是其中一个场景。找到并利用`/challenge/cimg`中的漏洞来获取flag！
- 新增函数 handle_5

  ```c
  read_exact(0, rsp+0x5, 0x102, "ERROR: Failed to read &sprite_load_record!", 0xffffffff) 

  rsp+0x5 1bytes sprite_id，根据偏移判断
  rsp+0x6 2bytes 宽，宽高根据偏移后的结构判断
  rsp+0x7 1bytes 高
  rsp+0x8 文件名字符串，open函数的第一个参数

  在精灵数组中写入 2bytes 对应精灵的高宽字段
  *(&cimg + (rsp+0x5)*16 + 0x18) = *(rsp+0x6)

  存在open函数，并得到文件名字段
  open(rsp+0x8, 0);

  malloc 分配宽*高个字节的空间

  从精灵文件描述符读取到内存分配的堆中，
  注意，read_exact 在 size（宽*高） 超出实际大小时退出
  int n = read(fd, dst, size);
  if (n != size)
  
  逐字节读取后，将指针保存到精灵数组（变种h3）
  ```
- 文件路径记得加`\0`的字符串终止符以及填充


### 不安全动画

我们*cIMG指令*列表的可扩展性持续令人惊叹！
- handle_5 增加了flag字符检测后退出的代码
- 新增函数 handle_6 handle_7
- handle_6 
  ```c
  rsp+0x7 1bytes clear

  setuid(geteuid()) // 设置真实uid（hacker）为等效uid（root）
  system("clear") // 执行 clear 命令
  ```

- handle_7 此处无关
  ```c
  read_exact(0, &var_24, 4, "ERROR: Failed to read &milliseconds!", 0xffffffff);
  rsp+0x4 4bytes

  milliseconds/1000 得到商（秒）与余数（毫秒）
  rsp+0x8 4bytes 保存商 requested_time
  rsp+0x10 4bytes 保存余数* 1_000_000 （纳秒）
  nanosleep(&requested_time, nullptr);
  ```

----

**提示：**
请牢记 Linux Luminarium 中的 "Pondering PATH" 关卡。
这会很有用。

### 动画

好吧，上一关确实有点尴尬，但这类漏洞经常出现！我们在本关中修复了那个问题，并且由于对这个漏洞感到有些抱歉，我们决定再次给你 flag……这次是放在一个动画 cimg 里！祝你好运。
- 在之前xy坐标与字符列表的基础上增加了h6与h7的指令
  ```py
	directives += [ struct.pack("<HB", 6, 1) ]
	directives += [ struct.pack("<HI", 7, 733_331) 
  ```
- h6移除了设置uid的部分
  ```c
  rsp+0x7 1bytes clear 保留

  检查 clear 字段是否为0，若不为0则在标准输出打印字符串 "\x1b[H\x1b[2J"
  
  之后调用 display
  ```
  `\x1b[H\x1b[2J`控制序列： “光标回到左上 + 清屏”  


- 即，光标回到左上 + 清屏 -> 显示像素 -> 睡眠  持续循环

### 互操作性：修补数据

逆向工程的另一个目标是为了*互操作性*。  
时间是严苛的，随着时间推移，软件本身或其周围环境可能发生诸多变化。  
例如，[源代码可能丢失](https://www.rockpapershotgun.com/square-enix-digital-preservation-plans-slowed-by-lost-code)，因为源代码通常是相关公司的内部机密，但二进制文件往往得以保留，因为它们被广泛（例如商业性）分发。当源代码丢失时，必须通过逆向工程二进制文件来实现互操作性，以[重建](https://decompilation.wiki/applications/program-reconstruction/)或[适配](https://scanlime.org/2009/04/a-binary-patch-for-robot-odyssey/)它们。  

在本挑战中，我们已找回游戏 `The Epic Quest for the Flag`（`/challenge/quest.py`）的源代码，但其定制的基于 cIMG 的图形引擎缺失！  
我们为您提供了一个近似版本（标准 cIMG 解析器位于 `/challenge/cimg`），但它无法直接运行。  
您需要通过二进制补丁使其兼容！  
您能揭开 flag 吗？  
- 魔术字段不同  
  `screen = GraphicsEngine(w, h, cimg_ops=CIMG_NORMAL if "NOFLAG" in sys.argv else CIMG_1337)`
- 编辑时使用十六进制编辑器，使用文本编辑器可能破坏格式

hexedit：
- `Ctrl + W` 搜索功能组合键，但与网页快捷键冲突

使用 `strings -t x 文件 | grep cIMG` 得到字符串偏移
使用python修改对应位置：使用 bytearray() 对 bytes 进行处理，可执行切片赋值。

然而成功修改后需完成这个游戏找到flag的所有字节，然后在显示成功信息后按下终端组合键一次性显示flag。flag有60字节，若手动操作寻找每个字节要10秒(网络延迟以及浏览器渲染性能)，总共十分钟
跳过获得flag的游戏，一段时间后返回查看pwn.college是否修改了获取flag的逻辑

----

**注意：**  
请注意，`/challenge/quest.py` 使用 `cimg` 作为图形引擎，但它是针对您没有的定制版 `cimg` 构建的。  
您可以通过 `/challenge/quest.py NOFLAG | /challenge/cimg` 以“兼容模式”运行：无 flag，但兼容标准 `cimg`。  
若需获取 flag，您需要修改 `cimg` 以使其与 `quest` 协同工作，并通过 `/challenge/quest.py | /home/hacker/your-patched-cimg` 运行。 

----

**提示：**  
您可以使用任意逆向工程工具进行补丁，或找出需修补字节的文件地址并使用 `hexedit`。  

### 修补代码

上一关纯属侥幸——实际上无需修补任何代码。  
本关将是您在代码层面进行二进制补丁的初次尝试，但您只需修补 x86 比较指令使用的简单常量。  
祝你好运！

```py
class CIMG_NORMAL:
    MAGIC = b"cIMG"
    RENDER_FRAME =  struct.pack("<H", 1)
    RENDER_PATCH =  struct.pack("<H", 2)
    CREATE_SPRITE = struct.pack("<H", 3)
    RENDER_SPRITE = struct.pack("<H", 4)
    LOAD_SPRITE =   struct.pack("<H", 5)
    FLUSH =         struct.pack("<H", 6)
    SLEEP =         struct.pack("<H", 7)

class CIMG_1337:
    MAGIC = b"CNNR"
    RENDER_FRAME =  struct.pack("<H", 7)
    RENDER_PATCH =  struct.pack("<H", 6)
    CREATE_SPRITE = struct.pack("<H", 5)
    RENDER_SPRITE = struct.pack("<H", 4)
    LOAD_SPRITE =   struct.pack("<H", 3)
    FLUSH =         struct.pack("<H", 2)
    SLEEP =         struct.pack("<H", 1)
```
- 修改switch判断语句的比较数字

得到比较代码的地址 insn_addr 与指令字节。  
指令的立即数偏移为3 imm_insn_offset = 3
```c
004013ea  6683f901           cmp     cx, 0x1
004013fa  6683f902           cmp     cx, 0x2
0040140a  6683f903           cmp     cx, 0x3
0040141a  6683f904           cmp     cx, 0x4
0040142a  6683f905           cmp     cx, 0x5
0040143d  6683f906           cmp     cx, 0x6
00401450  6683f907           cmp     cx, 0x7
```

拿到 .text 段基址和文件偏移
```sh
readelf -S /challenge/cimg | grep .text
  [15] .text             PROGBITS         0000000000401290  00001290
```
```py
text_vaddr = 0x401290
text_offset = 0x1290
```

根据指令的相对偏移计算文件对应位置
```py
file_offset = text_offset + (insn_addr - text_vaddr) + imm_insn_offset
```

关键是找到指令在文件中对应的位置

### 修补控制流

这一关更为棘手：您需要修补稍显复杂的指令。  
这让您更接近实际互操作性修补的真实场景！

```c
004013af  488d1dce1f0000     lea     rbx, [rel jump_table_403384]

004013fe  48630483           movsxd  rax, dword [rbx+rax*4]
00401402  4801d8             add     rax, rbx
00401405  3effe0             jmp     rax

{Case 0x0}
00401408  e8b9010000         call    handle_1
0040140d  ebac               jmp     0x4013bb
```
- 此处使用跳转表基址进行相对偏移，跳转表中储存的是4字节的相对偏移

- 若尝试修改call地址，由于call使用的是rip相对偏移，于是需手动计算而无法直接复制地址
- 寻找并修改跳转表映射
  ```log
  (gdb) x/7x 0x403384
  0x403384:  0xffffe084  0xffffe08b  0xffffe092  0xffffe099
  0x403394:  0xffffe0a0  0xffffe0a7  0xffffe0ae
  ```