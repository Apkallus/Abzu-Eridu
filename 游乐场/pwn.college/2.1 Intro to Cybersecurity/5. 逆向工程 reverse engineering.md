# 逆向工程

欢迎学习逆向工程入门！逆向工程是一项关键技艺，您将在pwn.college的探索之旅中逐步掌握它。本次旅程将从Connor图像格式（cimg）开始。您此前从未听说过cimg，这种格式在现实世界中并不实际存在，但通过本模块的学习，您将借助分析多个版本的cimg渲染二进制文件来*逆向工程*该格式。当您完成最后一关时，将会实现从对cimg一无所知到完全理解它的跨越——这条路径您将在未来面对众多不同程序时反复践行。

### 其他资源

互联网上存在大量与逆向工程相关的资源。
- 入门推荐亚利桑那州立大学Adam Doupe在其[YouTube频道](https://www.youtube.com/watch?v=qgt-0ooafcm&list=PLk06xt3HfpZiMAzj8QUoqc8ivAeBrlZWh)发布的系列黑客挑战实战教程。
- 全面的逆向工程[教程系列](https://github.com/mytechnotalent/reverse-engineering)。

### 实用工具

如幻灯片所述，本作业有许多实用工具！以下为不全面的列表：
* `gdb` 可用于运行和检查程序状态。请查阅调试复习模块，此处也提供快速指南。重要概念：
    * 区分 `step instruction` (`si`) 与 `next instruction` (`ni`)：`si` 会跟随跳转指令进入子程序，`ni` 则直接执行完跳转指令。使用 `si` 可能误入 libc 库代码层，增加调试复杂度。
    * `x/i $rip` 可反汇编下条待执行指令，`display/i $rip` 可设置为每次输入提示时自动显示。支持扩展格式如 `x/2i` 显示两条指令。
    * `disas` 命令反汇编当前函数。
    * gdb 支持脚本化！参考手册了解条件断点和可脚本化断点。
    * 现代二进制文件采用*位置无关*设计，运行时载入内存地址不固定。gdb 默认加载偏移地址为 `0x555555554000`。若 objdump 显示 main 函数地址为 `0x100`，则 gdb 调试时实际地址为 `0x555555554100`。
* `strings` 可列出文件中可打印字符串，用于查找程序校验的固定字符串（如文件名等）。注意可通过参数设置最小输出字符串长度。
* 勿忘 pwntools！需频繁与程序交互时请优先选用。
* `rappel` 可用于分析特定指令功能。
* 逆向工程实战工具（Dojo环境内置）：
    * IDA 是行业标准级逆向工具。
    * Ghidra 作为开源方案直接对标 IDA，广受好评。
    * Binary Ninja 是 IDA 的替代产品。
    * angr-management 是具备高级功能的开源新兴工具。
    * 应急方案：`objdump -d -m intel the_binary` 可反汇编目标文件，其中 `-m intel` 参数输出易读的英特尔语法汇编代码。

## 挑战

### 文件格式：魔数（Python）

道场的前几个挑战将引导您创建首个基础cIMG图像。当然，此举的目的并非创作图像，而是通过逆向其二进制文件，亲身体验理解程序逻辑及数据格式的过程。

本关的 `/challenge/cimg` 二进制文件是一个（初始版本的）图像渲染程序，专门处理cIMG格式。软件通过以下几种方式识别文件格式（例如判断文件是GIF、JPEG还是MP3等）：

1. 文件扩展名  
   即文件名中`.`后的部分：`ZardusSmiling.jpg` 很可能是Zardus微笑的JPEG图像，而 `KanakLaughing.mp3` 可能是Kanak笑声的MP3音频文件。
2. *魔数*  
   文件可能被重命名，或关联文件名丢失（如文件系统部分故障）甚至缺失（如数据流中）。因此多数文件格式会包含可供解析器校验的*魔数*。

您早已接触过许多含魔数的文件。例如处理过的ELF二进制文件均以字节 `\x7fELF` 开头。对人类而言这像有语义的字符串，但计算机将其读取为数字，故得此名。

本挑战要求您制作一个包含正确魔数且扩展名为 `cimg` 的文件。您可通过逆向 `/challenge/cimg` 二进制文件获取该魔数。若成功通过魔数验证，即可获得flag！

注：
- 作为第1个挑战，提供了python源码
----

**方法建议：**  
以下建议或有助于入门：

- 逆向工程可采用静态分析（如使用IDA等图形化逆向工具分析静态程序）或动态分析（如通过gdb等调试器运行目标程序）。本模块推荐结合使用这两种技术：用图形化工具建立假设（如"程序在某汇编指令地址将输入字节与某些值比较"），再通过gdb验证（如在对应地址设断点，查看比较的寄存器值并与输入关联）。
- **弃用objdump**  
  您可能曾用objdump查看汇编代码。或可凭此通过本关（及下一关），但**若无图形化逆向工具则无法完成本模块**。请以此挑战为契机熟悉图形化逆向工具。
- 复盘成功解法  
  若未同时使用图形化逆向工具和调试器（gdb）即通过本关，请用未使用的工具重新验证解法。此举有助于掌握工具在后续关卡中的应用，建议在所有未同时使用两种工具解决的挑战中进行实践。

### 文件格式：魔数（C）

Now in C!

注：
- 作为第2个挑战，提供了c源码

### 文件格式：魔数（x86）

Now in x86!

注：
- 作为第3个挑战，提供了二进制文件
- 复制挑战的二进制文件：
    1. 将二进制文件编码为 Base64 格式  
        `base64 /challenge/cimg > ~/myrun`
    2. 复制base64编码后的字符串到本机
    3. 使用python的base64库解码，还原二进制文件
        `binary_data = base64.b64decode(base64_data)`
- 将二进制文件上传到 `cloud.binary.ninja` 进行静态可视化分析
- 使用gdb动态分析验证

### 读取字节序（Python）

### 读取字节序（C）

### 读取字节序（x86）

### 版本信息（Python）

### 版本信息（C）

### 版本信息（x86）

### 元数据与数据（Python）

### 元数据与数据（C）

### 元数据与数据（x86）

### 输入限制（Python）

### 输入限制（C）

### 输入限制（x86）

### 认识cIMG！（Python）

### 认识cIMG！（C）

### 认识cIMG！（x86）

### 基础cIMG（Python）

### 基础cIMG（C）

### 基础cIMG（x86）

### 内部状态迷你版（C）

### 内部状态迷你版（x86）

### 内部状态（C）

### 内部状态（x86）

### 文件格式：指令（C）

### 文件格式：指令（x86）

### 补丁指令

### 空间优化

### 图像微调

### 存储与检索

### 知识提取

### 高级精灵图

### 访问资源

### 不安全动画

### 动画

### 互操作性：修补数据

### 修补代码

### 修补控制流
