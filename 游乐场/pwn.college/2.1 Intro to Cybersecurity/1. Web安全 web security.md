# Web Security

你已经学习了 Linux 和 HTTP。现在，让我们把这些知识结合起来！

网络内容通过*Web 服务器*在互联网上提供，与其他所有事物一样，这些 Web 服务器及其提供的页面也存在漏洞！在本模块中，你将深入探索网络的奥秘，了解可能出现的各种漏洞类型。在学习本模块时，请记住这些并非理论上的奇谈：它们是现代网络中*经常*出现的常见关键漏洞，可能导致大规模数据泄露、账户接管等问题。现在，开始深入探索吧！

## Content Injection

### Path Traversal 1

本关卡将探讨 Linux 路径解析（当处理方式*简单粗暴*时）与攻击者意外 Web 请求的交集。
我们已为您实现一个简易 Web 服务器——它将通过 HTTP 提供 `/challenge/files` 目录下的文件。
你能诱骗服务器返回 flag 吗？

Web 服务器程序位于 `/challenge/server`。
您可以像运行其他挑战程序一样运行它，然后通过 HTTP（使用另一个终端或网页浏览器）与其交互。
建议阅读其源代码以理解运行机制并找出漏洞！
- 当使用 `app = Flask(__name__)` 初始化时，`root_path` 会自动设置为当前 Python 模块所在的目录
----

**提示：**
若不确定为何解法无效，请确认您尝试查询的内容与服务器实际接收到的请求是否一致！
使用 `curl -v [url]` 可查看 curl 发送的具体字节流。

### Path Traversal 2

上一关出现路径遍历漏洞的原因在于：

1.  开发者未能充分意识到攻击者可能向其应用发送的*潜在输入*的真实范围（例如，攻击者可能发送在路径中具有特殊含义的字符这一概念）。
2.  开发者的意图（从代码实现可以清楚地看出，我们*只期望*将 `/challenge/files` 目录下的文件提供给用户）与文件系统的*现实*（路径可以向上"回退"到父目录）之间存在脱节。

本关卡试图阻止你进行路径遍历，但其采用的方式清楚地表明开发者*仍然未能理解*路径究竟可以有多么棘手。
你还能成功实现遍历吗？
- python的`open`函数需求真实路径，若包含不存在中间路径则报错

### CMDi 1

现在，想象一下比Web服务器与文件系统之间的安全问题更疯狂的情况：  
Web服务器与整个Linux Shell之间的交互又会带来什么？  

令人沮丧的是，这种情况频繁发生。开发者常依赖命令行Shell来处理复杂操作。  
在这些场景中，Web服务器会执行一条Linux命令，并将该命令的结果用于其操作（一个常见用例是`Imagemagick`命令套件，它用于图像处理）。  
不同编程语言有不同的实现方式（Python中最简单的方式是`os.system`，但我们将主要使用更高级的`subprocess.check_output`），但几乎所有方法都存在*命令注入*的风险。  

在*路径遍历*中，攻击者发送了一个意料之外的字符（`.`），导致文件系统执行了开发者未预期的操作（查看父目录）。  
同样地，Shell中也充满了大量特殊字符，这些字符会引发开发者未预料的效果，而开发者意图与Shell实际执行（或在之前的挑战中涉及的文件系统）之间的差距，隐藏着各种安全问题。  

例如，考虑以下运行Shell命令的Python代码片段：

```sh
os.system(f"echo Hello {word}")
```

开发者显然希望用户发送类似`Hackers`的内容，并得到类似`echo Hello Hackers`这样的命令结果。  
但攻击者可能发送代码未明确阻止的*任何内容*。  
回想你在 Linux Luminarium(/linux-luminarium)的 Chaining(/linux-luminarium/chaining)模块中学到的内容：如果攻击者发送的字符串中包含`;`会发生什么？  

在本关卡中，我们将深入探讨这一具体概念。  
看看你是否能成功绕过本关并提取flag！
- 记得编码查询参数值的空格

### CMDi 2

许多开发者都意识到了*命令注入*这类安全问题，并试图防范它。
在本关卡中，你可能无法使用 `;`！
你能想出另一种实现命令注入的方法吗？
回想一下你在 Linux Luminarium(/linux-luminarium) 的 管道(/linux-luminarium/chaining)模块中学到的内容...

### CMDi 3

关于命令注入的一个有趣之处在于：注入点的选择权并不在你手中——开发者编写程序时的疏忽*意外地*替你做出了这个决定。
有时，这些注入会出现在*不太理想*的位置。
考虑以下代码：

```python
os.system(f"echo Hello '{word}'")
```

此处，开发者试图向 Shell 表明 `word` 应当*仅为一个单词*。
Shell 在处理单引号内的参数时，会将通常具有特殊含义的字符（如 `;`、`$` 等）视为普通字符，直到遇到结束的单引号（`'`）为止。

本关卡正是这样的场景。
你能绕过它吗？
- 如说明的引号配对或注释或分句等

----

**提示：**
请记住，无论你注入什么内容，其末尾都会紧跟着一个 `'` 字符。
在 Shell 中，所有引号都必须*成对匹配*，否则命令无效。
请精心构造你的注入载荷，确保最终生成的命令是有效的！

### CMDi 4

通过调用 Shell 命令来执行任务（通常称为*Shell 调用*）是危险的。  
Shell 命令的*任何部分*都可能存在可注入的漏洞！  
在本关卡中，我们将尝试向一个略有不同的命令中的*稍有不同的部分*进行注入练习。

### CMDi 5

程序常通过*调用Shell*来完成复杂的内部计算。
这意味着你可能无法始终获得命令执行的结果输出，因此需要以*盲打*方式进行攻击。
在本关卡中尝试：即使无法看到注入命令的输出，也要成功获取flag！

### CMDi 6

有时，开发者会*非常努力地*过滤掉潜在的危险字符。  
本挑战中的过滤机制*几乎完美*，但并非无懈可击……  
你可能会困惑一阵子，但在找到解决方案时，会因它的*似曾相识*而会心一笑！

### Authentication Bypass 1

当然，Web 应用程序可能存在与 Shell *完全无关*的安全漏洞。  
一种常见的漏洞类型是*身份验证绕过*，攻击者可通过该漏洞绕过应用程序的常规身份验证逻辑，在*不知晓合法用户凭证*的情况下登录系统。  

本关卡将引导你探索此类场景。  
该特定场景的成因再次源于开发者预期（认为 URL 参数*仅由应用程序自身设置*）与现实（攻击者可*随意构造* HTTP 请求）之间的差异。  

本关卡假设你对 SQL 有初步了解（可通过 SQL 练习场(/fundamentals/sql-playground) 学习）。  
SQL 的重要性将在后续内容中凸显，此处仅是挑战的辅助元素。  

现在，请尝试绕过身份验证机制，以 `admin` 用户身份登录并获取 flag！
- 可预测的会话token

### Authentication Bypass 2

身份验证绕过并非总是如此简单。  
有时，应用程序的逻辑可能看似正确，但开发者预期与现实情况之间的差距*再次暴露出来*。  
尝试挑战本关卡，并记住：*你*可控制所有请求，包括发送的每个 HTTP 头部！

### SQLi 1

当然，这类安全漏洞*层出不穷*！
例如在本关卡中，用户登录状态的验证机制本身是安全的。
与使用 GET 参数或原始 Cookie 不同，本关卡采用了*加密会话 Cookie*，您无法直接篡改其内容。
因此，您的任务是让应用程序*实际将您认证为 admin 用户*！

幸运的是，正如关卡名称所示，该应用程序存在*SQL 注入*漏洞。
从概念上讲，SQL 注入之于数据库查询，就如同命令注入之于 Shell 命令执行。
在命令注入中，应用程序组装命令字符串时，开发者意图与命令 Shell 实际功能之间的差距使攻击者能够执行开发者未预期的操作。
SQL 注入的原理相同：开发者编写应用程序时通过组装 SQL 查询来实现特定目标，但由于查询组装逻辑的缺陷，最终被数据库执行的 SQL 查询操作可能从安全角度产生灾难性后果。

命令注入没有明确的解决方案：Shell 是一项古老的技术，其接口早在几十年前就已固化且难以更改。
SQL 则相对灵活，目前大多数数据库都提供了能有效防御 SQL 注入的接口。
实际上，之前身份验证绕过关卡使用的正是这类接口：它们虽然存在漏洞，但*并非* SQL 注入漏洞。

而本关卡*确实存在* SQL 注入漏洞，因为它故意采用了略有不同的 SQL 查询构建方式。
当您找到可注入的 SQL 查询点时（提示：这是本关卡与前一关卡之间*唯一有实质性差异*的 SQL 查询），请分析当前查询的结构，思考如何通过注入*构造非预期条件*。
典型的 SQL 注入会添加一个条件，使得应用程序在*不知晓密码*的情况下也能验证成功。
您该如何实现这一点呢？

### SQLi 2

上一关的 SQL 注入*相对容易实现*，且仍能保持 SQL 查询的有效性。  
这部分是因为您的注入点位于查询语句的*最末端*。  
但在本关卡中，您的注入点位于查询语句的*中间位置*，且后续还有（少量）SQL 代码。  
这将*使情况复杂化*，因为尽管进行了注入，整个查询语句仍必须保持语法有效。

### SQLi 3

如果您还记得，您的命令注入攻击通常会导致*额外的*命令被执行。  
到目前为止，您的 SQL 注入只是修改了现有 SQL 查询的条件。  
然而，类似于 Shell 具有链接受命令的方式（例如 `;`、`|` 等），某些 SQL 查询也可以被链接受！  

攻击者链接受 SQL 查询的能力具有*极其强大的*潜在影响。  
例如，它允许攻击者查询*完全非预期*的表或表中的字段，从而导致新闻中报道的那种*大规模数据泄露*事件。  

本关卡将要求您掌握如何链接受 SQL 查询以泄露数据。  
祝您好运！

### SQLi 4

到目前为止，您一直知晓数据库的结构（例如 `users` 表的名称），从而能够*有意识地*构造查询。  
作为开发者，您可能会试图通过*随机化表名*等方式来防范此类攻击，使攻击者无法指定表名来查询其*无权访问*的数据。  
遗憾的是，这种方法并非如您想象的那般*万无一失*。  

数据库系统本身*非常复杂*，其设计精巧性有时反而会带来安全隐患。  
例如，几乎所有现代数据库都将数据库布局规范本身*存储在元数据表中*。  
攻击者可以查询该元数据表来获取表名、字段名以及任何其他所需信息！  

在本关卡中，开发者已随机化了（原名为）`users` 表的表名。  
请找到该表并获取 flag！

### SQLi 5

SQL注入可能发生在应用程序的*各个角落*，并且与命令注入类似，有时查询结果并不会返回给攻击者。  
对于命令注入而言，这种情况*相对容易处理*：命令行功能极其强大，即使*盲打*也能完成许多操作。  
但对于SQL注入，情况有时则*不同*。  
例如，与本模块使用的SQLite数据库不同，某些其他数据库*无法访问文件系统、执行命令*等操作。  

那么，如果应用程序未显示SQL注入产生的数据，攻击者该如何*实际泄露数据*？  
有时，即使未直接显示实际数据，攻击者仍可逐比特恢复信息！  
如果查询结果能触发应用程序的*两种不同行为*（例如跳转至"认证成功"页面与"认证失败"页面），攻击者便可精心构造*是/否问题*并通过页面差异获取答案。  

本挑战正是此类场景。  
您能否成功泄露flag？
- 上下文为用户表，使用响应的差异判断密码的逐步猜测是否正确（302、403）

## Cross Site Scripting

### XSS 1

语义鸿沟可能出现在任意两种技术的接口处（并导致安全问题）。截至目前，我们已经看到它们发生在以下场景中：
- Web应用程序与文件系统之间，导致路径遍历。
- Web应用程序与命令行 shell 之间，导致命令注入。
- Web应用程序与数据库之间，导致 SQL 注入。

我们尚未涉及的 Web 应用程序环节是 *Web 浏览器*。我们将通过本挑战来弥补这一疏忽。

现代 Web 浏览器是一款极其复杂的软件。它渲染 [HTML](https://en.wikipedia.org/wiki/HTML)，执行 [JavaScript](https://en.wikipedia.org/wiki/JavaScript)，解析 [CSS](https://en.wikipedia.org/wiki/CSS)，让您访问 pwn.college，以及更多功能。对我们目的特别重要的是您在本模块每个挑战中看到的由 Web 应用程序生成的 HTML。

当 Web 应用程序生成路径时，我们最终遇到了路径遍历。
当 Web 应用程序生成 shell 命令时，我们最终遇到了 shell 注入。
当 Web 应用程序生成 SQL 查询时，我们最终遇到了 SQL 注入。

我们真的认为 HTML 会表现更好吗？当然不会。

这种将注入发生在客户端 Web 数据（如 HTML）中的漏洞类别被称为 *跨站脚本攻击*，或简称 XSS（以避免与层叠样式表名称冲突）。

与之前注入的受害者是 Web 服务器本身不同，XSS 的受害者是 *Web 应用程序的其他用户*。在典型的 XSS 攻击中，攻击者会将自己的代码注入到（通常是）Web 应用程序生成并由受害用户查看的 HTML 中。这将使攻击者能够在受害者的浏览器中获得一定的控制权，从而导致一系列潜在的后续恶意行为。

本挑战是迈向此方向的第一步。与之前一样，您将拥有 `/challenge/server` Web 服务器。本挑战探讨一种称为 *存储型 XSS* 的攻击，这意味着您存储在服务器上的数据（在本例中为论坛帖子）最终会显示给受害用户。因此，我们需要一个受害者来查看这些帖子！

您现在将拥有一个 `/challenge/victim` 程序，用于模拟受害用户访问 Web 服务器。设置您的攻击，并使用将触发存储型 XSS 的 URL 调用 `/challenge/victim`。在本关卡中，您只需注入一个文本框。如果我们的受害者脚本看到三个文本框，我们将为您提供 flag！

----

**调试：**
如何调试这类攻击？在这种简单场景中，最常见的问题是注入后的最终 HTML 无效。这里，您浏览器的“查看源代码”功能可以提供帮助。您可以尝试在 Dojo 的 GUI 桌面中的 Web 浏览器上发起攻击（例如，设置 XSS，然后使用 Dojo 的 Firefox 访问，而不是使用 `/challenge/victim`）并查看源代码，或者直接使用 curl 读取结果。注入有效负载后，结果应该仍然是有效的（但已是恶意的）HTML！

### XSS 2

好的，注入一些 HTML 确实很酷！您可以想象这如何被用来迷惑受害者，但情况还会变得更糟...

在 20 世纪 90 年代，Web 的明智设计者们发明了 JavaScript 以使网站更具交互性。JavaScript 与您的 HTML 并存，并使事情变得有趣。例如，以下代码将您的浏览器变成一个时钟：

```html
<html>
  <body>
    <script>
      document.body.innerHTML = Date();
    </script>
  </body>
</html>
```

基本上，HTML 的 `<script>` 标签告诉浏览器该标签内的内容是 JavaScript，然后浏览器会执行它。我相信您能明白接下来的走向...

在上一关中，您注入了 HTML。在这一关中，您必须利用完全相同的存储型 XSS 漏洞在受害者的浏览器中执行一些 JavaScript。具体来说，我们希望您执行 JavaScript 代码 `alert("PWNED")` 来弹出一个警告框，告知受害者他们已被入侵。本关卡的 *方法* 与上一关完全相同；只有 *内容* 发生了变化，而突然间，您的攻击威力大增！

----

**调试：**
这里我们需要一种稍微高级一点的调试方法。主要有两个方面可能出错。

1.  首先，您可能没有正确注入您的 `<script>` 标签。
    您应该按照上一个挑战的调试路径进行类似检查：在 Firefox 中打开并查看源代码或检查元素，以确保它看起来是正确的。
2.  其次，您实际的 JavaScript 代码可能存在错误。
    JavaScript 错误会显示在您的 Firefox 控制台中。
    在 DOJO 的 Firefox 中打开 Web 开发控制台，加载页面，看看是否有任何问题！
    如果没有，可以考虑在 JavaScript 内部使用打印调试（例如，您可以使用 `console.log("wtf")` 打印到控制台）。

### XSS 3

在之前的示例中，您的注入内容首先存储在数据库中（作为帖子），并在 Web 服务器从数据库检索并将其发送到受害者浏览器时被触发。由于数据必须先存储后检索，因此这被称为 *存储型* XSS。然而，HTTP GET 请求及其 URL 参数的魔力为另一种类型的 XSS 打开了大门：*反射型* XSS。

反射型 XSS 发生在 URL 参数以某种方式被渲染到生成的 HTML 页面中时，这种方式再次允许攻击者插入 HTML/JavaScript 等。要执行此类攻击，攻击者通常需要诱骗受害者访问一个包含特定 URL 参数的、精心构造的 URL。这与存储型 XSS 不同，在存储型 XSS 中，攻击者可能只需在一个存在漏洞的论坛上发帖，然后等待受害者偶然看到它。

无论如何，本关卡涉及一个反射型 XSS 漏洞。本挑战的 `/challenge/victim` 程序在命令行接受一个 URL 参数，并将访问该 URL。欺骗 `/challenge/victim` 执行 JavaScript `alert("PWNED")`，您将获得 flag！

### XSS 4

与 SQL 注入和命令注入类似，有时您的 XSS 攻击发生在某些非理想的上下文环境中。
在 SQL 注入中，您处理过在引号中间进行注入的情况。
在 XSS 攻击中，您通常会注入到某个上下文中，例如本挑战中的 textarea。
通常情况下，textarea 中的文本仅仅是在页面文本框中显示的文本。
您能否突破此上下文并执行 `alert("PWNED")`？

与之前一样，本挑战的 `/challenge/victim` 程序在命令行接受一个 URL 参数，并将访问该 URL。

### XSS 5

实际的 XSS 攻击通常会尝试实现比 `alert("PWNED")` 更复杂的目标。
一个非常常见的目标是利用在受害者浏览器中执行 JavaScript 的能力，来发起伪装成受害者的新 HTTP 请求。
这可以通过多种方式实现，包括使用 JavaScript 的 `fetch()` 函数。

本挑战实现了一个更复杂的应用程序，您需要从 `admin` 用户的未发布的草稿帖子中提取 flag。
在 XSS 注入了 `admin` 之后，您必须利用注入发起一个 HTTP 请求（以 `admin` 用户身份），从而能够读取 flag。
祝您好运！
- 此挑战在登录后可使用发帖功能，帖子拥有是否公开的状态且可使用端点修改。
- 攻击者的帖子为载荷，帖子的公开端点为攻击点

----
**调试：**
本关卡在注入脚本时增加了额外的复杂度：`fetch()`。
现在，有三件事可能出错：

1. `<script>` 的 HTML 注入。
   同样，您可以通过在 DOJO 的 Firefox 中使用“查看源代码”或“检查元素”来验证。
   以 `guest` 身份登录（或修改脚本以便在实践模式下以 `admin` 身份登录），并通过图形界面进行测试。
1. JavaScript 本身。
   通过检查 Firefox 的 JavaScript 控制台中的错误并使用打印调试（通过 `console.log` 将信息输出到 Firefox 控制台）来验证。
1. 您将通过 `fetch()` 或其他方式触发的 GET 请求。
   您同样可以在 Firefox 中通过 Web 开发者工具的“网络面板”进行调试。
   保持该面板打开，触发您的攻击，并观察实际请求发生了什么。

### XSS 6

一旦攻击者能够在受害者浏览器中执行代码，他们就可以做很多事情。
您在之前的攻击中已经发起了 `GET` 请求，但通常，能够改变应用程序状态的是 `POST` 请求。
本挑战提升了真实感：`/publish` 端点现在需要一个 `POST` 请求。
幸运的是，`fetch` 支持此功能！

去弄清楚如何进行 `POST` 请求，并获取 flag。

### XSS 7

根据攻击者的具体目标，他们实际上可能想要的是受害者的整个账户。
例如，攻击者可能会利用 XSS 窃取受害者的身份验证数据，然后利用这些数据接管受害者的账户。

身份验证数据通常通过浏览器 Cookie 存储，例如在 `Authentication Bypass 2` 中所发生的情况（但通常安全性更高得多）。
如果攻击者能够泄露这些 Cookie，结果对受害者来说可能是灾难性的。

本关卡将登录用户的认证数据存储在 Cookie 中。
您必须使用 XSS 泄露此 Cookie，以便随后在请求中使用它来冒充 `admin` 用户。
这种泄露将通过 HTTP 发送到您运行的服务器上，而您需要的一切都可以通过 JavaScript 的 `fetch()` 函数及其访问（部分）网站 Cookie 的能力来实现。
- 此处admin的密码被包含在cookie内

----
**提示：**
这里的“您运行的服务器”实际上意味着使用 `nc` 在某个端口上监听就足够了。
查看 `nc` 的 `-l` 和 `-v` 选项。

## Cross-Site Request Forgery

### CSRF 1

你曾利用 XSS 注入 JavaScript 导致受害者发起 HTTP 请求。但如果没有 XSS 呢？能否直接“注入”HTTP 请求？令人震惊的是，答案是肯定的。

万维网的设计初衷是实现跨网站互联。网站可以嵌入其他网站的图片、链接至其他网站，甚至*重定向*到其他网站。所有这些灵活性都伴随着严重的安全风险，而几乎没有任何机制能阻止恶意网站直接诱导访问者发起可能敏感的请求（例如本例中向 `http://challenge.localhost/publish` 发送的 `GET` 请求）。这种*跨*站点*伪造*请求的方式被称为*跨站请求伪造*（简称 CSRF）。

注意我说的是“几乎”无法阻止。早在 1990 年代网络发展初期，人们就制定了[同源策略](https://en.wikipedia.org/wiki/same-origin_policy)来（尝试）缓解此问题。SOP 会阻止某一源（例如 `http://www.hacker.com` 或本例中的 `http://hacker.localhost:1337`）以某些安全敏感的方式与其他源（例如 `http://www.asu.edu` 或本例中的 `http://challenge.localhost/`）的站点交互。SOP 能阻断部分常见的 CSRF 攻击途径（例如使用 JavaScript 跨源发起请求时不会发送 cookie！），但仍存在大量绕过 SOP 的方法（例如通过完整重定向即可在保留 cookie 的情况下发起 `GET` 请求）。

在本关卡中，PwnPost 已修复其 XSS 漏洞（至少对 `admin` 用户如此）。你需要利用 CSRF 来发布带旗帜信息的帖子！本关卡的 `/challenge/victim` 将登录 PwnPost（`http://challenge.localhost/`），随后访问由你搭建的恶意网站（`http://hacker.localhost:1337/`）。`hacker.localhost` 指向你的本地工作区，但你需要自行在 1337 端口搭建 web 服务器。这同样可通过 `nc` 或 Python 服务器（例如使用 http.server 或直接修改挑战服务器代码）实现。由于这些站点属于不同源，SOP 保护机制将生效，因此请注意伪造请求的方式！

### CSRF 2

回想一下，源自 JavaScript 的请求会受到同源策略限制，这给上一关的 CSRF 攻击带来了些许复杂化。你已经掌握了如何在不使用 JavaScript 的情况下发起 `GET` 请求。那么对于 `POST` 请求能否实现同样的操作？

需知典型的 `POST` 请求通常由 JavaScript 调用的请求（受 SOP 限制无效）或 HTML 表单提交触发。你需要采用后者。当然，`/challenge/victim` 不会替你点击 `Submit` 提交按钮——你需要自行解决触发问题（提示：可通过 JavaScript 自动点击按钮；该请求仍将被视为表单来源！）。

开始进行 `POST` 型 CSRF 攻击获取旗帜吧！

### CSRF 3

让我们开始整合一些内容……  
一个 CSRF 攻击可以导致许多后果，包括*其他注入*！  
利用本关卡中的 CSRF 攻击来触发一个 XSS 攻击，并在 `http://challenge.localhost` 某处调用 `alert("PWNED")`！  

----  

**提示**：  
你可能需要在 `http://hacker.localhost:1337` 页面上使用 JavaScript 发起一个包含 `<script>` 标签的 URL 参数的 `GET` 请求。  
请注意：如果你在 HTML 中直接编码这段 JavaScript，你的 `<script>` 标签会包含字符串 `</script>`（作为 URL 参数的一部分）。  
这个字符串 `</script>` 会被浏览器解析为页面实际 `<script>` 标签的闭合标签，从而引发严重问题。  

如果遇到此错误，我建议在 `http://hacker.localhost:1337` 运行的 JavaScript 中动态构建该字符串（例如：`"</s"+"cript>"`）。  

### CSRF 4

很好，既然你已经掌握了 CSRF 到 XSS 的链式攻击原理，就请完成一次从 CSRF 触发 XSS，最终导致 Cookie 泄露的攻击，从而实现登录并获取旗帜！

----
**提示**：
你的解决方案可能包含两层 JavaScript：一层运行在你的 `http://hacker.localhost:1337` 页面上，另一层运行在反射型 XSS 中。
建议先手动触发包含该输入的页面并观察结果，对后者进行测试。
此外，由于此代码可能较为复杂，*VERY* 注意 URL 编码细节。
例如，`+` 将*不* 被编码为 `%2b`，*it is a special character in a URL* 会被解码为空格 (` `)。
可想而知，如果你在 JavaScript 中使用 `+`，这可能导致严重混乱。

### CSRF 5

本关卡修复了原本可通过 JavaScript 窃取 Cookie 的漏洞。  
Cookie 具有一个特殊设置，称为 `HttpOnly`，当启用此设置时，Cookie *仅* 可在 HTTP 头中访问，而无法通过 JavaScript 读取。  
这是一项安全措施，旨在防止你一直在进行的 Cookie 窃取行为。  
幸运的是，Flask 框架默认的 `session` Cookie 即为 `HttpOnly`，因此你无法通过 JavaScript 窃取它。  

那么，现在你该如何利用 CSRF 到 XSS 的链式攻击获取旗帜呢？  
幸运的是，你*并不需要*窃取 Cookie！  
一旦你能在页面内执行 JavaScript，就可以自由地 `fetch()` 其他页面，无需担心同源策略的限制，因为你现在已处于相同的源（Origin）。  
利用这一点，读取包含旗帜的页面，赢得关卡！

