# 二进制漏洞利用

二进制代码是源代码最真实的体现，而*二进制代码利用*是网络安全中最富挑战性的技术之一。在这里，你将初步接触这一领域：踏入一个令人惊叹的*分支学科*的第一步。

- 对于父进程fork的子进程，拥有相同的栈金丝雀与内存随机位置。以此作为爆破可行性的原理：
    - 金丝雀逐字节提取
    - 内存随机位置按照分页的0x1000对齐（最后3位不变）修改地址

分页 & 随机地址:
- 虚拟内存分页：页面大小 0x1000（4096 字节），基址按 0x1000 对齐
- PIE 程序：整个程序的代码段以「某个随机页」为基址加载
    - 内核会在某一块虚拟内存区域里，选一个随机的页基址
    - 把整个 .text（代码段）、.data 等段映射到这个基址之后的固定偏移位置。
- 函数在 binary 里的偏移是固定的，所以地址的低 12 bit（3 个 16 进制位）是不变的
    - 内核随机的是“页号”（高位）。即，低 12 bit 必为 0，高位随机

函数实际地址 = 随机基址 + 该函数在文件中的偏移
即
地址 = 随机基址 + 固定偏移

## Corrupting Memory

### 你的首次溢出（简单）

通过栈缓冲区溢出来设置正确的条件以获取flag！

我们的栈指针指向 0x7ffd7aafd900，基指针指向 0x7ffd7aafd980。
这意味着我们的栈帧中包含（十进制）18个8字节字，
包括保存的基指针和返回地址，总计144字节。
输入缓冲区起始于 0x7ffd7aafd930，位于栈帧的中段
（栈中"上方"是该函数使用的其他局部变量）。
您的输入将被读取到此缓冲区中。
缓冲区长度为61字节，但程序允许您提供任意长度的输入，
从而造成缓冲区溢出。

在本关卡中，存在一个"win"变量。
默认情况下，该变量的值为零。
但当该变量变为非零时，将打印flag。
您可以通过溢出输入缓冲区使该变量变为非零。
"win"变量存储在 0x7ffd7aafd970，距离输入缓冲区起始位置64字节处。

我们已为本挑战禁用以下标准内存破坏缓解措施：
- 该二进制文件*非*位置无关。这意味着
每次运行时它都将位于相同的内存位置，通过分析二进制文件
（使用objdump或阅读本输出），您可以确定覆盖返回地址所需的具体数值。

您选择发送4096字节的输入！
这将允许您从 0x7ffd7aafd930（输入缓冲区起始地址）
一直写入到 0x7ffd7aafe930（不包括该地址）（即超出缓冲区末端4035字节处）。

```c
struct
{
    char input[61];
    int win_variable;
} data  = {0} ;

if (data.win_variable)
{
    win();
}
```
- 若查看代码需预测填充，若查看汇编则可直接确认栈空间
- 注意内存空间分配时的对齐

### 你的首次溢出（困难）

本题与其"简单"版本在安全视角下完全相同，但存在以下差异：

1. 与简单版本不同，本题不会提供有用的调试输出。
   您需要使用调试器自行恢复这些信息。
2. 对于所有其他"困难"版本，将不提供源代码，您需要以简单版本为参考，通过逆向工程分析二进制文件。
   但针对本题，为帮助您熟悉简单版与困难版的区别，我们将提供源代码。
3. 随机化方式存在差异。
   缓冲区的长度可能不同，偏移量可能变化等。
   您需要通过逆向工程从二进制文件中获取这些信息！

```c
struct
{
    char input[91];
    int win_variable;
} data  = {0} ;

unsigned long size = 4096;

int received = read(0, &data.input, (unsigned long) size);

// buffer地址       rbp-0x70
// win_variable     rbp-0x14
00401ced  mov     rdx, qword [rbp-0x78 {size}] 
00401cf1  lea     rax, [rbp-0x70 {input}] 
00401cf5  mov     rsi, rax {input} 
00401cf8  mov     edi, 0x0 
00401cfd  call    read

00401d37  mov     eax, dword [rbp-0x14 {win_variable}]
```

### 精确控制（简单）

你发现了一个缓冲区溢出！现在该怎么办？你不能只是无差别地输入数据，因为这可能会将程序的控制数据破坏到不可恢复的状态。我们将在本次挑战中探讨这一概念：你可以溢出，但如果溢出*过多*，你将无法获得标志。

### 精确控制（困难）

主题统一的困难挑战描述

### 变量控制（简单）

到目前为止，您的*缓冲区溢出*只是将变量设置为非零值。  
当然，*内存错误*通常能实现对程序状态的更高级控制。  
在此挑战中，您必须精确溢出缓冲区，将*获胜条件变量*设置为特定值。  
需要注意以下几点：  

- 您需要写入*二进制数据*。  
  这些数据无法通过键盘直接输入，我们建议您使用 Python 等工具生成这些字节。  
- 请牢记*字节序*！  
- 根据您生成输入数据的方式，可能会意外地以换行符终止输入！  
  例如，bash 的 `echo` 命令默认会以换行符结尾（可使用 `-n` 标志禁用此行为）。  
  这些换行符可能导致问题——如果您依赖对程序变量的精确控制（本模块中正是如此），一个多余的换行符可能意外破坏程序状态并导致您的漏洞利用失败。  
  如果不确定输入是否包含多余换行符，可将其保存到文件中并使用 *hd* 等十六进制转储工具查看。  

注意，python 使用 `sys.stdout.buffer.write()` 输出原始字节流

### 变量控制（困难）

主题统一的困难挑战描述

### 控制流劫持（简单）

溢出缓冲区并破坏堆栈以获取标志！
- 覆盖返回地址
- 注意栈分配以及push

### 控制流劫持（困难）

主题统一的困难挑战描述

### 棘手的控制流劫持（简单）

溢出缓冲区并破坏堆栈以获取旗帜，但这次绕过另一个旨在阻止你获取旗帜的检查！

```c
void win_authed(int token)
{
    static char flag[256];
    static int flag_fd;
    static int flag_length;

    if (token != 0x1337) return;
```
- 简单方法：选择win函数中判断条件后的地址

### 棘手的控制流劫持（困难）

主题统一的困难挑战描述

### 位置无关可执行文件（简单）

在之前的关卡中，您知道 `win()` 函数的地址，因为二进制文件总是加载到内存中的相同位置。
在本关卡中，我们将探讨当您要溢出的可执行文件是*位置独立*时所面临的挑战！
*位置独立可执行文件*会被加载到内存中的随机位置。
因此，您无法确切知道 `win()` 函数位于何处。

那么该如何解决这个问题呢？
在 x86（以及大多数其他现代架构）上，内存是*逐页*映射到进程的内存空间中的。
一个内存页是连续的 0x1000（4096）字节块，出于性能和内存管理的原因，其起始地址（页地址）会对齐到 0x1000 的倍数（关于此点，在 pwn.college 课程体系中会有 更深入的讲解(https://pwn.college/system-security/kernel-security)！）。
例如，以下都是可能的页地址示例：

- `0x5f7be1ec2000`
- `0x7ee1382c9000`
- `0x6513a3b67000`

您是否注意到最后三位十六进制数（例如，12 位，或 1.5 字节，或亲切地称为 3 个“半字节”）都是 `0`？
我们可以利用这一点来*部分*预测二进制文件中的地址。
举个例子，假设我们的 `win()` 函数位于二进制文件起始位置之后 `0x1337` 字节处（因此，如果二进制文件不是位置独立的，它很可能位于 `0x401337`）。
这意味着，例如，如果我们的 PIE 二进制文件被加载到页地址 `0x6513a3b67000`，那么它的 `win` 函数将位于 `0x6513a3b68337`。
如果它被加载到 `0x5f7be1ec2000`，它的 `win` 函数将位于 `0x5f7be1ec3337`，依此类推。

因此，实际上，我们知道二进制文件中任何地址的最后三个半字节，因为这些半字节由于页对齐（到 `0x1000` 字节）而永远不会改变。
这为我们提供了一种解决方法：我们可以覆写已保存返回地址的最低有效字节（我们可以通过调试二进制文件得知该字节），从而将返回到 main 函数的指令重定向到任何共享其余 7 个字节的指令。
由于最后一个字节在不同执行之间是恒定的（由于页对齐），这种方法将始终有效。
如果我们要将执行重定向到的地址距离已保存的返回地址稍远，并且我们需要写入两个字节，那么其中一个半字节（第四低有效位）将是猜测值，并且在 16 次尝试中会有 15 次是错误的。
这没关系：我们可以多次运行我们的漏洞利用程序直到成功（从统计学上看，尝试 11 次后成功率约为 50%，尝试 36 次后成功率约为 90%）。

### 位置无关可执行文件（困难）

主题统一的困难挑战描述

### 字符串长度（简单）

溢出缓冲区并破坏栈以获取标志，但这次是在一个*位置独立*（PIE）二进制文件中，并且会对您的输入进行额外检查。

----

**注意：**
您需要具备此挑战源代码中所用函数的基础知识才能解决它。
不知道某个函数的作用？
请查阅其 `man` 手册页！

```c
char *tmp_input = malloc(size);
int received = read(0, tmp_input, (unsigned long) size);
size_t string_length = strlen(tmp_input);
assert(string_length < 120);
memcpy(&data.input, tmp_input, received);
```
- 新增将输入保持到堆，再使用memcpy复制到栈
- 检查输入长度，但上限低于覆盖返回地址所需长度，字符串结尾根据`\0`判断

### 字符串长度（困难）

主题统一的困难挑战描述

## Writing Shellcode

获得shellcode：
写汇编代码 - 编译为可执行文件 - 提取指令字段
```sh
# 无链接库、静态
gcc -nostdlib -static -o shellcode-elf shellcode.s 

# 复制指令字段
objcopy --dump-section .text=shellcode-raw shellcode-elf
```

调试shellcode：
- int3 汇编硬编码调试断点
- 添加汇编标签后设置调试断点
- strace
- 内存映射
    ```c
    void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

    page = mmap(0x1337000,      // 期望映射到的虚拟地址。
                0x1000,         // 映射的大小 4KB
                PROT_READ | PROT_WRITE | PROT_EXEC, // 页的权限是：可读 / 可写 / 可执行
                MAP_PRIVATE | MAP_ANON, // 匿名映射其内容全 0 | 写时复制的私有映射
                0, 0            // 对匿名映射来说这两个参数会被忽略，随便写成 0。
                );
    // 调用成功后，page 就指向一块 4KB 的、RWX 的内存区域。

    // 从标准输入读取最多 4096 字节数据，直接写入刚刚分配的那块 RWX 内存。
    read(0, page, 0x1000);

    // void(*)() 是 “指向 void f(void) 形式函数的指针” 的类型。
    // 即，强制类型转换为函数指针后调用那块 RWX 内存
    ((void(*)())page)();
    ```
    `cat shellcode-raw | ./tester`


常见错误：
- 大小字段
    ```log
    single byte:
    mov [rax], bl
    2-byte word:
    mov [rax], bx
    4-byte dword:
    mov [rax], ebx
    8-byte qword:
    mov [rax], rbx

    single byte:
    mov BYTE PTR [rax], 5
    2-byte word:
    mov WORD PTR [rax], 5
    4-byte dword:
    mov DWORD PTR [rax], 5
    8-byte qword:
    mov QWORD PTR [rax], 5
    ```

- 函数的输入终止字符  
    ```log
    Byte (Hex Value)            Problematic Methods
    Null byte \0 (0x00)         strcpy
    Newline \n (0x0a)           scanf gets getline fgets
    Carriage return \r (0x0d)   scanf
    Space (0x20)                scanf
    Tab \t (0x09)               scanf
    DEL (0x7f)                  protocol-specific (telnet, VT100, etc)
    ```
    即，对应的注入点函数需在载荷中避免对应字符

### 实用资源

- [x86_64汇编指令列表](http://ref.x86asm.net/coder64.html)
- [系统调用表！](https://syscall.sh/)
- [Felix Cloutier](https://www.felixcloutier.com/x86/)：深入探索指令的核心解析，助您精准掌握每步操作。

### 基础 Shellcode

编写并执行shellcode以读取旗帜！

此挑战会读入一些字节，根据特定挑战配置对其进行修改，然后将其作为*代码*执行！这是一种常见的漏洞利用场景，称为*代码注入*。通过本系列挑战，您将在各种限制条件下练习*shellcode*编写技能！为确保您是在进行shellcode编写而非使用其他技巧，本挑战将清理所有环境变量和参数，并关闭所有大于2的文件描述符。

在此挑战中，shellcode将被复制到栈上并执行。由于栈的位置在每次执行时都是随机化的，您的shellcode需要是*位置无关的*。

```c
uint8_t shellcode_buffer[0x1000];
shellcode = (void *)&shellcode_buffer;

shellcode_size = read(0, shellcode, 0x1000);

((void(*)())shellcode)();
```
注，查看模块视频或幻灯片。使用系统调用读取并输出flag

### NOP 雪橇

编写并执行shellcode来读取flag，但你输入的一部分会随机被跳过。

移动buffer指针，随机跳过最多800字节
```c
int to_skip = (rand() % 0x700) + 0x100;
shellcode += to_skip;
shellcode_size -= to_skip;
```
nop的指令码为`90`

### 无空字节 Shellcode

编写并执行shellcode来读取flag，但你的输入空间受限...

```c
shellcode = mmap((void *)0x182d5000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, 0, 0);

puts("This challenge requires that your shellcode have no NULL bytes!\n");
for (int i = 0; i < shellcode_size; i++)
    if (!((uint8_t *)shellcode)[i])
    {
        printf("Failed filter at byte %d!\n", i);
        exit(1);
    }
```
- 如幻灯片展示，使用位移、低段寄存器移动、异或等方式消除空格字节

## Using Shellcode

### 劫持至（已映射）Shellcode（简单）

整合你的技能，劫持控制流到一个你单独输入的内存映射的shellcode！

```c
shellcode = mmap((void *)0x1f7b3000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANON, 0, 0);
shellcode_size = read(0, shellcode, 0x1000);

size = 4096;
int received = read(0, &data.input, (unsigned long) size);
```
- 第一段的0x1000个字符在内存映射注入代码，应用程序在中间拥有消耗回车的暂停，第二段的字符覆盖返回地址到注入代码的内存映射地址

### 劫持至（已映射）Shellcode（困难）

主题统一的困难挑战描述

```asm
004013b7  mov     esi, 0x1000 
004013bc  mov     edi, 0x2d32f000 
004013c1  call    mmap

00401422  mov     rax, qword [rel shellcode] 
00401429  mov     edx, 0x1000 
0040142e  mov     rsi, rax 
00401431  mov     edi, 0x0 
00401436  call    read

004014a2  lea     rax, [rbp-0x80 {buf}] 
004014a6  mov     rsi, rax {buf} 
004014a9  mov     edi, 0x0 
004014ae  call    read
```

### 劫持至 Shellcode（简单）

整合你的技能，劫持控制流以注入作为攻击一部分的shellcode！

```c
struct
{
    char input[40];
} data  = {0} ;

size = 4096;

int received = read(0, &data.input, (unsigned long) size);
```

### 劫持至 Shellcode（困难）

主题统一的困难挑战描述

```ass
# challenge()
00401769  mov     rdx, qword [rbp-0x8 {nbytes}] 
0040176d  lea     rax, [rbp-0x90 {buf}] 
00401774  mov     rsi, rax {buf} 
00401777  mov     edi, 0x0 
0040177c  call    read
```
- 由于关闭了地址随机，于是可用gdb看到固定的运行时地址。

### 拓展学习

- OpenSecurityTraining2 提供了涵盖安全漏洞的课程：[漏洞分析 1001](https://ost2.fyi/Vulns1001) 与 [漏洞分析 1002](https://ost2.fyi/Vulns1002)。

