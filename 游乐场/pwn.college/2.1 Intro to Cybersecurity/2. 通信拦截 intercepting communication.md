# 通信拦截

学习各种拦截和操纵网络通信的技术，从连接远程主机到执行*中间人攻击*。

### 开始使用

要开始使用此模块，请在终端会话中运行位于 `/challenge` 的挑战。这将为您创建需要操作的网络环境。同时，您的终端提示符将发生变化，以指示您当前正在操作的主机。您可以运行 `exit` 命令返回到挑战网络之外的原始终端提示符。在挑战环境之外尝试连接网络主机将无法正常工作。

### 工具文档

- [手册页：`nc`](https://linux.die.net/man/1/nc)
- [手册页：`ip`](https://linux.die.net/man/8/ip)
- [手册页：`tcpdump`](https://linux.die.net/man/8/tcpdump)
- [`ip` 命令速查表](https://access.redhat.com/sites/default/files/attachments/rh_ip_command_cheatsheet_1214_jcs_print.pdf)
- [Wireshark 用户指南](https://www.wireshark.org/docs/wsug_html_chunked/)
- [Scapy 文档](https://scapy.readthedocs.io/en/latest/)

## 挑战

### 连接

从您位于 10.0.0.1 的主机连接到端口 31337 上位于 10.0.0.2 的远程主机。一个很好的方法是使用 `nc` 命令（发音为 "netcat"），它允许您从命令行打开网络连接。例如，要连接到端口 4242 上位于 10.0.0.42 的远程主机，您需要运行：

```sh
nc 10.0.0.42 4242
```
- 运行 /challenge/run 后连接到目标地址与端口

### 发送

从您位于 10.0.0.1 的主机连接到端口 31337 上位于 10.0.0.2 的远程主机，并发送消息：`Hello, World!`。

如前所述，您需要使用 netcat 命令。
您会注意到 netcat 将会*挂起*（例如，您将不会返回 shell 提示符），直到连接关闭。
与大多数*挂起*的进程一样，您可以通过按下 `Ctrl-C` 来终止该进程。

不过在此挑战中，您需要向远程主机发送一条消息。
如果您将该消息键入终端，不会立即发生任何情况。
这是因为您的终端默认会*缓冲*您键入的输入，直到您按下 `Enter` 键！
在键入消息后按下 `Enter` 键，一个包含整个消息的数据包将被发送到远程主机。

### 关闭

从您位于 10.0.0.1 的主机连接到端口 31337 上位于 10.0.0.2 的远程主机，然后*关闭*连接。

有时连接的另一端希望等待您完成发送所有数据后再向您返回数据。
假设存在一种协议，客户端可能需要长时间发送大量数据，服务器才能返回最终结果。
在这种情况下，预先确定协议中要发送的数据总量可能没有意义，因为客户端在开始时可能不知道需要发送多少数据。
我们该如何处理这种情况？

一种方案是让客户端在最后发送一个仅包含 "END" 的数据包。
但网络数据包可能很复杂，网络无法保证它们不会被拆分或合并。
或者，如果您希望能够将 "END" 作为数据的一部分发送呢？

Netcat 是一个简单的工具，它将标准输入的数据转换为网络数据包，反之亦然，将网络数据转换为标准输出。
那么如何使用 netcat 以这种方式关闭网络连接呢？
您执行等效的文件操作：关闭标准输入！
在交互式终端会话中，您可以通过按下 `Ctrl-D` 来实现这一点。

遗憾的是，netcat 默认可能不会实际执行此操作。
请查阅 netcat 的手册页（`man nc`），查看是否有方法可以配置 netcat 在关闭标准输入（EOF）后*关闭*网络连接。

### 监听

从您位于 10.0.0.1 的主机监听端口 31337，等待来自位于 10.0.0.2 的远程主机的连接。

一旦连接建立，该连接将是*双向*的，意味着双方都可以发送和接收数据。
然而，要实际建立连接，一方必须监听传入连接，而另一方必须连接到该监听方。
这次，与之前不同，您是监听方。

请查阅 netcat 的手册页（`man nc`）以了解如何监听传入连接。

### 扫描1

在此挑战中，您将尝试连接到远程主机。首先需要运行 `/challenge/run` 以访问网络：该命令将使您进入具有网络访问权限的主机 shell 环境。

从您所在的主机 10.0.0.1 连接到 10.0.0.0/24 子网上某个未知远程主机的 31337 端口。幸运的是，该子网上只有 256 个可能的主机，因此您可以全部尝试！

一个可用于辅助的简单工具是 *ping*。如果您对主机执行 "ping" 操作并得到响应，说明主机在线；否则 ping 将超时并提示无法访问该主机。例如，尝试 ping 自己：

```sh
ping 10.0.0.1
```

这将持续 ping 操作直到您按 `ctrl-c` 停止。您也可以尝试 ping 已知离线的主机：

```sh
timeout 10 ping 10.0.0.2
```

这将运行（最多）10 秒 ping，但应在超时前看到指示主机不可达的 ping 消息。

与大多数命令一样，您可运行 `man ping` 查看 *ping* 的手册页。将此视为练习 shell 脚本技能的机会！当然您可以手动 ping 全部 256 个主机，但使用 *for* 循环可能更高效：

```sh
for i in $(seq 10); do
  echo $i
done
```

- 重定向输出与错误到空文件，使用返回值判断是否命中，设置后台运行以并行执行循环。

----  
**重要提示：** 不要忘记运行 `/challenge/run` 访问网络，否则将无法找到远程主机。

### 扫描2

从您所在的主机 10.0.0.1 连接到 10.0.0.0/16 子网上某个未知远程主机的 31337 端口。

现在我们的网络开始变得更大了！该子网上有 65,536 个可能的主机，因此手动查找远程主机将非常耗时。即使一个基本的 `for` 循环每秒处理 10 个主机，也需要一个多小时才能完成！

我们当然可以通过 Shell 脚本实现更复杂的操作（例如并行处理等），但现在让我们考虑一个专门用于此类任务的标准工具：*nmap*。

*nmap* 是一款功能强大的网络扫描工具，可用于发现计算机网络上的主机和服务。例如，您可以使用以下命令扫描 10.0.0.0/30 网段中哪些主机在线（以及这些主机上运行的常用服务）：

```sh
nmap 10.0.0.0/30
```

大约 15 秒内，您应该会看到您位于 10.0.0.1 的主机如预期那样在线。

在进行网络扫描时，了解其对网络的潜在影响非常重要。在默认设置下，*nmap* 会尝试保持一定的礼貌，不会用大量数据包完全淹没网络。尽管如此，运行网络扫描仍有可能导致网络拥塞甚至触发安全警报，因此了解其潜在影响至关重要。因此，您不应在非您拥有或未经授权扫描的网络上运行网络扫描。

在当前这个网络中，我们可以进行更主动、更“直接”的扫描。您需要查看 *nmap* 的手册页（`man nmap`）以了解如何加速扫描过程：您特别需要关注每秒发送的数据包数量。禁用某些默认扫描（例如 DNS 解析）也可以加快扫描速度。如有疑问，可使用 `-v` 参数查看 *nmap* 当前正在执行的操作的更多信息。

### 监控1

监控来自远程主机的流量。
您的主机已在端口 `31337` 上接收流量。

注意，此处需使用图形 UI 打开wireshark。否则将找不到显示环境变量而报错。
以挑战程序的root权限运行后过滤端口查看数据，右键复制为ascii码

----

**提示：**
您可能需要使用 *Wireshark* 工具来完成此任务。
该工具已安装在 dojo 环境中，您可以从 `10.0.0.1` 客户端的终端启动它！
请确保从此处启动：若从其他位置（如工作区的不同终端）启动，*Wireshark* 将无法在正确的主机上运行！
*Wireshark* 可能需要较长时间才能启动。
如果等待超过一分钟，则可能出现异常...

### 监控2

监控来自远程主机的慢速流量。
您的主机已在端口 `31337` 上接收流量。
- wireshark GUI 的 follow TCP Stream 查看 
    把同一条 TCP 连接里的所有 payload，按顺序重组并展示出来
- 导出捕获数据包到文件后使用 tshark 解析

### Cookie嗅探

您已学会嗅探流量，但知识仅是行动的开端。现在是将此技能应用于实际安全场景的时候了：窃取管理员的 Cookie 并通过 GET 请求获取 flag！

- http协议中携带cookie，需查看挑战程序以定位端点

----

**提示：**
一旦成功窃取 Cookie，您可以运用在 Talking Web(/fundamentals/talking-web) 中学到的全套 HTTP 工具来使用该 Cookie！但无论采取何种操作，请确保在 `10.0.0.1` 终端中执行，以保证在正确的主机上运行。您可以在后台运行 *Wireshark* 或其他所需工具（正如您在 The Linux Luminarium(https://pwn.college/linux-luminarium/processes/) 中学到的那样）。

### 网络配置

配置您的网络接口。
位于 `10.0.0.2` 的远程主机正尝试与 `10.0.0.3` 的远程主机在端口 `31337` 上进行通信。

- 目标主机正在发送ARP协议查询地址，设置本机网络配置IP与网段后内核将自动发送ARP确认。

### 防火墙1

位于10.0.0.1的主机正在端口31337接收流量；阻止该流量。
- nftables 无法使用

### 防火墙2

你的主机10.0.0.1正在端口31337上接收流量；阻止来自远程主机10.0.0.3的流量，但必须允许来自远程主机10.0.0.2的流量。

### 防火墙3

从你的主机10.0.0.1连接到远程主机10.0.0.2的31337端口。这次我们阻止了到31337端口的出站流量，所以你必须先允许它。

### 拒绝服务攻击1

IP地址10.0.0.3的客户正在与IP地址10.0.0.2的服务器在端口31337上进行通信。拒绝此服务。
- 无并发。一个tcp连接即可阻塞

### 拒绝服务攻击2

客户端10.0.0.3正在与服务器10.0.0.2的31337端口通信。拒绝此服务。
这次服务器为每个客户端连接创建一个新进程。
- 有并发，无超时。子进程阻塞

### 拒绝服务攻击3

客户端10.0.0.3正在与服务器10.0.0.2的31337端口通信。拒绝此服务。

这次服务器为每个客户端连接创建一个新进程，并将每个会话限制为1秒。
- 之前使用循环 nc 连接通过，但nc使用1个进程换取服务器端1个连接，需高性能解决方案。
- 使用 python 的 asyncio 异步协程库

### 以太网

手动发送一个以太网数据包。该数据包应为`Ether type=0xFFFF`。该数据包应发送到远程主机`10.0.0.2`。
- 使用挑战 python 代码中的 scapy 库，设置字段后使用 `sendp()` 在以太网层发送

### IP协议

手动发送一个互联网协议数据包。该数据包应具有`IP proto=0xFF`。该数据包应发送到远程主机`10.0.0.2`。
- 设置字段后使用 `send()` 在网络层发送（不应当包含以太网堆叠）

### TCP协议

手动发送一个传输控制协议数据包。该数据包应具有`TCP sport=31337, dport=31337, seq=31337, ack=31337, flags=APRSF`。该数据包应发送到远程主机`10.0.0.2`。

### TCP三次握手

手动执行传输控制协议握手。初始数据包应具有`TCP sport=31337, dport=31337, seq=31337`。握手应在远程主机`10.0.0.2`上进行。
- `sr1` 函数发送并等待响应，返回响应内容
- 第一个包设置 `S` 标记
- 获取响应，提取序列字段+1
- 第二个包设置 `A` 标记，并设置更新的序列字段

### UDP协议

你现在是 TCP 领域的专家。如你所知，TCP 是一种优秀的协议，但一次只能通过一个连接进行通信。  
TCP 稳定可靠，但也相当复杂。  
当然，所有复杂性都会带来性能成本：握手、确认等操作都需要时间。

为解决这一问题，互联网的发明者提出了 UDP：*用户数据报协议*。  
UDP 是一种*极其简单*的协议。  
与 TCP 需要跟踪大量信息不同，UDP 头部仅包含源端口、目标端口、长度和数据包校验和。  
超级简单！

但这种简洁性也带来一些权衡。  
由于缺乏 TCP 的功能，UDP 没有“连接”的概念。  
每个数据包本身不与其他数据包关联，若需要此类关联，需由网络应用程序自身实现。

这使得编写 UDP 服务器和客户端有些特殊。  
使用 UDP 套接字时，套接字 `s` 不再需要 `s.listen` 和 `s.accept`：只需通过 `s.recvfrom` 接收数据（返回接收的字节和发送方地址，从 UDP 数据包中获取），并通过 `s.sendto` 发送数据（需传入要发送的字节和目标地址）。  
因此，单个服务器循环可同时处理多个客户端交互，但也容易以不安全的方式混淆数据。

在此挑战中，你将建立首个 UDP 连接。  
从你的主机 10.0.0.1 连接到端口 31337 上的远程主机 10.0.0.2，并发送消息：`Hello, World!\n`。  
你可使用 Python 或 netcat，但我们推荐前者，因为在后续挑战中会更实用。

### UDP协议2

虽然我们在 TCP 部分没有探讨这一点，但除了选择目标端口外，TCP 和 UDP 都可以设置它们的*源*端口。

我们将在此练习这一点——你可以使用套接字上的 `s.bind` 来设置源端口，这与服务器设置其监听端口的方式完全相同。

阅读 `/challenge/run` 的源代码，查看你需要使用的源端口！

----

**注意：**
你必须在发送数据*之前*设置源端口！
否则，Linux 会选择一个随机源端口（这是未调用 `bind` 时的默认行为）。

### UDP欺骗1

UDP 存在两个风险：首先，它常被用于人们为了性能而走捷径的场景。
其次，它迫使程序员必须显式跟踪会话。
这种组合可能导致安全问题。

在此挑战中，连接的一方可能将非受信连接误认为受信连接，并打印标志。
你能触发这种混淆吗？

----

**注意：**
在本关卡中，当你触发混淆时，标志将直接打印到控制台。
我们后续将研究如何实际地外传该标志。

### UDP欺骗2

TCP 所提供的功能与 UDP 的基础特性之间存在相当宽的差距。
有时，开发者希望获得*部分*这些功能，最终选择在 UDP 之上重新实现他们所需的功能。
这会导致一些奇怪的情况，例如能够触发向其他服务器的出站流量，这可能应用于拒绝服务[放大攻击](https://www.cisa.gov/news-events/alerts/2014/01/17/udp-based-amplification-attacks)。

这个挑战并非直接泄露 flag，而是允许你将其重定向到另一台服务器。
你能在另一端捕获到它吗？

注，似乎由于容器隔离而导致多个shell无法查看对方的包。
可能需在一个终端内设置前后台

----

**提示：**
你需要使用一个 UDP 服务器来实际接收 flag（例如使用 Python 或 netcat），或者即使没有服务器在监听，也可以在 flag 发送到你时使用 Wireshark 从网络上嗅探到它！


### UDP欺骗3

当然，之前的欺骗之所以有效，是因为你知道客户端正在使用的源端口，因此能够伪造服务器的响应。
事实上，这正是[域名系统](https://en.wikipedia.org/wiki/Domain_Name_System)中一个[非常著名的漏洞](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=0c1e863b6698808b724def8793d7cba023494808)的核心所在，该系统用于促进将诸如 `https://pwn.college` 之类的主机名转换为相应的 IP 地址。
该漏洞允许攻击者伪造来自 DNS 服务器的响应，并将受害者重定向到他们选择的 IP 地址！

针对该漏洞的修复措施是随机化 DNS 请求发出的源端口。
同样地，此挑战也不再*将源端口绑定到 31338*。
你还能强制获取响应吗？


----

**提示：**
源端口在每个套接字上仅设置一次，无论是在绑定时还是在第一次调用 `sendto` 时。
当你面对一个未知的固定数字时，你会怎么做？

### UDP欺骗4

让我们稍微提升一下难度：这个挑战会检查响应是否来自正确的服务器！
幸运的是，UDP 的伪造比 TCP 要容易得多。
在 TCP 中，伪造服务器响应需要你了解序列号以及一大堆其他*难以猜测*的信息。
但 UDP 并非如此！

继续使用 scapy 来精心构造服务器响应吧，就像你之前处理 TCP 时那样，让我们看看 flag 如何被获取！


### ARP协议

手动发送一个地址解析协议（ARP）数据包。
该数据包应通知远程主机，IP 地址 `10.0.0.42` 可以在以太网地址 `42:42:42:42:42:42` 处找到。
该数据包应发送到位于 `10.0.0.2` 的远程主机。
- 使用以太网发送，设置ARP操作头部

### 拦截

拦截来自远程主机的流量。
位于 `10.0.0.2` 的远程主机正在端口 `31337` 上与位于 `10.0.0.3` 的远程主机进行通信。
- 结合ARP与TCP握手

### 中间人攻击

来自远程主机的*中间人*流量。
位于 `10.0.0.2` 的远程主机正在端口 `31337` 上与位于 `10.0.0.3` 的远程主机进行通信。
- 双向ARP投毒，重写头部。可成功转发后修改数据，并删除长度与校验和字段以自动计算。