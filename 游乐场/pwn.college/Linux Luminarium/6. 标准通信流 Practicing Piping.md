# Practicing Piping

您可能已经注意到，运行某些命令时会在终端上输出数据。
到目前为止，这已经为您输出了许多标志（flag），但如同许多事物一样，背后的技术要深入得多。
命令行中处理输入和输出的机制正是命令行强大功能的来源。

本模块将向您介绍*输入输出重定向*。
简而言之，Linux 中的每个进程都有三个初始的标准通信通道：

- 标准*输入*是进程接收输入的通道。例如，您的 Shell 使用标准输入来读取您输入的命令。
- 标准*输出*是进程输出正常数据的通道，例如之前挑战中打印给您的标志，或是 `ls` 等实用程序的输出。
- 标准*错误*是进程输出错误详情的通道。例如，如果您输错了命令，Shell 会通过标准错误输出提示该命令不存在。

由于这三个通道在 Linux 中使用极为频繁，它们通常以更短的名称而闻名：`stdin`、`stdout`、`stderr`。
本模块将教您如何重定向、链接、阻塞以及以其他方式操控这些通道。
祝您好运！

### 资源

- 一篇关于 [Linux Shell 中 I/O 重定向](https://web.archive.org/web/20220629044814/http://bencane.com:80/2012/04/16/unix-shell-the-art-of-io-redirection/)的论文，这在本次作业中有应用。
    输入和输出流：    
    - stdin  
        从用户键盘获取命令的输入。stdin 的文件描述符是 0，对应的文件是 /dev/stdin。
    - stdout  
        程序的普通输出。stdout 的文件描述符是 1，对应的文件是 /dev/stdout。
    - stderr  
        程序的错误输出。stderr 具有文件描述符 2，以及文件/dev/stderr。
    
    在 Unix 环境中，当程序打印错误或诊断信息时，它使用标准错误流而不是标准输出；这有助于防止将命令的错误与同一命令的输出混合。

    重定向到文件：
    `命令 > 文件`
    - `>`符号用于重定向到文件；  
        但请注意，单个`>`会截断文件，然后将重定向的数据写入文件，这实际上会替换你的数据。如果指定的文件不存在，则会创建该文件。   

    `>` 符号默认会重定向标准输出，但你可以通过在重定向符号前放置适当的标准文件描述符来指定是重定向标准输出还是标准错误：
    - `1>` stdout（默认）
    - `2>` stderr

    重定向到文件并追加数据:
    `命令 >> 文件`
    - `>>`符号，被重定向的输出会追加到文件中，而不是完全覆盖文件。同样，可以使用文件描述符来指定是将标准输出还是标准错误写入指定的文件。

    从文件重定向输入：
    `命令 < 文件` 或 `< 文件 命令`
    - `<`（也可以用来将文件重定向到程序的标准输入。
    
    
    将一个程序的输出管道传输到另一个程序:
    `命令 | 命令`
    - `|` （管道符）用于将一个命令的标准输出重定向到另一个命令的标准输入。管道符`|`不被视为重定向操作符，而是一个控制操作符；虽然管道符`|`用于重定向输出，但并非所有控制操作符都具有此功能。

    将标准错误重定向到标准输出:
    - `2>&1` 在使用重定向时，你可以使用`&N`（其中 N=文件描述符）将两种输出方式重定向到同一个路径。这也可以与`|`控制运算符一起使用。
    
    写入文件和 stdout:
    `命令 | tee 文件`
    - `tee` 是一个命令，它会接收传递给它的 stdin，并将这些内容写入指定的文件和 stdout。我发现当运行一个命令时，既想记录输出又想在屏幕上看到输出，这种情况非常实用。  
        - `-a` 标志来使用 `tee` 命令，输出将会追加到指定的文件中而不是覆盖。

- Linux 中 [I/O 重定向的绝佳视觉指南](http://www.rozmichelle.com/pipes-forks-dups/)。
    - 如果一个命令不接受来自 stdin 的输入，那么传递给该命令的数据将被运行该命令的程序忽略，因为该程序没有编写来处理输入数据。

    文章关联了文件描述符与流。


## 挑战

### 重定向输出

首先，我们来看如何将标准输出重定向到文件。你可以使用 `>` 字符来实现，如下所示：

```console
hacker@dojo:~$ echo hi > asdf
```

这将把 `echo hi` 的输出（即 `hi`）重定向到文件 `asdf`。随后你可以使用诸如 `cat` 的程序来输出该文件内容：

```console
hacker@dojo:~$ cat asdf
hi
```

在本挑战中，你必须使用此输出重定向将单词 `PWN`（全大写）写入文件名 `COLLEGE`（全大写）。

### 重定向更多输出

除了重定向 `echo` 命令的输出外，你当然也可以重定向任何命令的输出。
在本关卡中，`/challenge/run` 将再次为你提供一个 flag，但*仅限*于你将它的输出重定向到文件 `myflag` 时。
你的 flag 最终当然会出现在 `myflag` 文件中！

你会注意到，即使你已经重定向了标准输出，`/challenge/run` 仍然会愉快地在你的终端上打印信息。
这是因为它通过*标准错误*来传递其指令和反馈信息，而*仅*通过*标准输出*打印 flag！

### 追加输出

输出重定向的一个常见用途是将某些命令结果保存下来以供后续分析。
很多时候，你需要以*聚合*的方式完成此操作：运行一系列命令，保存它们的输出，然后稍后使用 `grep` 进行筛选。
在这种情况下，你可能希望所有输出都能持续追加到同一个文件中，但使用 `>` 每次都会创建一个新的输出文件，并删除旧内容。

你可以使用 `>>` 而非 `>` 以*追加*模式重定向输出，如下所示：

```console
hacker@dojo:~$ echo pwn > outfile
hacker@dojo:~$ echo college >> outfile
hacker@dojo:~$ cat outfile
pwn
college
hacker@dojo:$
```

作为练习，请运行 `/challenge/run` 并将其输出以追加模式重定向到文件 `/home/hacker/the-flag`。
该练习会将 flag 的前半部分写入文件，如果标准输出被重定向到该文件，则会将后半部分写入标准输出。
如果你正确使用追加模式进行重定向，后半部分内容将追加到前半部分之后；但如果你使用*截断*模式（`>`）进行重定向，后半部分将*覆盖*前半部分，导致你无法获得完整 flag！

现在开始尝试吧！

### 重定向错误

正如可以重定向标准输出一样，你也可以重定向命令的错误通道。
这里，我们将学习*文件描述符编号*。
文件描述符（FD）是一个在 Linux 中*描述*通信通道的数字。
即使你之前没有意识到，其实你已经在使用它们了。
我们已经熟悉了三个：

- FD 0：*标准输入*
- FD 1：*标准输出*
- FD 2：*标准错误*

当你重定向进程通信时，是通过 FD 编号来操作的，尽管某些 FD 编号是隐含的。
例如，没有数字的 `>` 隐含了 `1>`，即重定向 FD 1（标准输出）。
因此，以下两个命令是等效的：

```console
hacker@dojo:~$ echo hi > asdf
hacker@dojo:~$ echo hi 1> asdf
```

从这一点出发，重定向错误就相当简单了。
如果你有一个可能通过标准错误产生数据的命令（例如 `/challenge/run`），你可以这样做：

```console
hacker@dojo:~$ /challenge/run 2> errors.log
```

这将把标准错误（FD 2）重定向到 `errors.log` 文件。
此外，你可以同时重定向多个文件描述符！
例如：

```console
hacker@dojo:~$ some_command > output.log 2> errors.log
```

该命令会将输出重定向到 `output.log`，将错误重定向到 `errors.log`。

让我们将其付诸实践！
在本挑战中，你需要像之前一样，将 `/challenge/run` 的输出重定向到 `myflag`，并将其“错误”（在我们的例子中是指令）重定向到 `instructions`。
你会注意到终端上不会打印任何内容，因为你已经重定向了所有输出！
当你成功完成此操作后，可以在 `instructions` 文件中找到指令/反馈，在 `myflag` 文件中找到 flag！

### 重定向输入

正如你可以重定向程序的*输出*一样，你也可以重定向输入*到*程序！
这可以通过使用 `<` 来实现，如下所示：

```sh
hacker@dojo:~$ echo yo > message
hacker@dojo:~$ cat message
yo
hacker@dojo:~$ rev < message
oy
```

通过使用输入重定向，你可以用许多不同的程序来完成有趣的事情！
在本关卡中，我们将练习使用 `/challenge/run`，这需要你将 `PWN` 文件重定向给它，并且要求 `PWN` 文件包含值 `COLLEGE`！
要将该值写入 `PWN` 文件，请回想一下之前关于使用 `echo` 进行输出重定向的挑战！

### grep 存储结果

你已了解如何运行命令、如何重定向其输出（例如使用 `>`）以及如何搜索结果文件（例如使用 `grep`）。
现在让我们将这些技能结合起来运用！

为应对更复杂的关卡，我们希望你能完成以下操作：

1.  将 `/challenge/run` 的输出重定向到 `/tmp/data.txt`。
2.  这将导致在 `/tmp/data.txt` 中生成十万行文本，其中一行包含 flag。
3.  使用 `grep` 在该文件中搜索 flag！

grep 的参数 `-A NUM, --after-context=NUM`  
在匹配行后打印 NUM 行的后续上下文。

### 使用管道符 grep 实时输出

事实证明，你可以"省去中间步骤"，无需像上一关卡那样将结果存储到文件中。
这可以通过使用 `|`（管道）运算符来实现。
管道左侧命令的*标准输出*将会被连接到（*管道传输到*）管道右侧命令的*标准输入*。
例如：

```sh
hacker@dojo:~$ echo no-no | grep yes
hacker@dojo:~$ echo yes-yes | grep yes
yes-yes
hacker@dojo:~$ echo yes-yes | grep no
hacker@dojo:~$ echo no-no | grep no
no-no
```

现在亲自尝试一下吧！`/challenge/run` 将会输出十万行文本，其中包含 flag。
使用 `grep` 来搜索这个 flag！

### grep 错误

你已了解如何将错误重定向到文件，也了解如何将输出通过管道传递给另一个程序（例如 `grep`）。
但如果你想直接对错误流进行 `grep` 筛选呢？

`>` 操作符将给定的文件描述符重定向到文件，你已使用过 `2>` 来重定向 fd 2（即标准错误）。
`|` 操作符则*仅*将*标准输出*重定向到另一个程序，并且该操作符没有 `2|` 这种形式！它*只能*重定向标准输出（文件描述符 1）。

幸运的是，只要有 shell，就有办法！
shell 提供了一个 `>&` 操作符，它可以将一个文件描述符重定向*到另一个文件描述符*。
这意味着我们可以通过一个两步过程来对错误流进行 `grep` 筛选：首先，我们将标准错误重定向到标准输出（`2>&1`），然后像往常一样将现在已合并的标准错误和标准输出通过管道传输（`|`）！

现在就尝试一下吧！
与上一关卡类似，本关卡会产生大量输出令你应接不暇，但这次输出是在标准错误上。
使用 `grep` 对其进行筛选以找到 flag！

### 使用 grep -v 过滤

`grep` 命令有一个非常实用的选项：`-v`（反向匹配）。
普通的 `grep` 显示*匹配*某个模式的行，而 `grep -v` 则显示*不匹配*该模式的行：

```console
hacker@dojo:~$ cat data.txt
hello hackers!
hello world!
hacker@dojo:~$ cat data.txt | grep -v world
hello hackers!
hacker@dojo:~$
```

有时，要筛选出你真正需要的数据，唯一的方法就是把你*不*想要的数据过滤*掉*。
在本挑战中，`/challenge/run` 会将 flag 输出到标准输出，但同时也会输出超过 1000 个诱饵 flag（这些诱饵 flag 的某处包含单词 `DECOY`），与真实的 flag 混合在一起。
你需要过滤*掉*所有包含 "DECOY" 的行，同时保留真实的 flag！
使用 `grep -v` 来过滤掉所有包含 "DECOY" 的行，从而揭示出真正的 flag！

### 使用 sed 过滤

`grep` 并非模式匹配的唯一方式。有时真实数据与无效数据会混合在同一行中，
而我们需要过滤掉这些无效数据。为此，我们可以使用 `sed`。`sed` 提供了一种简单的方法来将文本中的模式
替换为不同的词语。其匹配和替换的语法很简单：

```sh
sed "s/oldword/newword/g"
```

`s/` - 替换（substitute）  
`旧词语` - 需要被替换的词语  
`新词语` - 替换 `旧词语` 的内容  
`/g` - 全局（搜索并替换所有匹配的模式）  

在本挑战中，`/challenge/run` 会打印出 flag，但在每个字符之间都会插入字符串
"FAKEFLAG"。你的任务是过滤掉 flag 中的无效数据。祝你好运！

### 使用 tee 复制管道数据

当你将数据从一个命令通过管道传输到另一个命令时，数据自然不再显示在屏幕上。
但这并不总是符合预期：例如，你可能希望在数据流经各个命令之间时能够查看它，以便调试意外结果（例如，"为什么第二个命令没有工作？？？"）。

幸运的是，有一个解决方案！
`tee` 命令，其名称源于*管道工程*中使用的"T型分流器"，它会复制流经管道的数据，并将其写入命令行中提供的任意数量的文件。
例如：

```console
hacker@dojo:~$ echo hi | tee pwn college
hi
hacker@dojo:~$ cat pwn
hi
hacker@dojo:~$ cat college
hi
hacker@dojo:~$
```

如你所见，通过向 `tee` 提供两个文件，我们最终得到了管道传入数据的三个副本：一份到标准输出，一份到 `pwn` 文件，一份到 `college` 文件。
你可以想象如何利用这一点来调试出现混乱的情况：

```console
hacker@dojo:~$ command_1 | command_2
Command 2 failed!
hacker@dojo:~$ command_1 | tee cmd1_output | command_2
Command 2 failed!
hacker@dojo:~$ cat cmd1_output
Command 1 failed: must pass --succeed!
hacker@dojo:~$ command_1 --succeed | command_2
Commands succeeded!
```

现在，轮到你来尝试了！
此进程的 `/challenge/pwn` 必须通过管道传输到 `/challenge/college`，但你需要拦截数据以查看 `pwn` 需要你提供什么！

### 进程替换用于输入

有时你需要比较两个命令的输出，而不是两个文件。
你可能会想到先将每个输出保存到文件中：

```console
hacker@dojo:~$ command1 > file1
hacker@dojo:~$ command2 > file2
hacker@dojo:~$ diff file1 file2
```

但有一种更优雅的方式！Linux 遵循 ["everything is a file"](https://en.wikipedia.org/wiki/Everything_is_a_file) 的哲学。
也就是说，系统努力为大多数资源提供类似文件的访问方式，包括正在运行程序的输入和输出！
shell 遵循这一哲学，例如，允许你使用任何在命令行上接受文件参数的工具，并将其连接到程序的输出，正如你在前几个关卡中学到的那样。

有趣的是，我们可以更进一步，将程序的输入和输出连接到命令的*参数*。
这是通过使用[进程替换](https://www.gnu.org/software/bash/manual/html_node/Process-Substitution.html)来完成的。
对于从命令读取（输入进程替换），使用 `<(command)`。
当你写入 `<(command)` 时，bash 将运行该命令并将其输出连接到一个它将创建的临时文件。
这当然不是一个*真正的*文件，它被称为*命名管道*，因为它有一个文件名：

```console
hacker@dojo:~$ echo <(echo hi)
/dev/fd/63
hacker@dojo:~$
```

`/dev/fd/63` 是从哪里来的？
`bash` 用连接到命令输出的命名管道文件的路径替换了 `<(echo hi)`！
当命令正在运行时，从该文件读取数据将读取该命令标准输出的数据。
通常，这是通过使用接受输入文件作为参数的命令来完成的：

```console
hacker@dojo:~$ cat <(echo hi)
hi
hacker@dojo:~$
```

当然，你可以多次指定这个：

```console
hacker@dojo:~$ echo <(echo pwn) <(echo college)
/dev/fd/63 /dev/fd/64
hacker@dojo:~$ cat <(echo pwn) <(echo college)
pwn
college
hacker@dojo:~$
```

现在轮到你的挑战了！
请回想你在命令行小节中的 `diff` 挑战里学到的知识。
在那个挑战中，你比较了 (`diff`) 了两个文件。
现在，你将比较两组命令的输出：`/challenge/print_decoys`（将打印一堆诱饵 flag）和 `/challenge/print_decoys_and_flag`（将打印相同的诱饵 flag 加上真实的 flag）。
使用进程替换配合 `diff` 来比较这两个程序的输出，从而找到你的 flag！

### 向多个程序写入

现在你已经了解到，进程替换可以让命令输出以文件形式出现，通过 `<(command)` 进行读取。但你也*可以*使用进程替换来*向命令写入*数据！

你可以使用 `tee` 将数据复制到两个文件中：

```console
hacker@dojo:~$ echo HACK | tee THE > PLANET
hacker@dojo:~$ cat THE
HACK
hacker@dojo:~$ cat PLANET
HACK
hacker@dojo:~$
```

并且你用过 `tee` 将数据复制到文件和一个命令：

```console
hacker@dojo:~$ echo HACK | tee THE | cat
HACK
hacker@dojo:~$ cat THE
HACK
hacker@dojo:~$
```

但如何复制到两个命令呢？正如 `tee` 在其手册页中所说，它设计用于写入文件和标准输出：

```text
tee(1)                   用户命令                   tee(1)

名称
       tee - 从标准输入读取并写入标准输出和文件
```

但是等等！你刚刚学到 bash 可以使用进程替换让命令看起来像文件！要向命令写入（输出进程替换），请使用 `>(command)`。如果你写入一个 `>(rev)` 参数，bash 将运行 `rev` 命令（该命令从标准输入读取数据，反转其顺序，然后写入标准输出！），但将其输入连接到一个临时命名管道文件。当命令写入此文件时，数据会传送到命令的标准输入：

```console
hacker@dojo:~$ echo HACK | rev
KCAH
hacker@dojo:~$ echo HACK | tee >(rev)
HACK
KCAH
```

以上发生了以下事件序列：

1.  `bash` 启动了 `rev` 命令，将一个命名管道（可能是 `/dev/fd/63`）连接到 `rev` 的标准输入
2.  `bash` 启动了 `tee` 命令，将一个管道连接到其标准输入，并将 `tee` 的第一个参数替换为 `/dev/fd/63`。`tee` 甚至从未看到参数 `>(rev)`；shell 在启动 `tee` 之前*替换*了它
3.  `bash` 使用 `echo` 内置命令将 `hack` 打印到 `tee` 的标准输入
4.  `tee` 读取 `hack`，将其写入标准输出，然后将其写入 `/dev/fd/63`（该文件连接到 `rev` 的 stdin）
5.  `rev` 从其标准输入读取 `hack`，反转它，并将 `kcah` 写入标准输出

现在轮到你了！在这个挑战中，我们有 `/challenge/hack`、`/challenge/the` 和 `/challenge/planet`。运行 `/challenge/hack` 命令，并将其输出复制为输入，同时传递给 `/challenge/the` 和 `/challenge/planet` 命令！如果需要复习此方法，请滚动回顾之前的挑战“使用 tee 复制管道数据”和“用于输入的进程替换”。

----

**小知识！**

细心的学习者会意识到以下是等价的：

```console
hacker@dojo:~$ echo hi | rev
ih
hacker@dojo:~$ echo hi > >(rev)
ih
hacker@dojo:~$
```

有多种方式可以管道传输数据！当然，第二种方式更难阅读，也更难扩展。例如：

```console
hacker@dojo:~$ echo hi | rev | rev
hi
hacker@dojo:~$ echo hi > >(rev | rev)
hi
hacker@dojo:~$
```

那只是愚蠢的！这里的教训是，虽然进程替换是你工具箱中的一个强大工具，但它是一个非常*专用*的工具；不要在所有地方都使用它！


### 分离管道 stderr 和 stdout

现在，让我们整合你的知识。
你必须掌握终极管道任务：将标准输出重定向到一个程序，将标准错误重定向到另一个程序。

这里的挑战当然是 `|` 操作符将左侧命令的*标准输出*与右侧命令的*标准输入*链接起来。当然，你用过 `2>&1` 将标准错误重定向到标准输出，从而通过管道传输标准错误，但这会将标准错误和标准输出混合在一起。如何保持它们不混合呢？

你将需要结合你关于 `>()`、`2>` 和 `|` 的知识。具体如何操作，这个任务我将留给你。

在这个挑战中，你有：

-   `/challenge/hack`：这个命令会在*标准输出*和*标准错误*上产生数据
-   `/challenge/the`：你必须将 `hack` 的*标准错误*重定向到这个程序
-   `/challenge/planet`：你必须将 `hack` 的*标准输出*重定向到这个程序

去获取 flag 吧！

----
**附加题：** 为了增加一点难度，请找到一个不使用 `|` 的解决方案。

正如之前的示例，标准错误与标准输出可同时分离。  
也可重定向到其他文件描述符，或命名管道后再重定向。

### 命名管道

你已经了解了使用 `|` 的管道，并且看到进程替换会创建临时的命名管道（如 `/dev/fd/63`）。
你*也*可以创建你自己的*持久化*命名管道，它们会保留在文件系统中！
这些被称为 **FIFO**，代表先进先出。

你可以使用 `mkfifo` 命令创建一个 FIFO：

```console
hacker@dojo:~$ mkfifo my_pipe
hacker@dojo:~$ ls -l my_pipe
prw-r--r-- 1 hacker hacker 0 Jan 1 12:00 my_pipe
hacker@dojo:~$ ls -l some_file
-rw-r--r-- 1 hacker hacker 0 Jan 1 12:00 some_file
hacker@dojo:~$
```

注意权限字符串开头的 `p` - 这表明它是一个管道！
这与普通文件（如上面例子中的 `some_file`）开头的 `-` 明显不同。

与进程替换生成的自动命名管道不同：

-   你可以控制 FIFO 的创建位置
-   它们会一直存在，直到你删除它们
-   任何进程都可以通过路径向它们写入（例如，`echo hi > my_pipe`）
-   你可以用 `ls` 看到它们，并像文件一样检查它们

FIFO 的一个问题是，在管道的读取端和写入端都准备好之前，对它们的任何操作都会“*阻塞*”。
例如，考虑以下情况：

```console
hacker@dojo:~$ mkfifo myfifo
hacker@dojo:~$ echo pwn > myfifo
```

为了执行 `echo pwn > myfifo`，bash 会以写入模式打开 `myfifo` 文件。
然而，这个操作将会挂起，直到有东西*也*以读取模式打开该文件（从而完成管道连接）。
这可以在另一个控制台中完成：

```console
hacker@dojo:~$ cat myfifo
pwn
hacker@dojo:~$
```

这里发生了什么？
当我们运行 `cat myfifo` 时，管道的两端连接都已建立并*解除阻塞*，允许 `echo pwn > myfifo` 运行，它将 `pwn` 发送到管道中，然后被 `cat` 读取。

当然，普通文件某种程度上也能做到这一点：你已经学会了如何将内容 `echo` 到文件中并用 `cat` 读取出来。
那为什么要使用 FIFO 呢？
以下是关键区别：

1.  **无磁盘存储：** FIFO 直接在进程间内存中传递数据 - 不会保存到磁盘
2.  **临时数据：** 数据一旦从 FIFO 中读取，就消失了（不像文件，数据会持久保存）
3.  **自动同步：** 写入者会阻塞直到读取者准备好，反之亦然。这实际上很有用！它提供了自动同步。考虑上面的例子：使用 FIFO，先执行 `cat myfifo` 还是先执行 `echo pwn > myfifo` 并不重要；每个操作都会等待另一个操作。对于文件，你需要确保在读取者之前执行写入者。
4.  **复杂数据流：** FIFO 有助于实现复杂的数据流，以灵活的方式合并和分割数据等。例如，FIFO 支持多个读取者和写入者。

这个挑战将是对 FIFO 的一个简单介绍。
你需要创建一个 `/tmp/flag_fifo` 文件，并将 `/challenge/run` 的标准输出重定向到它。
如果你成功了，`/challenge/run` 会将 flag 写入 FIFO！
开始行动吧！

----
**提示：**
FIFO 的*阻塞*行为使得在单个终端中解决这个挑战很困难。
你可能需要为此挑战使用桌面或 VSCode 模式，以便可以启动两个终端。
