# SQL Playground

## Challenge

现代社会运行于互联网之上，而互联网运行于数据库之上。数据库存储着海量数据，从您的 pwn.college 成绩（是的，我们有一个数据库！）到整个维基百科，再到不那么重要的信息如您的信用评分。只要能够被描述的事物，几乎都存在于某个数据库中。

数据库形态各异，但最常见（且无疑最*传统*的）类型将数据条目存储在结构化表中。这些结构化表可通过一种名为结构化查询语言（即 `sql`，通常读作"sequel"）的专用语言进行查询。

sql 的（误）用会引发各种潜在安全问题，我们将在本平台后续内容中探讨。本模块将通过一系列挑战教你（或者说，迫使你学习）sql，让你接触该语言中后续将涉及的相关部分。欢迎来到 sql 练习场。

### SQL 查询

本挑战将是您 SQL 旅程的起点。在此挑战以及整个模块中，我们将使用一个名为 [SQLite](https://sqlite.org/) 的 SQL 引擎。SQLite 是一个极其轻量级的 SQL 引擎，它不使用复杂的 SQL 服务器进程来托管数据库，而是直接与数据库文件交互。这使得它非常便于进行应用程序原型开发，我们在 pwn.college 的挑战中几乎所有的 SQL 需求都使用它，但您不会想将其用于，例如，生产环境网站……

在挑战文件 (`/challenge/sql`) 中，您会注意到我们通过 `TemporaryDb` 类使用 SQLite。请忽略该类的内部工作原理——我们仅将其用作执行 SQL 查询和获取结果的包装器。请关注代码的其余部分！

本挑战将从一個非常简单的查询开始。我们将学习的查询是 `SELECT`。您可以使用 `SELECT` 来 (😎) *选择* 数据库表中的数据。其基本语法是 `SELECT what FROM where`，其中 `what` 和 `where` 是您指定的内容。`WHERE` 子句（在此上下文中指 `FROM` 后面的部分）通常是一个数据库表，而 `what` 则是您希望查询获取的列。如果您不想关心要 `SELECT` 哪一列，您可以执行 `SELECT *`！

阅读代码以了解您正在查询的数据库布局，并选择出 flag！

----
**注意：** 本挑战以及本系列中的其他挑战将尝试链接到相关的 SQLite 文档。这些文档可能相当枯燥和密集。也请随意使用其他资源。互联网上有许多 SQL 指南：我们制作本指南的唯一原因是为学习者提供 pwn.college 挑战所需 SQL 部分的加速指南！

### 过滤 SQL

任何非平凡的数据库都会包含足够多的数据，因此必须对访问内容保持*选择性* (🥁)。幸运的是，`SELECT` 查询可以使用 `WHERE` 子句进行过滤！本挑战将要求您过滤数据，因为现在数据库中有很多垃圾数据！

本挑战链接到 SQLite 关于 WHERE 子句的文档，我们希望您去阅读一下。简而言之，为了帮助您入门，您可以在查询后附加 `WHERE condition`，其中 `condition` 是您指定的某个表达式，例如 `some_column < 10`（用于整数比较）或 `some_column = 'pwn'`（用于字符串比较）等。

您需要分析代码以理解标志数据与垃圾数据的区别所在，然后据此进行查询！
提示：区别在于我们新添加的列。
您能设置正确的过滤器，将数据过滤到只剩下 flag 吗？

### 选择列

您可能因为我们在前几个挑战中的潜意识建议而一直使用 `SELECT *`。本挑战将强制您选择单个列。请按列名进行 `SELECT` 并获取 flag！

### 排除性过滤

在这里，我们将随机标记 flag。您还能将其过滤出来吗？
- 不等于：
    - `1 <> 2`
    - `1 != 2`

----
**提示：**
在过滤器中*排除*垃圾数据可能比包含 flag 数据更容易。

### 字符串过滤

当然，您也可以使用字符串值进行过滤。在这里，flag 标记是一个字符串。您还能获取到 flag 吗？

### 基于表达式的过滤

让我们继续学习更高级的过滤。在这个挑战中，我们去掉了 flag 标记，您需要根据 flag 数据的实际值进行过滤！幸运的是，`SQLite`（以及所有 SQL 引擎）提供了一些用于处理字符串的函数，您将在这里使用 `substr` 函数。`substr(some_column, start, length)` 会从 `some_column` 列的第 `start` 个字符开始（第一个字符的位置是 `1`，而不是像更合理的语言那样是 `0`）提取 `length` 个字符。您可以在查询接受表达式的任何地方使用此函数的结果，例如在 `WHERE` 子句中，将结果值与字符串进行比较，就像在前一个挑战中那样！

### SELECT 表达式

像 `substr` 这样的功能不仅仅用于过滤：您还可以 `SELECT` 此类表达式（代替或补充您通常指定列的位置）！当您不想（或者，如本挑战的情况，无法检索）*所有*数据，而只想要对数据执行某些计算的结果时，这非常方便。在这种情况下，挑战将不允许您读取整个 flag。您能分段读取它吗？

### 复合条件

到目前为止，我们的 `WHERE` 条件一直非常简单。本挑战通过向您的数据库注入诱饵数据，使情况变得稍微复杂一些。幸运的是，flag 标记又回来了。
您需要根据*flag 标记和 flag 值两者*进行过滤。与其他编程语言类似，您可以使用布尔运算符（如 `AND` 和 `OR`）将条件表达式连接起来。请构建一个强大的表达式，从诱饵中过滤出 flag！

### 达到您的 LIMIT

您一直能够依赖 `WHERE` 子句将结果过滤到只剩一个，但在本挑战中，我们拿掉了您用来过滤诱饵 flag 的 flag 标记！幸运的是，简单的 SQL 查询倾向于按照数据插入数据库的顺序返回数据，而真正的 flag 是在诱饵 flag 之前（但在某些垃圾数据之后）插入的。您只需要将查询结果 `LIMIT` 为仅 `1` 条，该结果就应该是您的 flag！如有需要，本挑战为您链接了 `LIMIT` 文档！

### 查询元数据

在实际的安全场景中，攻击者有时会缺乏某些信息，例如他们想要查询的表的名称！幸运的是，每个 SQL 引擎都有某种查询表*元数据*的方式（尽管令人困惑的是，每个引擎的做法都不同！）。SQLite 使用一个特殊的 `sqlite_master` 表来存储所有其他表的信息。您能找出包含 flag 的表的名称并查询它吗？
