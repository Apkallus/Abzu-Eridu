# Talking Web

HTTP（超文本传输协议）是开放互联网的通用语言：Web应用程序、服务器和客户端通过这一共同语言进行通信。本模块深入探讨构建、解码和操纵HTTP请求与响应的复杂技能。完成这段学习后，你将不再仅依赖网页浏览器代为发起HTTP请求，而是掌握直接与Web服务器对话的能力，开启新的可能性世界。

你将学习以下内容：
- **头部**：携带请求或响应关键信息的元数据字段
- **路径**：要访问的特定位置或资源
- **参数**：可改变或控制请求行为的数据点
- **表单数据**：从Web表单传输的数据
- **JSON**：一种轻量级且人类可读的流行数据交换格式
- **Cookie**：存储在用户计算机上的小型数据片段，对会话管理和跟踪至关重要
- **重定向**：Web服务用来将浏览器从一个位置引导至另一个位置的方法

当你攻克这些挑战时，不会盲目操作：

```sh
hacker@talking-web-level-1:~$ /challenge/run
* Serving Flask app 'run'
* Debug mode: off
WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead.
* Running on http://challenge.localhost:80
Press CTRL+C to quit
```

通过挑战提供的输出会将你引导至Web服务器活动的核心。切勿忽略它：服务器的响应通常是提示，在方向不明时为你指引正确路径。

### 文档

<https://requests.readthedocs.io/en/latest/>
Python requests 库的全面指南。

## 挑战

### 你的第一个 HTTP 请求

显然，既然你正在通过网页浏览器访问本网站，这并非你的 *第一个* HTTP 请求。但这是你为完成 pwn.college 挑战而发出的第一个 HTTP 请求！

运行 `/challenge/server`，在 dojo 工作区中启动 Firefox（为此你需要使用 [图形桌面](/workspace/desktop)），然后访问它正在监听的 URL 以获取 flag！

### 阅读 Flask

太棒了，你已经掌握了基本流程。不过，还有一件事你需要完成：你必须阅读并理解挑战的源代码！

Web 服务器将 HTTP 请求 *路由* 到不同的 *端点*：`http://challenge.localhost/pwn` 的请求可能会被发送到处理路径 `/pwn` 的端点，而 `http://challenge.localhost/college` 的请求可能会被发送到处理路径 `/college` 的端点。

本挑战有一个随机选择的端点名称。你必须阅读 `/challenge/server` 中的代码，理解它，并找出在浏览器中要访问哪个端点！

----
感到困惑？我们的 Web 服务器是使用 [Flask](https://flask.palletsprojects.com/en/stable/quickstart/) 库实现的。请阅读其文档以逐步理解代码，或者动手实验一下！

### 带注释的数据

HTTP 是 *超文本* 传输协议。
“超文本”这个名称源于 20 世纪末的技术乐观主义，它指的是不仅包含文本含义、还携带关于应*如何*理解这些文本的附加数据的文本。
在现代，这是通过各种方式实现的：HTTP 被用来传输许多不同类型的资源，而你的网页浏览器则将这些资源组合起来，构建出你所看到并与之交互的网站。
其中最古老的方式就是超文本标记语言，即 HTML。

HTML 以一种浏览器能够解释的方式，描述了（初始状态下）应在网页上显示的元素。
我们将在后续模块中深入探讨 HTML 的微妙之处，但在这里，我们将练习揭开网站的面纱，查看其背后的 HTML。
和之前一样，你需要找到端点并在 dojo 内的浏览器中访问它。
但是，发送过来的 HTML 会*隐藏* flag。
你需要弄清楚如何查看 HTML 的页面源代码，而不是渲染后的结果，以获取这些隐藏的数据。

----
**提示：** 点击 Firefox 的“汉堡包”菜单（≡），然后转到 `更多工具`。

### HTTP 元数据

HTTP 既促进 *数据*（例如，`/challenge/server` 发送给你的 HTML）的传输，也促进 *元数据*（关于数据的数据）的传输。
后者通过 *头信息* 发送：这些是 HTTP 请求或响应中的字段，用于向服务器或浏览器提供附加指令。
在本挑战中，flag 位于一个头信息中。
你能找到它吗？

----
**提示：** 你可以使用 Firefox 的 Web 开发者工具（≡，然后选择 `更多工具`）来检查头信息。
工具的“网络”标签页会显示所有的 HTTP 连接（你可能需要在打开 Web 开发者工具后重新加载页面，连接信息才会显示出来）。
这些连接中的每一个都有一个 `头信息` 子标签页，其中显示你的浏览器随请求发送的头信息（`请求头`）以及随响应接收到的头信息（`响应头`）。
在那里找到包含 flag 的头信息！

### HTTP (netcat)

你已经学会了如何进行 HTTP 通信（当然，你可能一生中大部分时间都在进行 HTTP 通信！）。
现在，让我们学习如何*真正地*进行 HTTP 通信。
HTTP 协议本身，即在网络上传输的确切数据，实际上出人意料地易于人类阅读和编写。
在本挑战中，你将学习编写它。
此挑战要求你使用一个名为 "netcat"（命令名：`nc`）的程序，它是一个通过网络连接进行通信的简单程序。
Netcat 的基本用法涉及两个参数：*主机名*（服务器监听的位置，例如 Google 的 www.google.com）和端口（标准的 HTTP 端口是 80）。

当 netcat 启动时，它会连接到服务器，并为你提供一个与之通信的原始通道。
你将*直接与 Web 服务器对话*，没有中间环节！
这有多酷？

回顾讲座内容，找到 HTTP 请求的格式，并向 `/` 端点（我们稍后会处理更多端点）发出一个 GET 请求来获取 flag！

----
**提示：**
无法判断 netcat 是否连接成功？
使用 `-v` 标志来开启一些详细输出！

**提示：**
输入了你的 GET 请求，但按 Enter 键后没有任何反应？
HTTP 请求以*两个*换行符终止。
尝试再按一次 Enter 键！

**一点思考...**
直到此刻，你是否曾真正地进行过 HTTP 通信？

### HTTP 路径 (netcat)

好的，你已经掌握了 netcat 的基础知识。
现在，向一个特定的路径发出 GET 请求！
和往常一样，查看 `/challenge/server` 代码以了解更多信息。

### HTTP (curl)

接下来，我们将练习使用最常用的 HTTP 命令行工具之一：`curl` 来发起 HTTP 请求。
与 netcat 不同，curl 是专门为 HTTP 设计的，你无需编写原始的 HTTP 命令。
相反，你必须学会使用正确的程序选项来实现你的目标。
在这里，你只需向正确的端点发出一个 GET 请求即可！

### HTTP (python)

最后，我们将学习 HTTP 工具包中的第四个工具：Python 的 [requests 库](https://requests.readthedocs.io/en/latest/)。
这个工具，连同浏览器，很可能成为你的 HTTP 工具包中使用最频繁的两个工具。
Requests 库允许你编写脚本实现复杂的网络交互，这对于后续执行复杂的黑客技术是必要的。
目前，事情很简单：打开 Python，`import requests`，然后 GET 获取 flag！

### HTTP Host 头 (python)

不幸的是，现代互联网的大部分运行在少数几家公司的基础设施上，这些公司运营的一台服务器可能负责为几十个不同的域名提供网站服务。
服务器如何决定提供哪个网站呢？
答案就是 `Host` 头。

`Host` 头是一个由客户端（例如浏览器、curl 等）发送的*请求*头，其值通常等于 HTTP 请求中输入的主机名。
当你访问 `https://pwn.college` 时，你的浏览器会自动将 `Host` 头设置为 `pwn.college`，这样我们的服务器就知道应该提供 `pwn.college` 的网站，而不是其他内容。

到目前为止，你一直在交互的挑战都是不区分 `Host` 头的。
但现在它们开始检查了。
设置正确的 `Host` 头并获取 flag！

### HTTP Host 头 (curl)

现在，我们来学习如何在 curl 中设置 Host 头！
阅读其 `man` 手册页，了解如何设置请求头。

### HTTP Host 头 (netcat)

最后，你可以学习在 netcat 中 Host 头是如何*真正*通过网络发送的。
这可能会有点棘手。
实际上，你可以把 `curl` 当作一个信息来源！
Curl 的 `-v` 选项会使其打印出它发送（以及接收）的确切头信息。
观察它，用 netcat 模仿这些头信息，然后获取 flag！

### URL 编码 (netcat)

还记得 HTTP 请求是如何包含由空格分隔的字段吗？
例如：`GET /solve HTTP/1.1`。
如果路径（例如，不是 `/solve`）内部包含空格会怎样？
这是很可能会发生的情况，因为这些路径通常引用目录，而目录名中可能包含空格！

如果放任不管，空格会破坏 HTTP 请求的结构。
试想一个 HTTP 服务器试图解析 `GET /solve my challenge HTTP/1.1`。
一个聪明的服务器或许能够处理它，但一个只是逐词读取的简单版本很可能会把 `my` 误读为协议版本而引发混乱！

为了避免这种情况，URL 使用 [URL 编码](https://en.wikipedia.org/wiki/Percent-encoding) 进行*编码*。
与你之前在 数据处理(/fundamentals/data-dealings) 中见过的编码相比，这是一种简单的编码。
任何特殊字符（例如空格）都会被简单地进行十六进制编码，并在前面加上一个 `%`。
当然，因为 `%` 本身也因此变成了一个特殊字符，所以它也必须被编码。
在上面的例子中，`/solve my challenge` 会变成 `/solve%20my%20challenge`，因为 ASCII 空格字符的十六进制值是 `0x20`。

无论如何，现在我们来实践一下。
我们在端点中加入了空格。
你还能拿到 flag 吗？
- 若在请求行中未输入 HTTP 版本字段，此处服务器兼容旧版的 方法+路径 的请求行而不会报错。
    但仅返回body而不含头部。

----
**信息：**
你会发现，使用 curl 时也需要以完全相同的方式对 URL 进行编码（不过我们不会让你在这方面绕圈子）。
然而，Python 的 requests 库会自动为你进行 URL 编码。
真方便！

### HTTP GET 参数

与编程语言中的函数调用或 shell 中的命令执行类似，HTTP 请求可以包含*参数*。
GET 请求将参数与路径一起放在 URL 的 [查询字符串](https://en.wikipedia.org/wiki/Query_string) 部分发送。
在本挑战中，你将学习如何构造这个查询字符串。
阅读挑战源代码以了解你需要传递什么参数，然后将其发送出去！
你可以使用任何你想要的客户端：在所有客户端中，基本过程都是相同的。

----
**安全提示：**
很容易将 HTTP 参数类比为函数调用的参数。
但请记住：当你编写 C、Python 或 Java 代码时，攻击者（通常）不能随意使用随机参数调用你程序中的随机函数。
但对于 HTTP，他们*可以*。
他们可以随意向任何地方发起 HTTP 请求！
这已经导致了相当多的安全问题...

### 多个 HTTP 参数 (netcat)

当然，你可以传入多个参数；你只需要用 `&` 分隔它们：`what=pwn&where=college`。
现在就在 netcat 中尝试一下。

### 多个 HTTP 参数 (curl)

在 curl 中指定多个 HTTP 参数有点特殊，因为 `&` 在 shell 中有特殊含义（它会在后台启动命令），如果你不小心，shell 会被你的 `&` 干扰！
请务必将整个 URL（包括查询字符串）放在引号中以避免这种情况。
现在就来试试吧。

### HTTP 表单

HTTP GET 请求通常用于*获取*数据，其参数通常代表数据标识符以及用于其检索和显示的各种自定义项。
*存储*数据通常通过 HTTP *POST* 请求来完成。
在过去，POST 请求通常由人们填写并提交 HTML 表单产生。
这种情况现在依然存在，但也有许多其他产生 POST 请求的方式（其中一些我们将在后面介绍）。

现在，让我们来练习一下这个经典且有用的方法。
`http://challenge.localhost` 有一个表单供你填写。
在浏览器中填写并提交它以获取 flag！

### HTTP 表单 (curl)

现在，让我们用 curl 来尝试一下。
查看其手册页，弄清楚如何发出 POST 请求（提示：最相关的选项是 `-d`）。

----
**注意：**
还记得我们说过攻击者能够触发他们想要的任何 HTTP 请求吗？
请注意，这个挑战甚至没有任何生成表单的功能，但你仍然可以通过 POST 请求来访问它！

### HTTP 表单 (netcat)

现在，我们用 netcat 来尝试这个。
这要*困难得多*，并且由于历史原因显得有些过时。
查看 [Mozilla](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST) 提供的最简单的 URL 编码表单提交示例，并将其调整以适应你的用例。
- POST 表单时拥有请求体类型与长度的额外请求头

### HTTP 表单 (python)

现在让我们用 requests 库来试试！
查看文档以了解如何操作。

### 无表单的 HTTP 表单提交

现在，尝试让你的浏览器在没有网站提供表单的情况下执行 POST 请求。
提示：你能自己准备一个表单吗？

### 多表单字段 (curl)

让我们来练习处理多个表单字段！

### 多表单字段 (netcat)

……现在用 netcat 试试！

### HTTP 重定向 (netcat)

有时，网络上的资源会移动。
网站可能被重新设计，我们可能重命名 pwn.college 的某个模块，等等。
在这些（以及其他）情况下，Web 服务器可以*重定向*客户端到新的 URL。
这是通过一个特殊的 HTTP 请求完成的，你将在这里发现这一点。
你还能找到 flag 吗？

### HTTP 重定向 (curl)

现在，让我们试试 curl。
Curl 有一个非常有用的命令行选项，可以*自动*跟随重定向。
它就是 `-L`。
试试看，你会发现这变得多么简单！

### HTTP 重定向 (python)

现在轮到 Python 了。
Python 的 requests 库会*自动*跟随重定向，所以这应该*非常*简单。
尝试一下吧！

### HTTP Cookie (curl)

使用 curl 包含来自 HTTP 响应的 cookie

### HTTP Cookie (netcat)

使用 nc 包含来自 HTTP 响应的 cookie

### HTTP Cookie (python)

使用 python 包含来自 HTTP 响应的 cookie

---
**提示：** 如果你还没有使用它，请查看 `requests.Session`！

### 服务器状态 (python)

使用 python 响应有状态的 HTTP 响应并发出多个请求
- 即，此挑战为一系列有状态（cookie）的消息。无状态将导致无限重定向

### 监听网络

你一直在研究 Web 服务器代码，并学习如何与之通信。
现在，让我们学习如何*监听*。

在本关卡中，你将编写一个简单的服务器来接收获取 flag 的请求！
只需从（例如）第一个模块复制服务器代码，删除任何额外内容，然后构建一个将在端口 1337（而不是 80 —— 作为非管理员用户，你无法监听端口 80）和主机名 `localhost` 上监听的 Web 服务器。
当你准备好后，运行 `/challenge/client`，它将启动一个内部 Web 浏览器并访问 `http://localhost:1337/` 以获取 flag！

### 发起重定向

你已经跟随过重定向 —— 现在来让重定向发生吧！
让你的 Web 服务器将 `/challenge/client` 重定向到 `/challenge/server` 中的正确位置。
为此，你需要三个终端窗口：

1.  第一个终端窗口运行 `/challenge/server`，它在端口 80 上监听并准备提供 flag。
2.  第二个终端窗口运行你的 Web 服务器实现，它在端口 1337 上监听并准备重定向客户端。
3.  第三个终端窗口运行 `/challenge/client`。

这有点复杂，但你能做到的！

### JavaScript 重定向

在万维网初期，HTML 虽然是*超*文本，但相当静态。
它描述布局，仅此而已。
在 20 世纪 90 年代的某个时候，互联网的推动者和影响者们想到：“如果网页能够执行逻辑会怎样？”，于是 JavaScript 诞生了。

JavaScript 是一种编程语言，它允许网页动态地做出决策并执行操作。
毫无疑问（并且不幸的是，因为它很糟糕），它是目前最重要的编程语言（尽管幸运的是不是使用最广泛的），尽管我们可能尽力避免它（我们提到过它很糟糕吗？），但在任何关于网络安全的讨论中，我们都必须考虑到它。

HTML 通过 `<script>` 标签指定要执行的 JavaScript。
此标签告诉浏览器，该标签内的内容是 JavaScript，浏览器会执行它。
网上有很多关于如何编写 script 标签以及如何编写 JavaScript 的资源，我们将寻找这些资源作为您（学习者）的练习。
在这里，我们将练习一些非常具体的内容：使用 JavaScript 将浏览器重定向到不同的网页。

和之前一样，客户端浏览器会打印出它接收到的页面，但它会从访问 `http://challenge.localhost/~hacker/solve.html` 开始。
这里，我们回溯到共享服务器的旧时代：`http://challenge.localhost/~hacker/anything` 将从您主目录的 `public_html` 子目录中提供！
请创建 `/home/hacker/public_html/solve.html` 文件，编写重定向浏览器所需的 JavaScript，然后获取 flag！

----
**提示：**
您需要的 JavaScript 对象是 `window.location`。
您可以为其分配一个字符串，从而将浏览器重定向到新位置。

**提示：**
使用内置浏览器调试可能会比较棘手。
可以尝试使用 dojo 的 Firefox 浏览器！
虽然您无法用它获取最终的 flag，但至少可以判断您的重定向是否有效！

### 包含 JavaScript

JavaScript 在网页上下文中可以执行许多操作，因此可能导致意外情况和安全漏洞。你将在 Web 安全模块中探索其中一些情况，但我们将在此奠定基础。

在本关卡中，`/challenge/client` 将不再打印网页，而 `/challenge/server` 也不会提供包含 Flag 的 HTML 页面，而是提供一个将全局 `flag` 变量设置为 Flag 值的 JavaScript 脚本。你需要创建一个网页来*包含*此脚本（具体实现方式请自行查阅文档 —— 提示：涉及 `src` 属性），然后创建另一个脚本来以某种方式*渗出*这些信息。渗出是指在数据所有者（本例中为 `/challenge/client` 和 `/challenge/server`）的眼皮底下悄悄将敏感数据传出的技术。当然，在你的页面上运行的 JavaScript 可以访问 `flag` 变量，但你需要以某种方式将其传递到外部。这可以通过几种不同的方式实现，但最简单的方法可能是将客户端浏览器重定向（使用之前用过的 `window.location` 技巧！）到一个包含 Flag 的 URL（类似于几关前客户端将其泄漏给你的方式），并让该请求发送到你可以查看 URL 日志的位置（例如 `/challenge/server` 的日志或你自己的 Web 服务器！）。

这听起来很复杂，但完全可行。我们的参考 HTML 解决方案文件仅 150 字节！和之前一样，请记住：你可以使用自己的浏览器调试解决方案（并且可以在实践模式下以 root 权限运行以包含 Flag 脚本！）。


### HTTP (JavaScript)  

现在，困难的部分开始了……通常你需要渗出的是 JavaScript 在网站上可访问的其他数据，但往往需要通过 HTTP 请求来获取这些数据。在现代 JavaScript 中，HTTP 请求使用 `fetch()` 函数实现。其基本用法如下：

```javascript
fetch("http://google.com").then(response => response.text()).then(website_content => ???);
```

当然，`???` 部分是你想在网站内容上执行的代码。这个 API 看起来非常复杂，一方面是因为 JavaScript 本身的设计特点，另一方面是因为它需要解决一个难题：它必须在网络错误、CPU 负载、笔记本电脑休眠与唤醒、防火墙等可能干扰资源加载和运行的复杂环境中执行逻辑。

上述代码使用了 JavaScript 的 "Promise"，这是一种复杂的编程模式，允许你为*尚未*可用的数据编写*将要*执行的逻辑。`.then()` 是 Promise 的一部分，用于指定最终要执行的代码。流程大致如下：

1. `fetch()` 返回一个 Promise 并开始获取 `http://google.com`。这可能需要一段时间，可能永远不会成功，也可能立即成功。无论如何，它最初返回一个 `promise` 对象，该对象具有一个 `then()` 成员函数，会在响应可用时运行。
2. 响应可用后，Promise 中的代码执行。这段代码获取 Promise 返回的响应并调用 `response.text()`，从而获取 `http://google.com` 返回的*完整*文本内容。由于完全加载可能需要时间，这*同样*返回一个 Promise，而*该* Promise 也有一个我们可以指定代码的 `.then()` 方法。
3. 最后，所有内容都可用时，我们最终的 Promise 代码运行。这可以是任何操作，但在我们的大部分应用场景中，这里就是像之前挑战中那样渗出数据的地方。

这可能非常难以理解和调试。请准备好在实际模式下的 Firefox 中进行调试。  
在本关卡中，Flag 不再整齐地包裹在 JavaScript 中，它只是普通的旧文本。你需要获取并渗出它以得分。祝你好运！

### HTTP GET 参数 (JavaScript)

当然，与任何 GET 请求一样，你可以添加一些参数。
现在就来试试吧！

### HTTP 表单 (JavaScript)

并且，我们自然可以使用 `fetch()` 来发起 POST 请求。
这让我们的 JavaScript 可以模拟提交表单等操作，这非常巧妙！
让我们在本关卡中练习一下。
你可以自行查阅如何向 `fetch()` 传递高级参数，但我们会给你一些提示，以下内容应*原样*出现在你的 JavaScript 代码中：

- `{`
- `method: "POST"`
- `body`
- `new URLSearchParams`
- `}`

祝你好运！

----
**注意：**
发送 POST 参数有多种方式。
在本模块中，我们介绍了表单数据的发送，但也存在其他类型的数据，并且通过 flask 访问它们的方式各不相同。
请确保你在 POST 中发送的是表单数据，而不是其他类型的数据；否则，我们的服务器（按其当前实现方式）将无法识别它！
