# 程序滥用

在本模块的每个挑战中，一个由 root 拥有的不同（标准）程序被设置了 `SUID` 位。这些程序通常在设计上并不需要设置为 `SUID`。你的任务是滥用这些程序提升后的权限来读取标志（flag）。

其中一些程序通常用于读取文件，但另一些则不然。为了更好地理解如何正确使用（以及滥用）这些程序，建议你查阅它们的 `man` 手册页。

## 挑战

### cat

让你直接读取标志！

### more

让你直接读取标志！

### less

让你直接读取标志！

### tail

让你直接读取标志！

### head

让你直接读取标志！

### sort

让你直接读取标志！

### vim

向你证明一个权限过高的编辑器是非常强大的工具！

### emacs

向你证明一个权限过高的编辑器是非常强大的工具！

### nano

向你证明一个权限过高的编辑器是非常强大的工具！

### rev

需要你理解其输出来推导出标志！

### od

需要你理解其输出来推导出标志！

### hd

需要你理解其输出来推导出标志！

### xxd

需要你理解其输出来推导出标志！

### base32

需要你理解其输出来推导出标志！

### base64

需要你理解其输出来推导出标志！

### split

需要你理解其输出来推导出标志！

### gzip

迫使你理解不同的归档格式！

### bzip2

迫使你理解不同的归档格式！

### zip

迫使你理解不同的归档格式！

### tar

迫使你理解不同的归档格式！

### ar

迫使你理解不同的归档格式！

### cpio

迫使你理解不同的归档格式！

### genisoimage

迫使你理解不同的归档格式！
- 权限不足无法读取，尝试信息泄露

### env

通过让程序执行其他命令来读取标志！

### find

通过让程序执行其他命令来读取标志！

### make

通过让程序执行其他命令来读取标志！

### nice

通过让程序执行其他命令来读取标志！

### timeout

通过让程序执行其他命令来读取标志！

### stdbuf

通过让程序执行其他命令来读取标志！

### setarch

通过让程序执行其他命令来读取标志！

### watch

通过让程序执行其他命令来读取标志！

### socat

通过让程序执行其他命令来读取标志！

### whiptail

需要一些简单的编程来读取标志！

### awk

需要一些简单的编程来读取标志！

### sed

需要一些简单的编程来读取标志！

### ed

需要一些简单的编程来读取标志！

### chown

通过权限操作来获取标志！

### chmod

通过权限操作来获取标志！

### cp

通过权限操作来获取标志！

### mv
通过权限操作来获取标志！

----
**注意：** 退一步思考你所处的更广泛的环境以及这种环境带来的可能性可能会有所帮助。

### perl

让你读取标志，因为它允许你编写任何程序！

### python

让你读取标志，因为它允许你编写任何程序！

### ruby

让你读取标志，因为它允许你编写任何程序！

### bash

让你读取标志，因为它允许你编写任何程序！

### date

压根就不是设计用来让你读文件的！

### dmesg

压根就不是设计用来让你读文件的！

### wc

压根就不是设计用来让你读文件的！

### gcc

压根就不是设计用来让你读文件的！

### as

压根就不是设计用来让你读文件的！

### wget

压根就不是设计用来让你读文件的！

----
**注意：** 此关卡存在一个“诱饵”解法，它*看起来*像是泄露了标志，但实际上是错误的。如果你提交了你认为应该有效的标志，但道场（dojo）不接受，请尝试在一个包含大写字母的文件上测试你的解法，看看会发生什么。

### ssh-keygen

此关卡展示了允许用户将自己的代码作为插件加载到程序中有多危险。当然，如何做到这一点正是难点所在！

----
**注意：** 你需要编写并编译 C 代码来解决此关卡！不知道怎么做？[在 pwn.college 上学习](/intro-to-programming-languages)！
