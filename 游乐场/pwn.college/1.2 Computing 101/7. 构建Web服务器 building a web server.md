# 构建Web服务器

既然你已经掌握了汇编语言的编写和调试，现在该真正实践了！在本模块中，你将逐步掌握从零构建 Web 服务器的技能：从简单程序开始，逐步进阶到处理多个 HTTP *GET* 和 *POST* 请求。祝你好运！  

----  
在后续学习中，请随时查阅你的[系统调用表](https://x64.syscall.sh/)。

## 挑战

### 退出

你的首个任务是创建一个最简单的程序——该程序在运行时立即终止。  
在本挑战中，你将使用负责结束进程并向操作系统返回退出状态的[退出系统调用](https://man7.org/linux/man-pages/man2/_exit.2.html)。  
此系统调用接受单个参数：退出状态（通常用 `0` 表示成功）。  
理解如何正确退出程序至关重要，因为这能确保你的进程正确传达其完成状态。
- 程序内说明：`/challenge/run <path_to_web_server>`
    - `as -o server.o server.s && ld -o server server.o`
    - `/challenge/run ./server`
- 60 exit

### 套接字

在本挑战中，你将通过使用[socket系统调用](https://man7.org/linux/man-pages/man2/socket.2.html)创建套接字来开启网络编程之旅。  
套接字是网络通信的基础构建单元，作为发送和接收数据的端点。  
当你调用[socket](https://man7.org/linux/man-pages/man2/socket.2.html)时，需要提供三个关键参数：协议域（例如IPv4使用`AF_INET`）、类型（如TCP使用`SOCK_STREAM`）以及协议（通常设为`0`以选择默认协议）。  
掌握此系统调用至关重要，因为它为所有后续网络交互奠定基础。 

```log
===== Expected: Parent Process =====
[ ] execve(<execve_args>) = 0
[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
[ ] exit(0) = ?
```
- 41 socket
- `grep -r SOCK_STREAM /usr/include/x86_64-linux-gnu`
    子目录对应道场环境
- `socket(AF_INET, SOCK_STREAM, 0)`
- 需保存之前挑战的退出功能

----

**注意：**  
查阅文档时，系统调用的参数会以全大写名称列出。  
例如，我们可能需要调用`socket(AF_INET, SOCK_STREAM, 0)`，但不能直接执行`mov rdi, AF_INET`：因为在汇编层面并不存在`AF_INET`这个概念。  
我们需要找到对应`AF_INET`的整数值。  
这些数值甚至不在手册页中，但确实存在于你的机器上。  
请查看`/usr/include`目录，系统所有C编程通用头文件都存放于此（若写过C语言，可回想代码中`#include <stdio.h>`引入的头文件，所有函数和常量的定义均位于此目录某处）。  
由于C语言会被编译为汇编，这些数值必然存在于此目录的某个文件中。  
与其手动搜索，你可以使用 grep(https://pwn.college/linux-luminarium/commands/)进行查找。

### 绑定

创建套接字后，下一步是为其分配网络身份标识。  
在本挑战中，你将使用[绑定系统调用](https://man7.org/linux/man-pages/man2/bind.2.html)将套接字与特定IP地址及端口号建立关联。  
该调用需要提供三个参数：套接字文件描述符、指向`sockaddr`结构体的指针（对于IPv4需使用特化的`sockaddr_in`结构体，其包含地址族、端口号和IP地址等字段），以及该结构体的大小。  
绑定操作至关重要，因为它能确保服务器在已知地址上监听，使客户端能够访问服务。

```log
===== Expected: Parent Process =====
[ ] execve(<execve_args>) = 0
[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
[ ] bind(3, {sa_family=AF_INET, sin_port=htons(<bind_port>), sin_addr=inet_addr("<bind_address>")}, 16) = 0
    - Bind to port 80
    - Bind to address 0.0.0.0
[ ] exit(0) = ?
```

- 49 bind
- `int bind(int sockfd, const struct sockaddr_in *addr, socklen_t addrlen);`
- sockaddr结构：<https://www.man7.org/linux/man-pages/man3/sockaddr.3type.html>
    ```c
    struct sockaddr_in {                           /* 共128位，或16字节 */
        uint16_t sa_family_t     sin_family;     /* AF_INET   栈偏移0   主机序*/
        uint16_t in_port_t       sin_port;       /* Port number 偏移2   网络序（大端）*/
        uint32_t struct in_addr  sin_addr;       /* IPv4 address 偏移4  网络序（大端）*/
        uint8_t __pad[8];                         /* 偏移8 */
    };

    struct in_addr {
        uint32_t in_addr_t s_addr;
    };
    ```

### 监听

在将套接字绑定到地址后，你现在需要将其设置为可接受传入连接的状态。  
[listen](https://man7.org/linux/man-pages/man2/listen.2.html) 系统调用会将你的套接字转换为被动模式，等待客户端连接请求。  
该调用需要两个参数：套接字的文件描述符和一个用于设置连接队列最大长度的积压参数。  
此步骤至关重要，因为如果不将套接字标记为监听状态，你的服务器将无法接收任何连接尝试。

```log
===== Expected: Parent Process =====
[ ] execve(<execve_args>) = 0
[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
[ ] bind(3, {sa_family=AF_INET, sin_port=htons(<bind_port>), sin_addr=inet_addr("<bind_address>")}, 16) = 0
    - Bind to port 80
    - Bind to address 0.0.0.0
[ ] listen(3, 0) = 0
[ ] exit(0) = ?
```

- 50 listen
- `int listen(int sockfd, int backlog);`

### 接受连接

当套接字处于监听状态后，下一步是主动接受传入连接。  
在本挑战中，你将使用 [accept](https://man7.org/linux/man-pages/man2/accept.2.html) 系统调用，该调用会等待客户端连接。  
当连接建立时，它会返回一个专用于与该客户端通信的新套接字文件描述符，并填充提供的地址结构（如 `struct sockaddr_in`）以记录客户端详细信息。  
这一步骤是实现服务器从被动监听者转变为主动通信者的关键环节。

```log
===== Expected: Parent Process =====
[ ] execve(<execve_args>) = 0
[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
[ ] bind(3, {sa_family=AF_INET, sin_port=htons(<bind_port>), sin_addr=inet_addr("<bind_address>")}, 16) = 0
    - Bind to port 80
    - Bind to address 0.0.0.0
[ ] listen(3, 0) = 0
[ ] accept(3, NULL, NULL) = 4
[ ] exit(0) = ?
```
- 43	accept
- `int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`


### 静态响应

既然你的服务器已能建立连接，现在该学习如何发送数据了。  
在本挑战中，你的目标是向任何连接的客户端发送固定的HTTP响应（`HTTP/1.0 200 OK\r\n\r\n`）。  
你将使用[write](https://man7.org/linux/man-pages/man2/write.2.html)系统调用，该调用需要三个参数：文件描述符、数据缓冲区的指针以及要写入的字节数。  
此练习非常重要，因为它将教你如何通过网络格式化并传输数据。

```log
===== Expected: Parent Process =====
[ ] execve(<execve_args>) = 0
[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
[ ] bind(3, {sa_family=AF_INET, sin_port=htons(<bind_port>), sin_addr=inet_addr("<bind_address>")}, 16) = 0
    - Bind to port 80
    - Bind to address 0.0.0.0
[ ] listen(3, 0) = 0
[ ] accept(3, NULL, NULL) = 4
[ ] read(4, <read_request>, <read_request_count>) = <read_request_result>
[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19
[ ] close(4) = 0
[ ] exit(0) = ?
```

- :warning: 包含 `read` 以及 `close`
- 0	read
    - 需在栈中分配后读取连接描述符中足够多的字节
- 1	write
- 3	close
- `ssize_t read(int fd, void *buf, size_t count);`
- `ssize_t write(int fd, const void *buf, size_t count);`
- `HTTP/1.0 200 OK\r\n\r\n`   
    => `48 54 54 50 2F 31 2E 30 20 32 30 30 20 4F 4B 0D 0A 0D 0A`
    若使用数字，需再转为小端法的排序
- 无法将64位立即数直接写入内存，立即数到寄存器后再写入内存


### 动态响应

在本挑战中，你的服务器将升级为能基于 HTTP *GET* 请求处理动态内容。  
首先使用 [read](https://man7.org/linux/man-pages/man2/read.2.html) 系统调用从客户端套接字接收传入的 HTTP 请求。  
通过解析请求行（此处重点关注 URL 路径），可判断客户端请求的具体资源。  
接着使用 [open](https://man7.org/linux/man-pages/man2/open.2.html) 系统调用打开目标文件，并再次调用 [read](https://man7.org/linux/man-pages/man2/read.2.html) 读取文件内容。  
最后通过 [write](https://man7.org/linux/man-pages/man2/write.2.html) 系统调用将文件内容返回客户端。  
这是实现服务器交互能力的关键进展——你的服务端不再仅返回静态消息，而是能根据请求动态生成响应内容。

```log
===== Expected: Parent Process =====
[ ] execve(<execve_args>) = 0
[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
[ ] bind(3, {sa_family=AF_INET, sin_port=htons(<bind_port>), sin_addr=inet_addr("<bind_address>")}, 16) = 0
    - Bind to port 80
    - Bind to address 0.0.0.0
[ ] listen(3, 0) = 0
[ ] accept(3, NULL, NULL) = 4
[ ] read(4, <read_request>, <read_request_count>) = <read_request_result>
[ ] open("<open_path>", O_RDONLY) = 5
[ ] read(5, <read_file>, <read_file_count>) = <read_file_result>
[ ] close(5) = 0
[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19
[ ] write(4, <write_file>, <write_file_count>) = <write_file_result>
[ ] close(4) = 0
[ ] exit(0) = ?
```

- 2	open
- 0 O_RDONLY
- `int open(const char * pathname, int flags);`
- 注意栈帧状态

### 迭代式GET服务器

此前，你的服务器仅处理单个 *GET* 请求后便会终止运行。  
现在，你需要对其进行改造，使其能够顺序处理多个 *GET* 请求。  
这需要将 accept-read-write-close 操作序列置于循环中实现。  
每当客户端连接时，服务器将接受连接、处理 *GET* 请求，随后在保持活动状态以等待下个请求的同时，妥善关闭当前客户端会话。  
这种迭代处理方式是构建持久化服务器的核心机制。
- 注意寄存器的值在系统调用时可能遭到的破坏

### 并发GET服务器

为使你的服务器能同时处理多个客户端，你将通过 [fork](https://man7.org/linux/man-pages/man2/fork.2.html) 系统调用引入并发机制。  
当客户端连接时，[fork](https://man7.org/linux/man-pages/man2/fork.2.html) 会创建专用于处理该连接的子进程。  
与此同时，父进程立即返回以继续接收其他连接。  
在此设计下，子进程通过 [read](https://man7.org/linux/man-pages/man2/read.2.html) 和 [write](https://man7.org/linux/man-pages/man2/write.2.html) 与客户端交互，而父进程持续保持监听状态。  
这种并发模型是构建可扩展实际应用服务器的核心概念。

```log
===== Expected: Parent Process =====
[ ] execve(<execve_args>) = 0
[ ] socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
[ ] bind(3, {sa_family=AF_INET, sin_port=htons(<bind_port>), sin_addr=inet_addr("<bind_address>")}, 16) = 0
    - Bind to port 80
    - Bind to address 0.0.0.0
[ ] listen(3, 0) = 0
[ ] accept(3, NULL, NULL) = 4
[ ] fork() = <fork_result>
[ ] close(4) = 0
[ ] accept(3, NULL, NULL) = ?

===== Expected: Child Process =====
[ ] close(3) = 0
[ ] read(4, <read_request>, <read_request_count>) = <read_request_result>
[ ] open("<open_path>", O_RDONLY) = 3
[ ] read(3, <read_file>, <read_file_count>) = <read_file_result>
[ ] close(3) = 0
[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19
[ ] write(4, <write_file>, <write_file_count>) = <write_file_result>
[ ] exit(0) = ?
```

- 57 fork
- `pid = fork();`
- 在fork后，父进程关闭连接描述符，子进程关闭监听描述符
- 确保文件描述符传递准确

### 并发POST服务器

本次挑战将扩展你的服务器能力，重点聚焦于并发处理 HTTP *POST* 请求。  
*POST* 请求更为复杂，因其同时包含请求头和消息体。  
你将再次使用 [fork](https://man7.org/linux/man-pages/man2/fork.2.html) 系统调用管理多连接，并通过 [read](https://man7.org/linux/man-pages/man2/read.2.html) 捕获完整请求内容。  
同样需要解析 URL 路径确定目标文件，但此次并非读取文件内容，而是将接收到的 *POST* 数据写入该文件。  

为此，你需要确定传入 *POST* 数据的长度：  
- **常规方案**：解析明确指定数据长度的 `Content-Length` 头部字段  
- **替代方案**：利用 [read](https://man7.org/linux/man-pages/man2/read.2.html) 返回值获取请求总长度，通过解析请求头（以 `\r\n\r\n` 结尾）计算头部总长，二者差值即为消息体长度——此方案看似复杂，实际可能更易实现  

最后，向客户端返回 `200 OK` 响应以确认 *POST* 请求处理成功。

POST 请求的子进程逻辑：
```log
===== Expected: Child Process =====
[ ] close(3) = 0
[ ] read(4, <read_request>, <read_request_count>) = <read_request_result>
[ ] open("<open_path>", O_WRONLY|O_CREAT, 0777) = 3
[ ] write(3, <write_file>, <write_file_count>) = <write_file_result>
[ ] close(3) = 0
[ ] write(4, "HTTP/1.0 200 OK\r\n\r\n", 19) = 19
[ ] exit(0) = ?
```
- GET `47, 45, 54`
- POST `50, 4F, 53, 54`
- O_WRONLY 01
- O_CREAT 0100（八进制）=> 64(十进制)
- `O_WRONLY|O_CREAT`：1 | 64 = 65（十进制）= 0x41
- `0777` 八进制 => 511 十进制 => 0x1ff 
- POST 的write定位请求体位置
- 注意系统调用时的寄存器破坏

### Web服务器

在最终挑战中，你的服务器必须在一个程序中无缝支持 *GET* 和 *POST* 请求。  
通过 [read](https://man7.org/linux/man-pages/man2/read.2.html) 系统调用读取传入请求后，服务器将检测前几个字符以判断当前处理的是 *GET* 还是 *POST* 请求。  
根据请求类型，服务器将相应处理数据，并通过 [write](https://man7.org/linux/man-pages/man2/write.2.html) 系统调用返回合适响应。  
整个过程中将运用 [fork](https://man7.org/linux/man-pages/man2/fork.2.html) 系统调用来并发处理每个连接，确保服务器能同时处理多个请求。  
完成此挑战后，你将构建出一个能处理各类 HTTP 请求的简易但功能完整的 Web 服务器。
