# 软件内省

当你编写越来越大的程序时，你（是的，甚至是你！）可能在实现某些功能时犯错，从而将*漏洞*引入你的程序中。当这种情况发生时，你需要一个可靠的资源工具箱来理解问题所在并修复它。当然，*完全相同*的技术也可用于理解非你编写的代码的问题，并根据你的意愿修复或利用它！

本模块将向你介绍几种内省、调试和理解软件的方法。你将携带这一关键知识，并在整个pwn.college中使用它，所以请认真听讲！

## 挑战

### 跟踪系统调用

第一个工具相当简单：系统调用跟踪器 `strace`。

给定一个要运行的程序，`strace` 将利用 Linux 操作系统的功能来内省并记录程序调用的每一个系统调用及其结果。
例如，我们来看一下之前挑战中的程序：

```sh
hacker@dojo:~$ strace /tmp/your-program
execve("/tmp/your-program", ["/tmp/your-program"], 0x7ffd48ae28b0 /* 53 vars */) = 0
exit(42)                                 = ?
+++ exited with 42 +++
hacker@dojo:~$
```

如你所见，`strace` 报告了触发了哪些系统调用、传递给它们的参数是什么以及它们返回了什么数据。
这里用于输出的语法是 `system_call(parameter, parameter, parameter, ...)`。
这种语法借鉴了一种名为 C 的编程语言，但我们暂时无需担心这一点。
只需记住如何阅读这种特定的语法即可。

在这个例子中，`strace` 报告了两个系统调用：第二个是程序用来请求自我终止的 `exit` 系统调用，你可以看到传递给它的参数 (42)。
第一个是一个 `execve` 系统调用。
我们稍后会学习这个系统调用，但它某种程度上与 `exit` 相辅相成：它启动一个新程序（在这个例子中是 `your-program`）。
在这种情况下，它实际上并非由 `your-program` 调用：它被 `strace` 检测到是 `strace` 工作方式的一个奇特现象，我们将在后面研究。

在最后一行，你可以看到 `exit(42)` 的结果，即程序以退出码 `42` 退出！

现在，不使用 `strace` 来内省 `exit` 系统调用很容易——毕竟，`exit` 的部分意义就在于给你一个可以访问的退出码。
但其他系统调用就不那么直观了。
例如，`alarm` 系统调用（系统调用编号 37！）会在操作系统中设置一个定时器，当经过指定的秒数后，Linux 将终止该程序。
`alarm` 的目的是，例如，在程序冻结时将其终止，但在这个案例中，我们将使用 `alarm` 来练习我们的 `strace` 窥探能力！

在这个挑战中，你必须使用 `strace` 跟踪 `/challenge/trace-me` 程序，以找出它作为参数传递给 `alarm` 系统调用的值，然后以你检索到的数字作为参数调用 `/challenge/submit-number`。
祝你好运！

### 启动 GDB

接下来，我们继续介绍 GDB。
GDB 代表 GNU 调试器，它通常用于追踪和理解程序漏洞。
更具体地说，调试器是一种能够密切监控和内省其他进程的工具。
有许多著名的调试器，而在 Linux 领域，gdb 是目前最常用的。

我们将通过一系列挑战逐步学习 gdb。
在这个挑战中，我们将重点介绍如何启动它。
操作如下：

```sh
hacker@dojo:~$ gdb /path/to/binary/file
```

在这个挑战中，包含秘密的可执行文件是 `/challenge/debug-me`。
一旦你在 gdb 中加载它，其余部分将神奇地完成：我们将处理分析并给你秘密数字。
在后续关卡中，你将学习如何自行获取该数字！

再次提醒，一旦你获得该数字，请使用 `/challenge/submit-number` 将其兑换为 flag。

### 在 GDB 中启动程序

调试器（包括 gdb）会在被调试程序*运行时*观察它，以暴露其运行时行为的信息。
在上一关中，我们自动为你启动了程序。
在这里，我们将稍微减少自动化程度：你必须启动程序的执行，而我们将完成其余工作（例如，从中恢复秘密值）。

当你现在启动 gdb 时，它最终会显示一个命令提示符，如下所示：

```gdb
(gdb) 
```

你可以使用 `starti` 命令启动程序：

```gdb
(gdb) starti
```

`starti` 在第一条指令处启动程序。
现在请尝试一下，我们将在程序运行后配置 gdb 以自动提取秘密值。
