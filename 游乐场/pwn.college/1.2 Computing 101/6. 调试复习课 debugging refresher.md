# 调试复习指南

与计算工作的关键部分是理解当问题不可避免地出现时究竟哪里出了错。本模块将基于您之前接触过的 GDB 知识，进一步深入*调试*程序：挖掘内部、四处探查并获取知识。这是您在计算之旅中将学到的最关键技能之一，而本模块有望为我们之前种下的种子浇灌成长。

如您所知，GDB 是一款非常强大的动态分析工具，您可以通过它来了解程序在整个执行过程中的状态。在本模块中，您将更加熟悉其部分功能。

## resources

### GDB 帮助

以下是几个优秀的 GDB 速成课程/参考手册：

- [GDB 官方文档](https://sourceware.org/gdb/onlinedocs/gdb/index.html)
- [Tudor 的 GDB 速成课程](https://web.archive.org/web/20250101052732/https://users.umiacs.umd.edu/~tdumitra/courses/ENEE757/Fall15/misc/gdb_tutorial.html)
- [GDB 调试完整示例](https://www.brendangregg.com/blog/2016-08-09/gdb-example-ncurses.html)
- [pwndbg：GDB 扩展（功能列表）](https://pwndbg.re/stable/features/)
- [gef：另一个 GDB 扩展（功能列表）](https://hugsy.github.io/gef/commands/aliases/)
- OpenSecurityTraining2 的课程 [Debuggers 1012：GDB 入门](https://ost2.fyi/Dbg1012)

## 挑战

### 调试程序

本关卡旨在让你重新熟悉 gdb。要开始本关卡及本模块所有其他关卡，请运行 `/challenge/embryogdb_levelxyz`（其中 xyz 是关卡编号）。该程序将启动 `gdb`。使用 `r` 命令运行实际关卡逻辑，并按照提示获取 flag！

----  
**相关文档：**  
- gdb 的 [run](https://sourceware.org/gdb/current/onlinedocs/gdb#starting) 命令  
- gdb 的 [continue](https://sourceware.org/gdb/current/onlinedocs/gdb#contin

### 检查寄存器

接下来，我们将学习如何打印寄存器的值。

你可以使用 `info registers` 查看所有寄存器的值。或者，你也可以使用 `print` 命令（简写为 `p`）打印特定寄存器的值。例如，`p $rdi` 将以十进制打印 $rdi 的值。你也可以使用 `p/x $rdi` 以十六进制打印其值。

为了解决本关卡，你必须找出寄存器 r12 当前的随机值（十六进制格式）。

如前所述，启动挑战程序，调用 `run` gdb 命令，然后按照说明操作。  
当你打印出所需信息后，记得使用 `continue` 继续挑战的下一步！

----

**相关文档：**

- gdb 的 [run](https://sourceware.org/gdb/current/onlinedocs/gdb#starting) 命令  
- gdb 的 [continue](https://sourceware.org/gdb/current/onlinedocs/gdb#continuing-and-stepping) 命令  
- gdb 的 [info](https://sourceware.org/gdb/current/onlinedocs/gdb#registers) 命令  
- gdb 的 [print](https://sourceware.org/gdb/current/onlinedocs/gdb#data) 命令

### 检查内存

接下来，我们将学习使用 gdb 查看进程内存！

你可以使用参数化命令 `x/<n><u><f> <address>` 来检*查*内存内容。此格式中：
- `<u>` 表示显示的单位大小
- `<f>` 表示显示的格式  
- `<n>` 表示要显示的元素数量

有效的单位大小包括：`b`（1 字节）、`h`（2 字节）、`w`（4 字节）和 `g`（8 字节）。有效的格式包括：`d`（十进制）、`x`（十六进制）、`s`（字符串）和 `i`（指令）。地址可以通过寄存器名、符号名或绝对地址指定。此外，在指定地址时还可以使用数学表达式。

例如：
- `x/8i $rip` 将打印当前指令指针后的 8 条指令
- `x/16i main` 将打印 main 函数的前 16 条指令
- 你也可以使用 `disassemble main`（简写 `disas main`）打印 main 函数的全部指令
- `x/16gx $rsp` 将打印栈上的前 16 个值
- `x/gx $rbp-0x32` 将打印栈上该地址存储的局部变量

你可能希望使用正确的汇编语法查看指令，可通过命令 `set disassembly-flavor intel` 设置。

为了解决本关卡，你必须找出栈上的随机值（从 `/dev/urandom` 读取的值）。请思考 read 系统调用的参数含义。
- `ssize_t read(int fd, void * buf, size_t count);`
- 查看调用read前的buf地址，在调用read后解引用buf
- 或，查看储存值的栈地址

----

**相关文档：**

- gdb 的 [run](https://sourceware.org/gdb/current/onlinedocs/gdb#Starting) 命令
- gdb 的 [continue](https://sourceware.org/gdb/current/onlinedocs/gdb#Continuing-and-Stepping) 命令  
- gdb 的 [info](https://sourceware.org/gdb/current/onlinedocs/gdb#Registers) 命令
- gdb 的 [print](https://sourceware.org/gdb/current/onlinedocs/gdb#Data) 命令
- gdb 的 [examine](https://sourceware.org/gdb/current/onlinedocs/gdb#Memory) 命令

### 设置断点

动态分析的关键部分在于让程序进入你感兴趣的分析状态。
到目前为止，这些挑战已自动设置断点，使程序在执行到你可能感兴趣的分析状态时暂停。
掌握自行设置断点的能力十分重要。

有多种方式可以控制程序执行流程：
- 使用 `stepi <n>` 命令（简写为 `si <n>`）单步执行一条指令
- 使用 `nexti <n>` 命令（简写为 `ni <n>`）单步执行一条指令，但会跳过函数调用
- `<n>` 参数为可选参数，用于指定单次执行的指令步数
- 使用 `finish` 命令执行完当前函数
- 使用参数化命令 `break *<address>` 在指定地址设置断点
- 你已使用过的 `continue` 命令会继续执行直至遇到断点

单步调试时，实时显示某些数值会很有帮助，实现方式有多种：
- 最简单的是使用参数化命令 `display/<n><u><f>`，其格式与 `x/<n><u><f>` 命令完全一致。例如：
  - `display/8i $rip` 会持续显示后续 8 条指令
  - `display/4gx $rsp` 会持续显示栈上前 4 个值
- 另一种方式是使用 `layout regs` 命令，该命令会启用 gdb 的 TUI 模式，显示所有寄存器内容及附近指令

本关卡需要你找出栈上存放的一系列随机值。如前所述，`run` 命令将启动程序，但会中断执行，你需要*仔细地*继续执行流程。

强烈建议你尝试组合使用 `stepi`、`nexti`、`break`、`continue` 和 `finish` 命令，以深入理解这些关键的程序执行导航工具。

查看判断的对应值，或运行时修改内存以匹配

----

**相关文档：**
- gdb 的 [run](https://sourceware.org/gdb/current/onlinedocs/gdb#starting) 命令
- gdb 的 [continue](https://sourceware.org/gdb/current/onlinedocs/gdb#continuing-and-stepping) 命令
- gdb 的 [info](https://sourceware.org/gdb/current/onlinedocs/gdb#registers) 命令
- gdb 的 [print](https://sourceware.org/gdb/current/onlinedocs/gdb#data) 命令
- gdb 的 [examine](https://sourceware.org/gdb/current/onlinedocs/gdb#memory) 命令
- gdb 的 [break](https://sourceware.org/gdb/current/onlinedocs/gdb#set-breaks) 命令
- gdb 的 [display](https://sourceware.org/gdb/current/onlinedocs/gdb#auto-display) 命令
- gdb 的 [各类单步执行命令](https://sourceware.org/gdb/current/onlinedocs/gdb#continuing-and-stepping)（整节内容）

**注意：**
本关卡需要你*阅读*并*理解*汇编代码！不必担心，这项技能在后续的 pwn.college 学习中会非常实用。

### GDB 脚本编写

我们编写代码是为了表达可复现和优化的思想。我们可以将分析过程视为一个*将待分析目标作为数据输入的程序*。正如俗话所说，代码即数据，数据即代码。

虽然像之前关卡那样交互式使用 gdb 非常强大，但 gdb 脚本是另一个强大的工具。通过编写 gdb 脚本，你可以快速创建定制化的程序分析工具。如果你了解如何与 gdb 交互，你就已经掌握了编写 gdb 脚本的方法——语法完全相同。

你可以将命令写入某个文件（例如 `x.gdb`），然后使用 `-x <脚本路径>` 参数启动 gdb。该文件将在 gdb 启动后执行所有命令。或者，你可以使用 `-ex '<命令>'` 执行单个命令，并通过多个 `-ex` 参数传递多个命令。最后，你可以将某些命令放入 `~/.gdbinit` 中，使其在任何 gdb 会话中自动执行（建议将 `set disassembly-flavor intel` 放入该文件）。

在 gdb 脚本中，断点命令是一个非常有用的结构。考虑以下 gdb 脚本：

```gdb
start
break *main+42
commands
  x/gx $rbp-0x32
  continue
end
continue
```

这种情况下，每当执行到 `*main+42*` 处的指令时，我们会输出特定局部变量后继续执行。

现在看一个类似但更高级的脚本（使用一些你尚未接触的命令）：

```gdb
start
break *main+42
commands
  silent
  set $local_variable = *(unsigned long long*)($rbp-0x32)
  printf "Current value: %llx\n", $local_variable
  continue
end
continue
```

此脚本中，`silent` 表示让 gdb 不报告断点命中信息以使输出更简洁。接着使用 `set` 命令在 gdb 会话中定义变量（其值为局部变量），最后通过格式化字符串输出当前值。

请使用 gdb 脚本来帮助你收集本关卡的随机值。这个过程可能有些困难，但将对你未来的学习之旅大有裨益。

----

**相关文档：**

- gdb 的 [run](https://sourceware.org/gdb/current/onlinedocs/gdb#starting) 命令
- gdb 的 [continue](https://sourceware.org/gdb/current/onlinedocs/gdb#continuing-and-stepping) 命令
- gdb 的 [info](https://sourceware.org/gdb/current/onlinedocs/gdb#registers) 命令
- gdb 的 [print](https://sourceware.org/gdb/current/onlinedocs/gdb#data) 命令
- gdb 的 [examine](https://sourceware.org/gdb/current/onlinedocs/gdb#memory) 命令
- gdb 的 [break](https://sourceware.org/gdb/current/onlinedocs/gdb#set-breaks) 命令
- gdb 的 [display](https://sourceware.org/gdb/current/onlinedocs/gdb#auto-display) 命令
- gdb 的 [各类单步执行命令](https://sourceware.org/gdb/current/onlinedocs/gdb#continuing-and-stepping)（整节内容）
- gdb 的 [断点脚本](https://sourceware.org/gdb/current/onlinedocs/gdb#break-commands)

### 修改数据

事实上，gdb 对目标进程拥有*完全*控制权。
你不仅可以分析程序状态，还能修改其状态。虽然 gdb 可能不是进行程序长期维护的最佳工具，但有时快速修改目标进程的行为可以更方便地进行分*析*。

你可以使用 `set` 命令修改目标程序的状态。例如：
- `set $rdi = 0` 可将 $rdi 清零
- `set *((uint64_t *) $rsp) = 0x1234` 可将栈顶第一个值设为 0x1234  
- `set *((uint16_t *) 0x31337000) = 0x1337` 可将地址 0x31337000 处的 2 字节设为 0x1337

假设你的目标是某个网络应用程序，它从文件描述符 42 的套接字读取数据。出于分析目的，若让目标改为从标准输入读取可能更方便。你可以通过以下 gdb 脚本实现类似效果：

```gdb
start
catch syscall read
commands
  silent
  if ($rdi == 42)
    set $rdi = 0
  end
  continue
end
continue
```

此示例演示了如何自动在系统调用处中断，以及如何在命令中使用条件判断来选择性执行 gdb 命令。

在前一关卡中，你的 gdb 脚本解决方案可能仍需手动复制粘贴答案。本次请尝试编写一个无需与程序交互的脚本，通过正确修改寄存器/内存来自动完成每个挑战。
- 当前 scanf 从标准输入读取，修改值并跳过

----
相关文档：
- gdb 的 [run](https://sourceware.org/gdb/current/onlinedocs/gdb#starting) 命令
- gdb 的 [continue](https://sourceware.org/gdb/current/onlinedocs/gdb#continuing-and-stepping) 命令
- gdb 的 [info](https://sourceware.org/gdb/current/onlinedocs/gdb#registers) 命令
- gdb 的 [print](https://sourceware.org/gdb/current/onlinedocs/gdb#data) 命令
- gdb 的 [examine](https://sourceware.org/gdb/current/onlinedocs/gdb#memory) 命令
- gdb 的 [break](https://sourceware.org/gdb/current/onlinedocs/gdb#set-breaks) 命令
- gdb 的 [display](https://sourceware.org/gdb/current/onlinedocs/gdb#auto-display) 命令
- gdb 的 [各类单步执行命令](https://sourceware.org/gdb/current/onlinedocs/gdb#continuing-and-stepping)（整节内容）
- gdb 的 [断点脚本](https://sourceware.org/gdb/current/onlinedocs/gdb#break-commands)
- gdb 的 [set](https://sourceware.org/gdb/current/onlinedocs/gdb#assignment) 命令（注意：本关卡将专门用此命令设置寄存器（如示例中的 `$rdi`）和内存（参见链接文档底部说明））

### 修改执行流程

本关卡将向你展示 gdb 的真正威力之一。

如前一关卡所示，gdb 对目标进程拥有*完全*控制权。正常情况下，以普通用户身份运行的 gdb 无法附加到特权进程。这就是为什么 gdb 不会成为允许你直接解决所有关卡的重大安全问题。尽管如此，gdb 仍然是极其强大的工具。

在此提升权限的 gdb 实例中运行，可让你对整个系统拥有更高控制权。为清晰演示此功能，请观察当你运行命令 `call (void)win()` 时发生的情况。事实上，本模块的所有关卡均可通过此方式解决。

GDB 非常强大！

注：
- `info functions` 列出所有已知函数
    - `info functions win` 按名字过滤

----
相关文档：
- gdb 的 [run](https://sourceware.org/gdb/current/onlinedocs/gdb#starting) 命令
- gdb 的 [continue](https://sourceware.org/gdb/current/onlinedocs/gdb#continuing-and-stepping) 命令
- gdb 的 [info](https://sourceware.org/gdb/current/onlinedocs/gdb#registers) 命令
- gdb 的 [print](https://sourceware.org/gdb/current/onlinedocs/gdb#data) 命令
- gdb 的 [examine](https://sourceware.org/gdb/current/onlinedocs/gdb#memory) 命令
- gdb 的 [break](https://sourceware.org/gdb/current/onlinedocs/gdb#set-breaks) 命令
- gdb 的 [display](https://sourceware.org/gdb/current/onlinedocs/gdb#auto-display) 命令
- gdb 的 [各类单步执行命令](https://sourceware.org/gdb/current/onlinedocs/gdb#continuing-and-stepping)（整节内容）
- gdb 的 [断点脚本](https://sourceware.org/gdb/current/onlinedocs/gdb#break-commands)
- gdb 的 [set](https://sourceware.org/gdb/current/onlinedocs/gdb#assignment) 命令
- gdb 的 [call](https://sourceware.org/gdb/current/onlinedocs/gdb#calling) 命令（记住表达式语法类似 C 语言语法）

### 故障函数

前一关卡向你展示了原始但未优化的力量。
本关卡将迫使你优化它，因为 `win` 函数将不再有效。
请在该函数处设置断点，查看周围环境，并理解问题所在。
- 分配栈并初始化为0后，将0做为指针而不是使用栈地址
    - 存在两处会导致段错误的内存访问点
- 设置为栈空间或跳过

----
**相关文档：**
- gdb 的 [run](https://sourceware.org/gdb/current/onlinedocs/gdb#Starting) 命令
- gdb 的 [continue](https://sourceware.org/gdb/current/onlinedocs/gdb#Continuing-and-Stepping) 命令
- gdb 的 [info](https://sourceware.org/gdb/current/onlinedocs/gdb#Registers) 命令
- gdb 的 [print](https://sourceware.org/gdb/current/onlinedocs/gdb#Data) 命令
- gdb 的 [examine](https://sourceware.org/gdb/current/onlinedocs/gdb#Memory) 命令
- gdb 的 [break](https://sourceware.org/gdb/current/onlinedocs/gdb#Set-Breaks) 命令
- gdb 的 [display](https://sourceware.org/gdb/current/onlinedocs/gdb#Auto-Display) 命令
- gdb 的 [各类单步执行命令](https://sourceware.org/gdb/current/onlinedocs/gdb#Continuing-and-Stepping)（整节内容）
- gdb 的 [断点脚本](https://sourceware.org/gdb/current/onlinedocs/gdb#Break-Commands)
- gdb 的 [set](https://sourceware.org/gdb/current/onlinedocs/gdb#Assignment) 命令
- gdb 的 [call](https://sourceware.org/gdb/current/onlinedocs/gdb#Calling) 命令
- gdb 的 [jump](https://sourceware.org/gdb/current/onlinedocs/gdb#Jumping) 命令
