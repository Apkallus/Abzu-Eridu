# 计算机内存

哇，你是一位崭露头角的x86汇编程序员！你已经设置了寄存器，触发了系统调用，并编写了第一个能干净退出的程序。现在，我们还有一个重要概念要介绍给你：*内存*。

你作为（大概）人类，拥有[短期记忆](https://en.wikipedia.org/wiki/short-term_memory)和[长期记忆](https://en.wikipedia.org/wiki/long-term_memory)。在执行特定计算时，你的大脑会将之前学到的信息加载到短期记忆中，然后对这些信息进行操作，最终将新的结果信息存入长期记忆。在社会层面，我们还发明了其他更长期的存储形式：口述历史、日记、书籍和维基百科。如果你的长期记忆没有足够空间存储某些信息，或者该信息不重要到需要存入长期记忆，你随时可以查阅维基百科，让大脑将其存入长期记忆，并在以后需要时提取到短期记忆中。

这种从"小而快"（你的短期记忆，需要时立即可用但[仅能存储5到9条信息](https://www.simplypsychology.org/short-term-memory.html)）到"大而慢"（从海量长期记忆中回忆信息）再到"巨大但极其缓慢"（查阅维基百科）的多层次信息访问层级，实际上是现代计算中[内存层次结构](https://en.wikipedia.org/wiki/memory_hierarchy)的基础。

我们在上一个模块中已经学习了"小而快"的部分：那就是寄存器，数量有限但速度极快。比所有寄存器加起来还要宽敞得多，但访问速度却慢得多的，是计算机内存，这正是本模块要深入探讨的内容，让你一窥内存层次结构的另一层级。

## 挑战

### 从内存加载

从程序的角度看，计算机内存是一个存储数据的巨大空间。
就像街道上的房屋一样，内存的每个部分都有一个数字*地址*，并且这些数字（大部分）是连续的。
现代计算机拥有海量内存，而典型现代程序的内存视图实际上存在大量空隙（可以理解为：街道上尚未建造房屋的区域，因此这些地址被跳过）。
但这些都只是细节：关键在于，计算机将数据（主要是顺序地）存储在内存中。

在本关卡中，我们将练习访问存储在内存中的数据。
我们该如何做到这一点？
回想一下，要将一个值移入寄存器，我们曾执行类似这样的操作：

```assembly
mov rdi, 31337
```

执行后，`rdi` 的值变为 `31337`。
很好。
那么，我们可以使用相同的指令来访问内存！
该指令有另一种格式，它将第二个参数用作要访问的内存地址！
假设我们的内存布局如下：

```text
  Address │ Contents
+────────────────────+
│ 31337   │ 42       │
+────────────────────+
```

要访问内存地址 31337 处的内容，你可以这样做：

```assembly
mov rdi, [31337]
```

当 CPU 执行此指令时，它当然理解 `31337` 是一个*地址*，而不是原始值。
如果你将指令想象成一个人告诉 CPU 该做什么，并且沿用我们的"街道房屋"类比，那么指令/人并不是直接递给 CPU 数据，而是*指向街道上的一栋房屋*。
CPU 随后会前往该地址，按响门铃，打开前门，将里面的数据拖出来，并将其放入 `rdi`。
因此，此上下文中的 `31337` 是*内存地址*，用于*指向*存储在该内存地址的数据。
此指令执行后，存储在 `rdi` 中的值将是 `42`！

让我们将其付诸实践！
我已经将一个秘密数字存储在内存地址 `133700` 处，如下所示：

```text
  Address │ Contents
+────────────────────+
│ 133700  │ ???      │
+────────────────────+
```

你必须检索这个秘密数字，并将其用作程序的退出代码。
为此，你必须将其读入 `rdi`，如果你还记得的话，`rdi` 的值是 `exit` 的第一个参数，并被用作退出代码。
祝你好运！

----

*注意*：要解决此挑战，你必须将输出的可执行二进制文件或汇编代码 `.s` 文件传递给 `/challenge/check`。

### 更多加载练习

你看起来好像还需要*再多练习一点点*。在这一关，我们把密钥值放在 `123400` 而不是 `133700`，像这样：

```text
  Address │ Contents
+────────────────────+
│ 123400  │ ???      │
+────────────────────+
```

去把它加载到 `rdi` 中并以它作为退出代码*退出*！

### 指针解引用

你是更倾向于访问 `133700` 处的内存还是 `123400` 处的内存？
你的答案或许能反映出你的个性，但从技术角度来说并不太重要。
事实上，在大多数情况下，编写程序时你根本不需要处理实际的内存地址！

这怎么可能呢？
通常，内存地址是存储在寄存器中的，我们使用寄存器中的值来指向内存中的数据！
让我们从这个内存配置开始：

```text
  Address │ Contents
+────────────────────+
│ 133700  │ 42       │
+────────────────────+
```

并考虑这段汇编代码片段：

```assembly
mov rax, 133700
```

现在，你面临的情况如下：

```text
    Address │ Contents
  +────────────────────+
┌▸│ 133700  │ 42       │
│ +────────────────────+
│
└────────────────────────┐
                         │
   Register │ Contents   │
  +────────────────────+ │
  │ rax     │ 133700   │─┘
  +────────────────────+
```

`rax` 现在保存了一个值，该值对应着我们想要加载的数据的地址！
让我们来加载它：

```assembly
mov rdi, [rax]
```

在这里，我们正在访问内存，但不是像 `133700` 那样为内存读取指定一个固定地址，而是使用存储在 `rax` 中的值作为内存地址。
通过包含内存地址，`rax` 是一个*指针*，它*指向*我们想要访问的数据！
当我们使用 `rax` 来代替直接指定它存储的地址，以访问它引用的内存地址时，我们称之为*解引用*该指针。
在上面的例子中，我们*解引用* `rax` 以将其指向的数据（地址 `133700` 处的值 `42`）加载到 `rdi` 中。
很巧妙吧！

这也强调了另一点：这些寄存器是*通用*的！
仅仅因为我们在之前的挑战中一直将 `rax` 用作系统调用索引，并不意味着它不能有其他用途。
在这里，它被用作指向我们存储在内存中的秘密数据的指针。

同样，寄存器中的*数据*也没有隐含的用途。
如果 `rax` 包含值 `133700` 并且我们写入 `mov rdi, [rax]`，CPU 会将该值用作要解引用的内存地址。
但是，如果在相同条件下我们写入 `mov rdi, rax`，CPU 只会简单地将 `133700` 放入 `rdi`。
对 CPU 而言，数据就是数据；只有当它以不同的方式被使用时，它才会被区分开来。

在这个挑战中，我们已经将 `rax` 初始化为包含我们存储在内存中的秘密数据的地址。
解引用 `rax` 将秘密数据加载到 `rdi` 中，并将其用作程序的退出代码来获取 flag！

### 自主解引用

在上一关中，你通过解引用 `rax` 将数据读取到 `rdi` 中。
这里有趣的是，我们选择 `rax` 是相当随意的。
我们本可以使用任何其他指针，甚至是 `rdi` 本身！
没有什么能阻止你通过解引用一个寄存器，用解引用得到的值来覆盖它自身的内容！

例如，这里我们正在用 `rax` 做这件事。
我已经用注释对每一行进行了标注：

```assembly
mov [133700], 42
mov rax, 133700  # after this, rax will be 133700
mov rax, [rax]   # after this, rax will be 42
```

在整个代码片段中，`rax` 从被用作指针，转变为用于保存从内存中读取的数据。
CPU 使这一切成为可能！

在这个挑战中，你将探索这个概念。
与之前初始化 `rax` 不同，我们这次让 `rdi` 成为了指向密钥值的指针！
你需要解引用它，将该值加载到 `rdi` 中，然后以该值作为退出代码执行 `exit`。
祝你好运！

### 带偏移量的解引用

所以现在你可以像专业人士一样解引用内存中的指针了！
但指针并不总是直接指向你需要的数据。
例如，有时一个指针可能指向一个数据集合（比如一整本书），而你需要引用这个集合中的某一部分来获取你需要的数据。

例如，如果你的指针（比如 `rdi`）指向内存中的一系列数字，像这样：

```text
    Address │ Contents
  +────────────────────+
┌▸│ 133700  │ 50       │
│ │ 133701  │ 42       │
│ │ 133702  │ 99       │
│ │ 133703  │ 14       │
│ +────────────────────+
│
└────────────────────────┐
                         │
   Register │ Contents   │
  +────────────────────+ │
  │ rdi     │ 133700   │─┘
  +────────────────────+
```

如果你想要该序列中的第二个数字，你可以这样做：

```assembly
mov rax, [rdi+1]
```

哇，超级简单！
在内存术语中，我们称这些数字槽为*字节*：每个内存地址代表一个特定的内存字节。
上面的例子访问的是 `rdi` 所指向的内存地址之后 1 个字节处的内存。
在内存术语中，我们称这 1 个字节的差值为*偏移量*，所以在这个例子中，相对于 `rdi` 指向的地址有一个为 1 的偏移量。

让我们来练习这个概念。
和之前一样，我们将初始化 `rdi` 以指向密钥值，但*不是*直接指向它。
这次，密钥值的位置将与 `rdi` 指向的位置有 8 个字节的偏移量，类似于这样：

```text
    Address │ Contents
  +────────────────────+
┌▸│ 31337   │ 0        │
│ │ 31337+1 │ 0        │
│ │ 31337+2 │ 0        │
│ │ 31337+3 │ 0        │
│ │ 31337+4 │ 0        │
│ │ 31337+5 │ 0        │
│ │ 31337+6 │ 0        │
│ │ 31337+7 │ 0        │
│ │ 31337+8 │ ???      │
│ +────────────────────+
│
└────────────────────────┐
                         │
   Register │ Contents   │
  +────────────────────+ │
  │ rdi     │ 31337    │─┘
  +────────────────────+
```

当然，实际的内存地址并不是 `31337`。
我们会随机选择一个地址，并将其存储在 `rdi` 中。
去解引用 `rdi` 加上偏移量 `8` 来获取 flag 吧！

### 存储的地址

指针还可以变得更有趣！
想象一下你的朋友住在你街道上的另一所房子里。
与其记住他们的地址，你可能会把它写下来，并将写有朋友家地址的纸存放在*你的*房子里。
然后，要从你的朋友那里获取数据，你需要让 CPU 指向你的房子，让它进去找到朋友的地址，并使用该地址作为指向他们房子的指针。

类似地，由于内存地址实际上只是值，它们可以被存储在内存中，并在之后被检索出来！
让我们探讨一个场景：我们将值 `133700` 存储在地址 `123400` 处，并将值 `42` 存储在地址 `133700` 处。
考虑以下指令：

```assembly
mov rdi, 123400    # after this, rdi becomes 123400
mov rdi, [rdi]     # after this, rdi becomes the value stored at 123400 (which is 133700)
mov rax, [rdi]     # here we dereference rdi, reading 42 into rax!
```

哇！
这种存储地址的方式在程序中*极其*常见。
地址和数据被存储、加载、移动，有时还会相互混淆！
当这种情况发生时，安全问题就会出现，在你 pwn.college 的旅程中，你会遇到许多这样的问题。

现在，让我们练习解引用一个存储在内存中的地址。
我会将一个密钥值存储在一个密钥地址处，然后将这个密钥地址存储在地址 `567800` 处。
你必须读取该地址，解引用它，获取密钥值，然后以该值作为退出代码执行 `exit`。
你能做到的！

### 双重解引用

在过去的几关中，你已经：

- 使用我们告诉你的地址（在一关中为 `133700`，另一关中为 `123400`）从内存中加载密钥值。
- 使用我们为你放入 `rax` 的地址从内存中加载密钥值。
- 使用我们告诉你的地址（在上一关中为 `567800`）从内存中将密钥值的*地址*加载到一个寄存器中，然后使用该寄存器作为指针从内存中检索出密钥值！

现在让我们把最后两点结合起来。
在这个挑战中，我们将 `SECRET_VALUE` 存储在地址为 `SECRET_LOCATION_1` 的内存中，然后将 `SECRET_LOCATION_1` 存储在地址为 `SECRET_LOCATION_2` 的内存中。
接着，我们把 `SECRET_LOCATION_2` 放入了 `rax`！
使用 `123400` 代表 `SECRET_LOCATION_1`，`133700` 代表 `SECRET_LOCATION_2`（注意，在实际挑战中，这些值将是不同的并且对你隐藏！），结果看起来类似这样：

```text
      Address │ Contents
    +────────────────────+
┌──▸│ 133700  │ 123400   │─┐
│   +────────────────────+ │
│ ┌▸│ 123400  │ 42       │ │
│ │ +────────────────────+ │
│ └────────────────────────┘
└──────────────────────────┐
                           │
     Register │ Contents   │
    +────────────────────+ │
    │ rax     │ 133700   │─┘
    +────────────────────+
```

在这里，你需要执行两次内存读取：第一次是解引用 `rax`，从 `rax` 所指向的位置（即 `SECRET_LOCATION_2`）读取 `SECRET_LOCATION_1`；第二次是解引用现在持有 `SECRET_LOCATION_1` 的那个寄存器，将 `SECRET_VALUE` 读取到 `rdi` 中，这样你就可以用它作为退出代码了！

这听起来很复杂，但基本上你已经做过所有这些步骤了。
去把它们组合起来吧！

### 三重解引用

好的，让我们再深入一层！
在这个挑战中，我们增加了一层额外的间接引用，所以现在你将需要*三次*解引用才能找到密钥值。
类似于这样：

```text
        Address │ Contents
      +────────────────────+
┌────▸│ 133700  │ 123400   │───┐
│     +────────────────────+   │
│ ┌──▸│ 123400  │ 100000   │─┐ │
│ │   +────────────────────+ │ │
│ │ ┌▸│ 100000  │ 42       │ │ │
│ │ │ +────────────────────+ │ │
│ │ └────────────────────────┘ │
│ └────────────────────────────┘
└──────────────────────────────┐
                               │
       Register │ Contents     │
      +────────────────────+   │
      │ rdi     │ 133700   │───┘
      +────────────────────+
```

如你所见，我们会将你必须解引用的第一个地址放入 rdi。
去获取这个值吧！
