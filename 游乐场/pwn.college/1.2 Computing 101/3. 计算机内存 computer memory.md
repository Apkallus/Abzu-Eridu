# 计算机内存

哇，你是一位崭露头角的x86汇编程序员！你已经设置了寄存器，触发了系统调用，并编写了第一个能干净退出的程序。现在，我们还有一个重要概念要介绍给你：*内存*。

你作为（大概）人类，拥有[短期记忆](https://en.wikipedia.org/wiki/short-term_memory)和[长期记忆](https://en.wikipedia.org/wiki/long-term_memory)。在执行特定计算时，你的大脑会将之前学到的信息加载到短期记忆中，然后对这些信息进行操作，最终将新的结果信息存入长期记忆。在社会层面，我们还发明了其他更长期的存储形式：口述历史、日记、书籍和维基百科。如果你的长期记忆没有足够空间存储某些信息，或者该信息不重要到需要存入长期记忆，你随时可以查阅维基百科，让大脑将其存入长期记忆，并在以后需要时提取到短期记忆中。

这种从"小而快"（你的短期记忆，需要时立即可用但[仅能存储5到9条信息](https://www.simplypsychology.org/short-term-memory.html)）到"大而慢"（从海量长期记忆中回忆信息）再到"巨大但极其缓慢"（查阅维基百科）的多层次信息访问层级，实际上是现代计算中[内存层次结构](https://en.wikipedia.org/wiki/memory_hierarchy)的基础。

我们在上一个模块中已经学习了"小而快"的部分：那就是寄存器，数量有限但速度极快。比所有寄存器加起来还要宽敞得多，但访问速度却慢得多的，是计算机内存，这正是本模块要深入探讨的内容，让你一窥内存层次结构的另一层级。

## 挑战

### 从内存加载

从程序的角度看，计算机内存是一个存储数据的巨大空间。
就像街道上的房屋一样，内存的每个部分都有一个数字*地址*，并且这些数字（大部分）是连续的。
现代计算机拥有海量内存，而典型现代程序的内存视图实际上存在大量空隙（可以理解为：街道上尚未建造房屋的区域，因此这些地址被跳过）。
但这些都只是细节：关键在于，计算机将数据（主要是顺序地）存储在内存中。

在本关卡中，我们将练习访问存储在内存中的数据。
我们该如何做到这一点？
回想一下，要将一个值移入寄存器，我们曾执行类似这样的操作：

```assembly
mov rdi, 31337
```

执行后，`rdi` 的值变为 `31337`。
很好。
那么，我们可以使用相同的指令来访问内存！
该指令有另一种格式，它将第二个参数用作要访问的内存地址！
假设我们的内存布局如下：

```text
  Address │ Contents
+────────────────────+
│ 31337   │ 42       │
+────────────────────+
```

要访问内存地址 31337 处的内容，你可以这样做：

```assembly
mov rdi, [31337]
```

当 CPU 执行此指令时，它当然理解 `31337` 是一个*地址*，而不是原始值。
如果你将指令想象成一个人告诉 CPU 该做什么，并且沿用我们的"街道房屋"类比，那么指令/人并不是直接递给 CPU 数据，而是*指向街道上的一栋房屋*。
CPU 随后会前往该地址，按响门铃，打开前门，将里面的数据拖出来，并将其放入 `rdi`。
因此，此上下文中的 `31337` 是*内存地址*，用于*指向*存储在该内存地址的数据。
此指令执行后，存储在 `rdi` 中的值将是 `42`！

让我们将其付诸实践！
我已经将一个秘密数字存储在内存地址 `133700` 处，如下所示：

```text
  Address │ Contents
+────────────────────+
│ 133700  │ ???      │
+────────────────────+
```

你必须检索这个秘密数字，并将其用作程序的退出代码。
为此，你必须将其读入 `rdi`，如果你还记得的话，`rdi` 的值是 `exit` 的第一个参数，并被用作退出代码。
祝你好运！

----

*注意*：要解决此挑战，你必须将输出的可执行二进制文件或汇编代码 `.s` 文件传递给 `/challenge/check`。

### 更多加载练习

### 指针解引用

### 自主解引用

### 带偏移量的解引用

### 存储的地址

### 双重解引用

### 三重解引用
