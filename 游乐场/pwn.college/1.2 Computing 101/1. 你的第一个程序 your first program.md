# 你的第一个程序

计算机运行*计算机程序*以实现不同的目标。一个程序可能是你最喜欢的视频游戏，另一个是你用来访问此网站的网页浏览器，等等。

一个程序由*计算机代码*组成，而这些代码则由大量单独的*指令*构成，这些指令促使计算机进行计算，并根据计算结果执行特定操作。每条单独的指令通常非常简单，只有在组合起来时，它们才能实现诸如让你浏览互联网上的表情包之类酷炫的功能。

这些计算由*中央处理器*（CPU）完成，并与你计算机内的其他硬件协同工作。这些指令通过一种称为*汇编语言*的代码形式指定给CPU，而每种CPU架构都会使用不同风格的汇编语言。无论程序最初是用哪种语言（例如，C、C++、Java、Python等）编写的，最终都会被转换为或解释为汇编指令。

pwn.college的大部分内容都使用[x86 CPU架构](https://en.wikipedia.org/wiki/x86)，这也是zardus最喜欢的架构。x86是由Intel在个人电脑时代初期创建的，并且多年来一直在不断演进。x86与ARM（一种不同的、相对没那么酷的架构）共同构成了当前PC CPU的主流。

在本模块中，我们将从可以想象的最简单的x86程序开始，用x86汇编语言编写它，并在此基础上逐步扩展！让我们开始吧，编写你的第一个程序！

## Challenge

### 你的第一个寄存器（Register）

CPU 的思维方式非常简单。它移动数据、更改数据、根据数据做出决策，并根据数据采取行动。大多数时候，这些数据存储在*寄存器*中。

简而言之，寄存器是数据的容器。CPU 可以将数据放入寄存器、在寄存器之间移动数据等等。这些寄存器在硬件层面是通过非常昂贵的芯片实现的，被压缩在极其微小的空间内，并以连光速等物理概念都会影响其性能的频率进行访问。因此，CPU 所能拥有的寄存器数量*极其*有限。

不同的 CPU 架构拥有不同数量的寄存器、不同的寄存器名称等等，但通常有 10 到 20 个"通用"寄存器可供程序代码随意使用，此外还有最多几十个用于特殊目的的寄存器。在 x86 的现代版本 x86_64 中，程序可以访问 16 个通用寄存器。在本挑战中，我们将了解第一个寄存器：`rax`。

你好，rax！`rax` 只是 x86 CPU 极其复杂设计中的一个小部件，但我们将从这里开始。与其他寄存器一样，`rax` 是一个用于存储少量数据的容器。您可以使用 `mov` 指令将数据*移动*到 `rax` 中。指令被指定为一个*操作符`mov`）和*操作数`rax` 作为目标，以及我们想要存储在那里的值）。例如，如果您想将值 `1337` 存储到 `rax` 中，x86 汇编代码将如下所示：

```assembly
mov rax, 1337
```

您可以观察到几点：
1.  目标 `rax`）在源 `1337`）*之前*指定。
2.  操作数之间用逗号分隔。
3.  它*真的*很简单！

在本挑战中，您将编写您的第一个汇编程序。您必须将值 `60` 移动到 `rax` 中。请将您的程序写入扩展名为 `.s` 的文件中，例如 `rax-challenge.s`（虽然不是强制要求，但 `.s` 是汇编文件的典型扩展名），并将其作为参数传递给 `/challenge/check` 文件（例如 `/challenge/check rax-challenge.s`）。您可以使用您喜欢的文本编辑器或 pwn.college 的 VSCode 工作空间中的文本编辑器来实现您的 `.s` 文件！

----

**勘误：** 如果您以前见过 x86 汇编，您可能见过稍微不同的语法变体。pwn.college 使用的是"Intel 语法"，这是编写 x86 汇编的正确方式（提醒一下，Intel 创造了 x86）。有些课程错误地教授使用"AT&T 语法"，这造成了巨大的混淆。我们将在下一个模块中稍微提及这一点，然后希望再也不用考虑 AT&T 语法了。

### 你的第一个系统调用（Syscall）

所以，你的第一个程序崩溃了...
别担心，这很常见！
在本挑战中，你将学习如何让程序正常退出而不是崩溃。

启动程序和正常停止程序是由计算机的*操作系统*处理的操作。
操作系统管理程序的存在以及程序与你的硬件、网络环境等之间的交互。

你的程序使用汇编指令（例如你之前编写的 `mov` 指令）来与 CPU "交互"。
类似地，你的程序使用 `syscall`（即*系统调用*指令）来与操作系统交互（当然是通过 CPU）。

就像你可能通过打电话与当地餐厅互动点餐一样，程序使用系统调用来请求操作系统代表程序执行操作。
稍微过度概括一下，你的程序所做的任何不涉及对数据进行计算的事情，都是通过系统调用完成的。

你的程序可以调用许多不同的系统调用。
例如，Linux 有大约 330 个不同的系统调用，尽管这个数字会随着系统调用的添加和弃用而随时间变化。
每个系统调用由一个*系统调用号*（从 0 开始向上计数）来指示，你的程序通过将其系统调用号移动到 `rax` 寄存器并调用 `syscall` 指令来调用特定的系统调用。
例如，如果我们想调用系统调用 42（一个你稍后会了解的系统调用！），我们会编写两条指令：

```assembly
mov rax, 42
syscall
```

非常酷，而且超级简单！

在本挑战中，我们将学习我们的第一个系统调用：`exit`。
`exit` 系统调用使程序退出。
通过显式退出，我们可以避免之前程序遇到的崩溃！

现在，`exit` 的系统调用号是 `60`。
去编写你的第一个程序吧：它应该将 `60` 移动到 `rax` 中，然后调用 `syscall` 来正常退出！

### 退出码（Exit Codes）

如您所知，每个程序在终止时都会带有一个*退出码*。这是通过向 `exit` 系统调用传递参数实现的。类似于系统调用号（例如 `exit` 对应 `60`）被指定在 `rax` 变量中，参数也通过寄存器传递给系统调用。系统调用可以接受多个参数，但 `exit` 仅接受一个参数：退出码。系统调用的第一个参数通过另一个寄存器 `rdi` 传递。`rdi` 是本挑战中我们将重点关注的寄存器。

在本挑战中，您必须使程序以 `42` 作为退出码退出。因此，您的程序需要三条指令：
1. 设置程序的退出码（将其移入 `rdi`）。
2. 设置 `exit` 系统调用的系统调用号（`mov rax, 60`）。
3. 执行 `syscall`！

现在，开始行动吧！

### 构建可执行文件（Building Executables）

那么您已经编写了第一个程序？
但到目前为止，我们还未处理将其实际构建成CPU可运行可执行文件的过程。
在本挑战中，*您*将亲自构建它！

要构建可执行二进制文件，您需要：

1. 将汇编代码写入文件（通常使用 `.S` 或 `.s` 后缀。本例中将使用 `program.s`）。
2. 将汇编文件汇编成*目标文件*（使用 `as` 命令）。
3. 将一个或多个可重定位目标文件链接成最终的可执行二进制文件（使用 `ld` 命令）！

让我们逐步进行：

**编写汇编代码。**
汇编文件包含的就是您的汇编代码。
对于前一关卡，代码可能如下：

```sh
hacker@dojo:~$ cat program.s
mov rdi, 42
mov rax, 60
syscall
hacker@dojo:~$
```

但它还需要包含*稍多一些信息*。
我们提到在本课程中使用的是*Intel*汇编语法，我们需要让汇编器知晓这一点。
您可以通过在汇编代码开头添加一条伪指令来实现，如下所示：

```sh
hacker@dojo:~$ cat program.s
.intel_syntax noprefix
mov rdi, 42
mov rax, 60
syscall
hacker@dojo:~$
```

`.intel_syntax noprefix` 告诉汇编器您将使用Intel汇编语法，特别是无需为每条指令添加额外前缀的变体。
它实际上不是一条x86指令（如 `mov` 和 `syscall`），因此不会出现在最终的可执行二进制文件中或在CPU上运行。
我们将在后续讨论其他伪指令，目前先让汇编器自行处理！

**将汇编代码汇编成目标文件。**
接下来，我们将汇编代码。
这是使用汇编器 `as` 完成的，如下所示：

```sh
hacker@dojo:~$ ls
program.s
hacker@dojo:~$ cat program.s
.intel_syntax noprefix
mov rdi, 42
mov rax, 60
syscall
hacker@dojo:~$ as -o program.o program.s
hacker@dojo:~$ ls
program.o   program.s
hacker@dojo:~$
```

此处，`as` 工具读取 `program.s`，将其汇编成二进制代码，并输出一个名为 `program.o` 的*目标文件*。
此目标文件包含实际汇编后的二进制代码，但尚未准备好运行。
首先，我们需要*链接*它。

**将目标文件链接成可执行文件。**
在典型的开发工作流中，源代码被编译，汇编代码被汇编成目标文件，通常会有多个这样的文件（通常，程序中的每个源代码文件会编译成其自己的目标文件）。
然后将它们*链接*在一起形成一个可执行文件。
即使只有一个文件，我们仍然需要链接它，以准备最终的可执行文件。
这是通过 `ld`（源自术语"链接编辑器"）命令完成的，如下所示：

```sh
hacker@dojo:~$ ls
program.o   program.s
hacker@dojo:~$ ld -o program program.o
ld: warning: cannot find entry symbol _start; defaulting to 0000000000401000
hacker@dojo:~$ ls
program.o   program.s   program
hacker@dojo:~$
```

这将创建一个名为 `program` 的文件，然后我们就可以运行它了！
运行结果如下：

```sh
hacker@dojo:~$ ./program
hacker@dojo:~$ echo $?
42
hacker@dojo:~$
```

在shell中，`$?` 保存了上一个执行命令的退出码。

很好！
现在您可以构建程序了。
在本挑战中，请亲自运行这些步骤。
构建您的可执行文件，并将其传递给 `/challenge/check` 以获取flag！

----

**\_start？**
细心的学习者可能已经注意到 `ld` 打印了一个关于 `entry symbol _start` 的警告。
`_start` 符号本质上是给 `ld` 的一个说明，指出当ELF文件被执行时，程序执行应从何处开始。
该警告表明，在未指定 `_start` 的情况下，执行将从代码的开头开始。
这对我们来说完全没问题！

如果您想消除此错误，可以在代码中指定 `_start` 符号，如下所示：

```sh
hacker@dojo:~$ cat program.s
.intel_syntax noprefix
.global _start
_start:
mov rdi, 42
mov rax, 60
syscall
hacker@dojo:~$ as -o program.o program.s
hacker@dojo:~$ ld -o program program.o
hacker@dojo:~$ ./program
hacker@dojo:~$ echo $?
42
hacker@dojo:~$
```

这里多了两行代码。
第二行 `_start:` 添加了一个名为 `_start` 的*标签*，指向您代码的开头。
第一行 `.global _start` 指示 `as` 使 `_start` 标签在链接器级别*全局可见*，而不仅仅在目标文件级别局部可见。
由于 `ld` 是链接器，此伪指令对于 `_start` 标签被链接器看到是必要的。

对于本道场中的所有挑战，从文件开头开始执行完全没问题，但如果您不想看到这些警告出现，现在您知道如何避免它们了！
- 执行汇编与链接后将可执行文件名传递到 /challenge/check

### 寄存器间数据移动（Moving Between Registers）

好的，让我们再学习一个寄存器：`rsi`！
与 `rdi` 类似，`rsi` 是一个可以存放数据的位置。
例如：

```assembly
mov rsi, 42
```

当然，您也可以在寄存器之间移动数据！
请看：

```assembly
mov rsi, 42
mov rdi, rsi
```

就像第一行将 `42` 移动到 `rsi` 中一样，第二行将 `rsi` 中的值移动到 `rdi`。
这里，我们必须提及一个复杂之处：通过*移动*，我们实际指的是*设置*。
在上述代码片段执行后，`rsi`*和*`rdi` 都将为 `42`。
至于为什么选择 `mov` 而不是像 `set` 这样合理的名称（即使知识渊博的人在回答时也诉诸于[大胆推测](https://retrocomputing.stackexchange.com/questions/12968/why-is-the-processor-instruction-called-move-not-copy)），这仍是个谜，但事实如此。

无论如何，开始挑战吧！
在本挑战中，我们将把一个秘密值存储在 `rsi` 寄存器中，您的程序必须将该值作为退出码退出。
由于 `exit` 使用存储在 `rdi` 中的值作为退出码，您需要将 `rsi` 中的秘密值移动到 `rdi` 中。
运行 `/challenge/check` 并将您的代码传递给它以获取flag！`/challenge/check` 将在运行您的代码之前在 `rsi` 中设置秘密值。
祝您好运！
- 传递 `rsi` 寄存器的秘密值到 `exit` 系统调用的唯一参数寄存器 `rdi` 中作为退出码