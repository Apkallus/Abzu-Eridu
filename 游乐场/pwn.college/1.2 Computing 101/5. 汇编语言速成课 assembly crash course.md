# 汇编语言速成课

既然你已经掌握了非常基础的汇编知识，让我们深入探索一些不同的指令和附加概念！《汇编语言速成教程》将带你领略汇编语言中各种可能实现的功能，为接下来的冒险之旅做好准备！要交互任何关卡，你可以选择将可执行文件作为参数运行挑战（例如 `/challenge/run /path/to/your/elf`），或通过标准输入向该程序发送原始字节。

## 材料

### 提示 - 调试汇编代码

这些挑战使用 Python 编写，并在模拟器中运行你的汇编代码。
这意味着你无法使用常规调试工具（如 `gdb`）来调试挑战。不过，我们为这些挑战添加了特殊的调试功能：当模拟器在执行你的汇编代码时遇到 `int3` 指令，将会打印出当前寄存器和内存的状态。这对于分析代码逻辑非常有帮助！

### 扩展阅读

- [LiveOverflow](https://www.youtube.com/watch?v=iyAyN3GFM7A&list=PLhixgUqwRTjxglIswKp9mpkfPNfHkzyeN&index=1) 超棒的入门系列，涵盖部分基础知识。
- [*Ike: The Systems Hacking Handbook*](https://ike.mahaloz.re/1_introduction/introduction.html)，计算机组织的绝佳指南。
- 涵盖多种架构的[综合汇编教程](https://github.com/mytechnotalent/Reverse-Engineering-Tutorial)（此处相关架构为 amd64）。
- OpenSecurityTraining2 的课程 [*Architecture 1001: x86-64 Assembly*](https://ost2.fyi/Arch1001)。
- 助你学习的完整 [x86_64 汇编书籍](https://open.umn.edu/opentextbooks/textbooks/733)。
- 通过[游戏](https://squallygame.com/)学习 x86 汇编，以及[检验知识掌握度](https://oooverflow.io/zero-is-you/)的游戏。
- x86 前缀和转义操作码的[流程图](https://soc.me/interfaces/x86-prefixes-and-escape-opcodes-flowchart)。
- 非官方但极其详实实用的 [x86 指令参考](https://www.felixcloutier.com/x86/)。

## 挑战练习

### 设置寄存器

在本关卡中，你将需要处理寄存器操作。系统会要求你修改或读取寄存器中的值。

在本关卡中，你将进行寄存器操作！请完成以下设置：

`rdi = 0x1337`

- 传递编译或链接的程序（.o目标文件 或 可执行文件），作为挑战目录的程序的参数。
    或使用 `objcopy` 导出裸二进制

### 设置多寄存器

在本关卡中，你将需要处理寄存器操作。系统会要求你修改或读取寄存器中的值。
在本关卡中，你将进行多个寄存器的操作！请完成以下设置：
- `rax = 0x1337`
- `r12 = 0xCAFED00D1337BEEF`
- `rsp = 0x31337`

### 寄存器加法

在本关卡中，你将需要处理寄存器操作。系统会要求你修改或读取寄存器中的值。

每次运行前，我们将动态地在内存中设置一些数值。这些值会在每次运行时发生变化，这意味着你需要使用寄存器执行某些公式化运算。我们会提前告知哪些寄存器已被设置，以及结果应存放的位置（多数情况下是 `rax`）。

x86 架构包含多种指令，可支持对寄存器和内存执行所有常规数学运算。

为简化表述，当我们使用 `A += B` 时，实际含义为 `A = A + B`。

以下是一些实用指令：
- `add reg1, reg2` ⇔ `reg1 += reg2`
- `sub reg1, reg2` ⇔ `reg1 -= reg2`
- `imul reg1, reg2` ⇔ `reg1 *= reg2`

`div` 指令较为复杂，我们将在后续讨论。注意：所有 `regX` 均可替换为常量或内存地址。

请执行以下操作：
- 将 `0x331337` 加到 `rdi` 中

### 线性方程寄存器操作

在本关卡中，您将学习处理寄存器操作。您需要修改或读取寄存器中的值。每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器进行某种公式化运算。我们将提前告知哪些寄存器已被赋值，以及结果应存放的位置（多数情况下是 `rax`）。

请运用所学知识计算以下公式：
- `f(x) = mx + b`, 其中:
  - `m = rdi`
  - `x = rsi`
  - `b = rdx`

将计算结果存入 `rax`。

注意：无符号乘法 `mul` 与有符号乘法 `imul` 在使用寄存器时存在重要差异。请查阅相关指令文档以了解区别。本例中需使用 `imul`。

### 整数除法

在本关卡中，您将学习处理寄存器操作。您需要修改或读取寄存器中的值。

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值，以及结果应存放的位置（通常是 `rax`）。

x86 架构中的除法运算比常规数学中的除法更为特殊。此处的数学运算称为整数运算，意味着每个值都是整数。

例如：在整数运算中，`10 / 3 = 3`。

为什么？

因为 `3.33` 会被向下取整为整数。

本关卡涉及的相关指令包括：
- `mov rax, reg1`
- `div reg2`

注意：`div` 是一条特殊指令，它可以用一个寄存器作为操作数，将 128 位被除数除以 64 位除数，同时存储商和余数。

这条复杂的 `div` 指令如何操作 128 位被除数（其大小是寄存器的两倍）？

对于指令 `div reg`，会发生以下操作：
- `rax = rdx:rax / reg`
- `rdx = 余数`

`rdx:rax` 表示 `rdx` 作为 128 位被除数的高 64 位，`rax` 作为低 64 位。

在调用 `div` 前，必须注意 `rdx` 和 `rax` 中的当前值。

请计算以下公式：
- `speed = distance / time`, 其中:
  - `distance = rdi`
  - `time = rsi`
  - `speed = rax`

注意：*distance* 最多为 64 位值，因此进行除法运算时 `rdx` 应设置为 0。

### 模运算

在本关卡中，您将学习处理寄存器操作。您需要修改或读取寄存器中的值。

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行公式化运算。我们将提前告知哪些寄存器已被赋值，以及结果应存放的位置（多数情况下是 `rax`）。

汇编中的模运算是另一个有趣的概念！

x86 架构允许您在 `div` 操作后获取余数。

例如：`10 / 3` 的余数为 `1`。

余数即等同于模运算，也称为 "mod" 运算符。

在大多数编程语言中，我们使用符号 `%` 表示模运算。

请计算以下表达式：`rdi % rsi`

将结果存入 `rax`。

### 设置高位字节

在本关卡中，您将学习处理寄存器操作。您需要修改或读取寄存器中的值。

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值，以及结果应存放的位置（通常为 `rax`）。

x86 架构中另一个很酷的概念是能够独立访问寄存器的低位字节。

x86_64 架构中每个寄存器的大小为 64 位，在之前的关卡中，我们使用 `rax`、`rdi` 或 `rsi` 来访问完整的寄存器。

我们还可以通过不同的寄存器名称来访问每个寄存器的低位字节。
例如：`rax` 的低 32 位可通过 `eax` 访问，低 16 位通过 `ax` 访问，低 8 位通过 `al` 访问。

```
MSB                                    LSB
+----------------------------------------+
|                   rax                  |
+--------------------+-------------------+
                     |        eax        |
                     +---------+---------+
                               |   ax    |
                               +----+----+
                               | ah | al |
                               +----+----+
```

低位寄存器字节访问几乎适用于所有寄存器。
请仅使用一条移动指令，将 `ax` 寄存器的高 8 位设置为 `0x42`。

### 高效模运算

在本关卡中，您将学习处理寄存器操作。您需要修改或读取寄存器中的值。

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

事实证明，使用 `div` 运算符计算模运算速度较慢！

我们可以使用数学技巧来优化模运算符（`%`）。编译器经常使用这种技巧。

如果存在 `x % y`，且 `y` 是 2 的幂次方（例如 `2^n`），则结果将是 `x` 的低 `n` 位。

因此，我们可以利用低位寄存器字节访问来高效实现模运算！

请仅使用以下指令：
- `mov`

计算以下表达式：
- `rax = rdi % 256`
    - 2^8
    - al, dil
- `rbx = rsi % 65536`
    - 2^16
    - bx, si


### 字节提取

在本关卡中，您将学习处理寄存器操作。您需要修改或读取寄存器中的值。

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习位逻辑与操作。这将涉及大量直接与寄存器或内存位置中存储的位进行交互。您可能还需要使用 x86 中的逻辑指令：`and`、`or`、`not`、`xor`。

汇编中的位移操作是另一个有趣的概念！

x86 允许您在寄存器中“移动”位。

例如，以 `al`（`rax` 的最低 8 位或*最低有效* 8 位）为例。
`al` 中的值（以位表示）为：

```
al = 10001010
```

如果我们使用 `shl` 指令向左移动一次：

```
shl al, 1
```

新值为：

```
al = 00010100
```

所有位向左移动，最高位（或*最高有效*位）被移出，同时在右侧添加了一个新的 0。
您可以利用这一点对您关心的位进行特殊操作。

位移的一个额外好处是可以实现快速乘法（乘以 2）或除法（除以 2），还可用于计算模运算。
以下是重要指令：
- `shl reg1, reg2` <=> 将 `reg1` 左移 `reg2` 指定的位数
- `shr reg1, reg2` <=> 将 `reg1` 右移 `reg2` 指定的位数

注意：“reg2” 可由常量或内存位置替代。

当我们提到*有效位*或*最低有效字节*时，“有效” 意为“对数值最重要”。
- *最低有效位/字节* 的权重最小（最低位值）。例如，当您修改“最低”或“最右侧”位时，数值仅改变 1。
- *最高有效位/字节* 的权重最大（最高位值）。

**对于本挑战**，请仅使用以下指令：
- `mov`、`shr`、`shl`

请执行以下操作：
将 `rax` 设置为 `rdi` 的第 5 个最低有效字节。
例如：

```
rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |
Set rax to the value of B4
```

### 位与运算

在本关卡中，您将学习处理寄存器操作。您需要修改或读取寄存器中的值。

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习位逻辑与操作。这将涉及大量直接与寄存器或内存位置中存储的位进行交互。您可能还需要使用 x86 中的逻辑指令：`and`、`or`、`not`、`xor`。

汇编中的位逻辑操作是另一个有趣的概念！x86 允许您对寄存器执行逐位逻辑运算。

以此示例为例，假设寄存器仅存储 8 位。
`rax` 和 `rbx` 中的值分别为：
- `rax = 10101010`
- `rbx = 00110011`

如果我们使用 `and rax, rbx` 指令对 `rax` 和 `rbx` 执行按位 AND 运算，结果将通过逐对进行 AND 运算得出，因此称为位逻辑运算。

从左到右依次计算：
- 1 AND 0 = 0
- 0 AND 0 = 0
- 1 AND 1 = 1
- 0 AND 1 = 0
- ...

最终将结果组合得到：
- `rax = 00100010`

以下为参考真值表：
- **AND**

    ```
    A | B | X
    ---+---+---
    0 | 0 | 0
    0 | 1 | 0
    1 | 0 | 0
    1 | 1 | 1
    ```

- **OR**

    ```
    A | B | X
    ---+---+---
    0 | 0 | 0
    0 | 1 | 1
    1 | 0 | 1
    1 | 1 | 1
    ```

- **XOR**

    ```
    A | B | X
    ---+---+---
    0 | 0 | 0
    0 | 1 | 1
    1 | 0 | 1
    1 | 1 | 0
    ```

请在不使用以下指令的情况下：`mov`、`xchg`
执行以下操作：
将 `rax` 设置为 `(rdi AND rsi)` 的值

----
**注意：**
`rax` 的所有位将被设置为 `1`
否则本关卡将更具挑战性！

### 偶数检测

在本关卡中，您将学习处理寄存器操作。您需要修改或读取寄存器中的值。
每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习位逻辑与操作。这将涉及大量直接与寄存器或内存位置中存储的位进行交互。您可能还需要使用 x86 中的逻辑指令：`and`、`or`、`xor`。

请仅使用以下指令：
- `and`
- `or`
- `xor`

实现以下逻辑：

```plaintext
if x is even then
  y = 1
else
  y = 0
```

其中：
- `x = rdi`
- `y = rax`
- 取最低位，根据奇偶数返回值调整

### 内存读取

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习内存操作。这将要求您读取或写入线性存储在内存中的数据。如有困惑，请查看 'ike 中的线性寻址模块。您可能还需要进行解引用操作（可能多次解引用），以访问我们动态放入内存供您使用的数据。

迄今为止，您一直将寄存器作为存储数据的唯一方式，本质上类似于数学中的变量（如 'x'）。

但我们也可以将字节存储到内存中！

请回忆，内存是可寻址的，每个地址都包含该位置存储的内容。注意这与现实生活中的地址类似！

例如：真实地址 '699 S Mill Ave, Tempe, AZ 85281' 对应 'ASU Brickyard'。我们也可以说它指向 'ASU Brickyard'。我们可以这样表示：

```
['699 S Mill Ave, Tempe, AZ 85281'] = 'ASU Brickyard'
```

地址的特殊性在于其唯一性。但这并不意味着其他地址不能指向同一事物（就像一个人可以拥有多处房产）。

内存完全同理！

例如，您的代码存储的内存地址（当我们从您那里获取时）是 `0x400000`。

在 x86 中，我们可以访问内存位置存储的内容（称为解引用），如下所示：

```
mov rax, [some_address]        <=>     Moves the thing at 'some_address' into rax
```

此操作同样适用于寄存器中的地址：

```
mov rax, [rdi]         <=>     Moves the thing stored at the address of what rdi holds to rax
```

写入内存的操作原理相同：

```
mov [rax], rdi         <=>     Moves rdi to the address of what rax holds.
```

因此，如果 `rax` 的值为 `0xdeadbeef`，则 `rdi` 的值将被存储到地址 `0xdeadbeef`：

```
[0xdeadbeef] = rdi
```

注意：内存是线性的，在 x86_64 架构中，其地址范围从 `0` 到 `0xffffffffffffffff`（是的，非常庞大）。

请执行以下操作：将地址 `0x404000` 存储的值放入 `rax`。确保 `rax` 中的值是 `0x404000` 处存储的原始值。

### 内存写入

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习内存操作。这将要求您读取或写入线性存储在内存中的数据。如有困惑，请查看 'ike 中的线性寻址模块。您可能还需要进行解引用操作（可能多次解引用），以访问我们动态放入内存供您使用的数据。

请执行以下操作：
将 `rax` 中存储的值存入地址 `0x404000`。

### 内存递增

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习内存操作。这将要求您读取或写入线性存储在内存中的数据。如有困惑，请查看 'ike 中的线性寻址模块。您可能还需要进行解引用操作（可能多次解引用），以访问我们动态放入内存供您使用的数据。

请执行以下操作：
- 将地址 `0x404000` 存储的值放入 `rax`
- 将地址 `0x404000` 存储的值增加 `0x1337`

确保 `rax` 中的值是 `0x404000` 处存储的原始值，并确保 `[0x404000]` 现在包含增加后的值。

### 字节访问

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习内存操作。这将要求您读取或写入线性存储在内存中的数据。如有困惑，请查看 'ike 中的线性寻址模块。您可能还需要进行解引用操作（可能多次解引用），以访问我们动态放入内存供您使用的数据。

请回忆，x86_64 架构中的寄存器宽度为 64 位，这意味着它们可存储 64 位数据。类似地，每个内存位置均可被视为 64 位值。我们将 64 位（8 字节）的数据称为四字。

以下是内存大小名称的细分：
- 四字 = 8 字节 = 64 位
- 双字 = 4 字节 = 32 位
- 字 = 2 字节 = 16 位
- 字节 = 1 字节 = 8 位

在 x86_64 中，解引用地址时可访问这些不同大小的数据，如同使用不同大小的寄存器访问方式：
- `mov al, [address]` <=> 将地址处的*最低有效*字节移动到 `rax`
- `mov ax, [address]` <=> 将地址处的*最低有效*字移动到 `rax`
- `mov eax, [address]` <=> 将地址处的*最低有效*双字移动到 `rax`
- `mov rax, [address]` <=> 将地址处的完整四字移动到 `rax`

请注意：向 `al` 移动数据不会完全清除高位字节。

请执行以下操作：
将 `rax` 设置为 `0x404000` 地址处的字节。

### 内存大小访问

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习内存操作。这将要求您读取或写入线性存储在内存中的数据。如有困惑，请参考 'ike 中的线性寻址模块。您可能还需要进行解引用操作（可能多次解引用），以访问我们动态放入内存供您使用的数据。

请回忆以下内容：

- 内存大小名称的细分：
  - 四字 = 8 字节 = 64 位
  - 双字 = 4 字节 = 32 位
  - 字 = 2 字节 = 16 位
  - 字节 = 1 字节 = 8 位

在 x86_64 中，解引用地址时可访问这些不同大小的数据，如同使用不同大小的寄存器访问方式：

- `mov al, [address]` <=> 将地址处的*最低有效*字节移动到 `rax`
- `mov ax, [address]` <=> 将地址处的*最低有效*字移动到 `rax`
- `mov eax, [address]` <=> 将地址处的*最低有效*双字移动到 `rax`
- `mov rax, [address]` <=> 将地址处的完整四字移动到 `rax`

请执行以下操作：

- 将 `rax` 设置为 `0x404000` 地址处的字节
- 将 `rbx` 设置为 `0x404000` 地址处的字
- 将 `rcx` 设置为 `0x404000` 地址处的双字
- 将 `rdx` 设置为 `0x404000` 地址处的四字

### 小端模式写入

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习内存操作。这将要求您读取或写入线性存储在内存中的数据。如有困惑，请查看 'ike 中的线性寻址模块。您可能还需要进行解引用操作（可能多次解引用），以访问我们动态放入内存供您使用的数据。

值得注意的是，您可能已经发现，数值的存储顺序与我们表示它们的顺序相反。
例如，假设：

```
[0x1330] = 0x00000000deadc0de
```

如果您检查其在内存中的实际存储形式，将会看到：

```
[0x1330] = 0xde
[0x1331] = 0xc0
[0x1332] = 0xad
[0x1333] = 0xde
[0x1334] = 0x00
[0x1335] = 0x00
[0x1336] = 0x00
[0x1337] = 0x00
```

这种“反向”存储格式在 x86 中是刻意设计的，称为“小端序”。
在本挑战中，我们将为您提供两个每次动态生成的地址。
第一个地址将存入 `rdi`。
第二个地址将存入 `rsi`。

利用前述信息，请执行以下操作：
- 设置 `[rdi] = 0xdeadbeef00001337`
- 设置 `[rsi] = 0xc0ffee0000`

提示：为解引用的寄存器赋值较大常量时可能需要一些技巧。可尝试先将常量值赋给某个寄存器，再将该寄存器赋给解引用的寄存器。

### 内存求和

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。
在本关卡中，您将学习内存操作。这将要求您读取或写入线性存储在内存中的数据。如有困惑，请查看 'ike 中的线性寻址模块。您可能还需要进行解引用操作（可能多次解引用），以访问我们动态放入内存供您使用的数据。

请回忆，内存是线性存储的。
这意味着什么？
假设我们访问地址 `0x1337` 处的四字：

```
[0x1337] = 0x00000000deadbeef
```

内存的实际布局方式是逐字节存储（小端序）：

```
[0x1337] = 0xef
[0x1337 + 1] = 0xbe
[0x1337 + 2] = 0xad
...
[0x1337 + 7] = 0x00
```

这种布局对我们有何用处？
这意味着我们可以使用偏移量来访问相邻的数据，类似于上文展示的方式。
假设您需要访问某个地址的第 5 个*字节*，可以通过以下方式访问：

```
mov al, [address+4]
```

请注意：偏移量从 0 开始计数。

请执行以下操作：
- 从 `rdi` 存储的地址处加载两个连续的四字
- 计算前一步骤中两个四字的总和
- 将总和存储到 `rsi` 存储的地址处

### 栈减法

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习栈操作——这是一个可动态扩展和收缩的内存区域。您需要读写栈数据，这可能要求您使用 `pop` 和 `push` 指令。您可能还需要通过栈指针寄存器（`rsp`）来获取栈的当前位置。

在这些关卡中，我们将介绍栈的概念。
栈是一个可用于临时存储数值的内存区域。

要将数值存入栈中，我们使用 `push` 指令；要取出数值，则使用 `pop` 指令。
栈采用后进先出（LIFO）的内存结构，这意味着最后压入的值将最先被弹出。

以从洗碗机中取出盘子为例：假设有红色、绿色、蓝色盘子各一个。我们先将红色盘子放入橱柜，接着将绿色盘子叠在红色上方，最后放上蓝色盘子。
此时盘子堆叠的状态如下：

```
Top ----> Blue
          Green
Bottom -> Red
```

若现在需要取盘子做三明治，我们会从栈顶取出最后放入的蓝色盘子，这正是后进先出的体现。

在 x86 架构中，`pop` 指令会从栈顶取出值并存入指定寄存器；
而 `push` 指令则会将寄存器中的值压入栈顶。

请运用这些指令：取出栈顶值，减去 `rdi` 的值，再将结果存回栈中。

### 交换栈值

每次运行前，我们会动态设置内存中的某些值。每次运行时这些值都会发生变化。这意味着您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习栈操作——这是一个可动态扩展和收缩的内存区域。您需要读写栈数据，这可能要求您使用 `push` 和 `pop` 指令。您可能还需要通过栈指针寄存器（`rsp`）来获取栈的当前位置。

在本关卡中，我们将探索栈的后进先出（LIFO）特性。

请仅使用以下指令：
- `push`
- `pop`

交换 `rdi` 和 `rsi` 中的值。

示例：
- 初始状态：`rdi = 2` 且 `rsi = 5`
- 最终状态：`rdi = 5` 且 `rsi = 2`

### 栈值求平均

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习栈操作——这是一个可动态扩展和收缩的内存区域。您需要读写栈数据，这可能要求您使用 `pop` 和 `push` 指令。您可能还需要通过栈指针寄存器（`rsp`）来获取栈的当前位置。

在前面的关卡中，您使用 `push` 和 `pop` 指令在栈中存储和加载数据。然而，您也可以直接通过栈指针访问栈。

在 x86 架构中，栈指针存储在特殊寄存器 `rsp` 中。`rsp` 始终存储栈顶的内存地址，即最后压入值的内存地址。

与内存关卡类似，我们可以使用 `[rsp]` 来访问 `rsp` 中内存地址处的值。
请在不使用 `pop` 指令的情况下，计算栈上存储的 4 个连续四字的平均值，并将该平均值压入栈中。

提示：
- `RSP+0x??` 四字 A
- `RSP+0x??` 四字 B
- `RSP+0x??` 四字 C
- `RSP` 四字 D
- 注，此处计算平均值而不是和

### 跳转到绝对地址，通过间接跳转

每次运行前，我们会动态设置内存中的某些值，这些值会随每次运行发生变化。因此您需要通过寄存器执行某种公式化运算。我们将提前告知哪些寄存器已被赋值以及结果应存放的位置。多数情况下为 `rax`。

在本关卡中，您将学习控制流操作。这涉及使用指令来间接或直接控制特殊寄存器 `rip`（指令指针）。您将使用 `jmp`、`call`、`cmp` 等指令及其变体来实现所需行为。

此前您学习了以伪控制方式操作数据，而 x86 为我们提供了直接操控控制流的实际指令。
控制流操作主要有两种方式：
- 通过跳转
- 通过调用

本关卡将重点讲解跳转操作。
跳转分为两种类型：
- 无条件跳转
- 条件跳转

无条件跳转始终触发，不依赖于先前指令的执行结果。
如您所知，内存位置可存储数据和指令。您的代码将存储在 `0x400042` 地址（该地址每次运行会变化）。

所有跳转指令可分为三种类型：
- 相对跳转：相对于下一条指令进行正向或负向跳转
- 绝对跳转：跳转到特定地址
- 间接跳转：跳转到寄存器指定的内存地址

在 x86 架构中，绝对跳转（跳转到特定地址）的实现方式是：先将目标地址加载到通用寄存器（暂称其为 `reg`），然后执行 `jmp reg`。

本关卡要求您执行绝对跳转。请完成以下操作：跳转到绝对地址 `0x403000`。
- 实际上是通过“间接跳转”实现的“绝对跳转”

### 相对跳转

在本关中，我们会在每次运行前动态地在内存中设置一些值。每次运行，这些值都会改变。这意味着你需要对寄存器执行某种“公式化”的运算。我们会告诉你在运行前哪些寄存器被设置好了，以及你应该把结果写到哪里。在大多数情况下，结果应放在 `rax` 中。

在本关中，你将处理控制流的操作。这涉及使用指令来间接或直接控制特殊寄存器 `rip`（指令指针）。你会使用诸如 `jmp`、`call`、`cmp` 以及它们的变体等指令来实现所要求的行为。

回顾一下，所有跳转大致分为三种类型：

- 相对跳转（Relative jumps）：从当前指令位置向前或向后跳转指定字节数。
- 绝对跳转（Absolute jumps）：跳转到某个固定的内存地址。
- 间接跳转（Indirect jumps）：跳转到寄存器或某个内存位置中存储的地址。

在本关中，我们重点关注相对跳转。这意味着你要告诉 CPU “从当前正在执行的位置向前跳转一定数量的字节”。这种方式非常有用，因为即使你的代码在内存中的位置发生变化，相对跳转仍然能够到达正确的目标位置。

要实现一个相对跳转，你需要用到以下几个工具：

- `labels`（标号）：你可以使用标号作为占位符，而无需手动计算地址。汇编器会自动计算你的跳转指令到该标号之间的偏移量。
- `nop`（No Operation，空操作）：一个单字节指令，本身不做任何事情。因为其大小可预测，可以作为填充，用来精确控制跳转距离。
- `.rept`（重复伪指令）：一种指示汇编器将给定指令重复多次的伪指令： [GNU Assembler Manual](https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html) 它非常适合用来生成一大段 `nop` 指令，而无需逐条手动输入。

    For example, assembling：
    ```
    .rept   3
    .long   0
    .endr
    ```
    
    is equivalent to assembling：
    ```
    .long   0
    .long   0
    .long   0
    ```

请完成以下操作：

- 让你的代码中的第一条指令是一个 `jmp`。
- 让这个 `jmp` 成为一个相对跳转，跳转距离恰好是从当前指令开始算起的 0x51 字节。
- 使用 `.rept` 指令，在跳转和目标位置之间用 `nop` 指令填充空间。
- 在相对跳转最终落到的标号处，将 `rax` 设为 0x1。

当你的代码运行时，CPU 会执行这条跳转指令，跳过所有的 `nop` 指令，并从设置 `rax` 的那条指令继续执行。这将展示如何通过相对跳转来控制程序的执行流。

### 跳转中转

我们现在将在每次运行前动态设置内存中的一些值。每次运行时，这些值都会改变。这意味着你需要使用寄存器执行某种公式化操作。我们会提前告知哪些寄存器已被设置，以及你应该将结果存放在何处。大多数情况下是 `rax`。

在本关卡中，你将进行*控制流操作*。这涉及使用指令来间接和直接控制特殊寄存器 `rip`（指令指针）。你将使用诸如 `jmp`、`call`、`cmp` 及其替代指令来实现要求的行为。

现在，我们将结合前两个关卡的内容执行以下操作：

- 创建一个两级跳转蹦床：
  - 让你代码中的第一条指令为 `jmp`。
  - 使该 `jmp` 成为相对于当前位置跳转 0x51 字节的*相对跳转*。
  - 在 0x51 地址处编写以下代码：
    - 将栈顶值存入寄存器 `rdi`。
    - 跳转到绝对地址 0x403000。
- `jmp .+2+数字` 可进行当前位置（`.`）的相对跳转，jmp本身占用2字节

### 条件跳转

在本关卡中，你将进行*控制流操作*。这涉及使用指令来间接和直接控制特殊寄存器 `rip`（指令指针）。你将使用诸如 `jmp`、`call`、`cmp` 及其替代指令来实现要求的行为。

我们将在本关卡中使用动态值多次测试你的代码！这意味着我们将以各种随机方式运行你的代码，以验证其逻辑是否足够健壮以应对正常使用场景。

现在我们将向你介绍条件跳转——x86架构中最有价值的指令之一。在高级编程语言中，存在if-else结构来实现如下功能：

```plaintext
if x is even:
    is_even = 1
else:
    is_even = 0
```

这看起来应该很熟悉，因为它仅通过位逻辑即可实现，这在你之前的关卡中已经实践过。在这些结构中，我们可以基于提供给程序的动态值来控制程序的执行流程。

使用跳转指令实现上述逻辑的方式如下：

```assembly
; assume rdi = x, rax is output
; rdx = rdi mod 2
mov rdx, 0
mov rax, rdi
mov rsi, 2
div rsi
; remainder is 0 if even
cmp rdx, 0
; jump to not_even code if it's not 0
jne not_even
; fall through to even code
mov rbx, 1
jmp done
; jump to this only when not_even
not_even:
mov rbx, 0
done:
mov rax, rbx
; more instructions here
```

但通常你需要的不仅仅是单个'if-else'结构。有时你需要两个if检查，后接一个else。要实现这一点，你需要确保控制流能在条件失败时"顺延"到下一个`if`。所有分支在执行后都必须跳转到相同的`done`标签以避免执行else分支。

x86中有多种跳转类型，了解其使用方法将很有帮助。几乎所有这些跳转都依赖于称为ZF（零标志）的寄存器。当`cmp`比较结果相等时ZF被设置为1，否则为0。

基于以上知识，请实现以下逻辑：

```plaintext
if [x] is 0x7f454c46:
    y = [x+4] + [x+8] + [x+12]
else if [x] is 0x00005A4D:
    y = [x+4] - [x+8] - [x+12]
else:
    y = [x+4] * [x+8] * [x+12]
```

其中：
- `x = rdi`, `y = rax`

假设每个解引用的值都是带符号的双字（dword）。这意味着每个内存位置的初始值可能为负数。

有效解决方案必须至少使用以下指令一次：
- `jmp`（任意变体）, `cmp`

注：本挑战只需进行32位运算，无需符号扩展到64位

### 间接跳转

在本关卡中，你将进行*控制流操作*。这涉及使用指令来间接和直接控制特殊寄存器 `rip`（指令指针）。你将使用诸如 `jmp`、`call`、`cmp` 及其替代指令来实现要求的行为。

我们将在本关卡中使用动态值多次测试你的代码！这意味着我们将以各种随机方式运行你的代码，以验证其逻辑是否足够健壮以应对正常使用场景。

最后一种跳转类型是*间接跳转*，在实际应用中常被用于 switch 语句。Switch 语句是 if 语句的一种特殊形式，仅使用数字来决定控制流的转向。
以下是一个示例：

```
switch(number):
  0: jmp do_thing_0
  1: jmp do_thing_1
  2: jmp do_thing_2
  default: jmp do_default_thing
```

此示例中的 switch 语句基于 `number` 变量工作，该变量的取值可能为 0、1 或 2。如果 `number` 不属于这些数值，则触发默认分支。你可以将其视为一种简化的 else-if 结构。在 x86 架构中，你已经习惯于使用数字，因此基于特定数值进行条件判断应该并不陌生。此外，如果你了解数字的取值范围，switch 语句会非常适用。
以跳转表为例：跳转表是一块连续的内存区域，其中存储了需要跳转的目标地址。
在上面的示例中，跳转表可能如下所示：

```
[0x1337] = address of do_thing_0
[0x1337+0x8] = address of do_thing_1
[0x1337+0x10] = address of do_thing_2
[0x1337+0x18] = address of do_default_thing
```

通过使用跳转表，我们可以大幅减少所需的 `cmp` 指令数量。现在只需检查 `number` 是否大于 2。如果是，则执行：

```
jmp [0x1337+0x18]
```

否则：

```
jmp [jump_table_address + number * 8]
```

基于以上知识，请实现以下逻辑：

```plaintext
if rdi is 0:
  jmp 0x40301e
else if rdi is 1:
  jmp 0x4030da
else if rdi is 2:
  jmp 0x4031d5
else if rdi is 3:
  jmp 0x403268
else:
  jmp 0x40332c
```

请遵循以下约束条件完成实现：
- 假设 `rdi` 的值不会为负数
- 最多使用 1 条 `cmp` 指令
- 最多使用 3 条跳转指令（任意类型）
- 我们将通过 `rdi` 寄存器提供需要判断的数值
- 我们将通过 `rsi` 寄存器提供跳转表的基地址

以下是一个示例表：

```
[0x40427c] = 0x40301e (addrs will change)
[0x404284] = 0x4030da
[0x40428c] = 0x4031d5
[0x404294] = 0x403268
[0x40429c] = 0x40332c
```

注：
- 并非创建跳转表，而是使用挑战提供的跳转表基地址
- 条件跳转，只能跳到“代码标签”，不能跳到“内存里存着的地址”。

### 循环求平均

我们现在将在每次运行前动态设置内存中的一些值。每次运行时，这些值都会改变。这意味着你需要使用寄存器执行某种公式化操作。我们会提前告知哪些寄存器已被设置，以及你应该将结果存放在何处。大多数情况下是 `rax`。

在本关卡中，你将进行*控制流操作*。这涉及使用指令来间接和直接控制特殊寄存器 `rip`（指令指针）。你将使用诸如 `jmp`、`call`、`cmp` 及其替代指令来实现要求的行为。

在之前的关卡中，你计算了4个四字整数的平均值，这是一个固定数量的计算任务。但当程序运行时获取到数据规模时，该如何处理呢？

在大多数编程语言中，存在一种称为*for循环*的结构，它允许你有限次地执行一组指令。这个次数可以在程序运行前或运行期间确定，"运行期间"意味着该值是动态给定的。

例如，*for循环*可用于计算从1到n的数字之和：

```plaintext
sum = 0
i = 1
while i <= n:
    sum += i
    i += 1
```

请计算连续n个四字整数的平均值，其中：
- `rdi` = 第一个四字整数的内存地址
- `rsi` = `n`（需要循环的次数）
- `rax` = 计算得到的平均值

### 非零计数

在本关卡中，你将进行*控制流操作*。这涉及使用指令来间接和直接控制特殊寄存器 `rip`（指令指针）。你将使用诸如 `jmp`、`call`、`cmp` 及其替代指令来实现要求的行为。

我们将在本关卡中使用动态值多次测试你的代码！这意味着我们将以各种随机方式运行你的代码，以验证其逻辑是否足够健壮以应对正常使用场景。

在之前的关卡中，你已经了解了用于迭代特定*次数*的 for 循环，无论该次数是动态还是静态已知的，但当你希望迭代直到满足某个条件时该怎么办呢？

存在第二种循环结构，称为 *while 循环*（当型循环）来满足这一需求。在 while 循环中，你迭代直到满足某个条件。

例如，假设内存中有一个包含相邻数字的位置，我们想要获取所有数字的平均值，直到找到一个大于或等于 `0xff` 的数字：

```plaintext
average = 0
i = 0
while x[i] < 0xff:
  average += x[i]
  i += 1
average /= i
```

基于以上知识，请执行以下操作：

统计内存连续区域中连续的非零字节数，其中：
- `rdi` = 第一个字节的内存地址
- `rax` = 连续非零字节的数量

此外，如果 `rdi = 0`，则将 `rax` 设置为 0（我们会检查）！

一个测试示例如下，设：
- `rdi = 0x1000`
- `[0x1000] = 0x41`
- `[0x1001] = 0x42`
- `[0x1002] = 0x43`
- `[0x1003] = 0x00`

那么：应设置 `rax = 3`。

### 字符串小写转换

我们将在本关卡中使用动态值多次测试你的代码！这意味着我们将以各种随机方式运行你的代码，以验证其逻辑是否足够健壮以应对正常使用场景。

在本关卡中，你将处理*函数*！这将涉及操作指令指针（rip）以及执行比常规任务更复杂的操作。你可能会被要求使用栈来存储值或调用我们提供的函数。

在之前的关卡中，你实现了*while循环*来统计连续内存区域中连续非零字节的数量。

在本关卡中，你将再次获得一个连续内存区域，并循环遍历每个字节执行条件操作，直到遇到零字节为止。所有这些操作都将封装在一个函数中！

函数是一段可调用的代码片段，不会破坏控制流。

函数使用"call"和"ret"指令。

"call"指令将下一条指令的内存地址压入栈中，然后跳转到第一个参数中存储的值。

让我们以下列指令为例：

```
0x1021 mov rax, 0x400000
0x1028 call rax
0x102a mov [rsi], rax
```

1. `call` 将下一条指令的地址 `0x102a` 压入栈中
2. `call` 跳转到 `rax` 中存储的值 `0x400000`

"ret"指令与"call"指令相反。

`ret` 从栈顶弹出一个值并跳转到该地址。

让我们使用以下指令和栈状态为例：

```
                            Stack ADDR  VALUE
0x103f mov rax, rdx         RSP + 0x8   0xdeadbeef
0x1042 ret                  RSP + 0x0   0x0000102a
```

这里，`ret` 将跳转到 `0x102a`。

请实现以下逻辑：

```plaintext
str_lower(src_addr):
  i = 0
  if src_addr != 0:
    while [src_addr] != 0x00:
      if [src_addr] <= 0x5a:
        [src_addr] = foo([src_addr])
        i += 1
      src_addr += 1
  return i
```

`foo` 函数位于 `0x403000`。`foo` 接受一个值作为参数并返回一个值。

所有函数（`foo` 和 `str_lower`）都必须遵循 Linux amd64 调用约定（也称为 System V AMD64 ABI）：
[System V AMD64 ABI](https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI)

因此，你的 `str_lower` 函数应该在 `rdi` 中查找 `src_addr` 并将函数返回值放置在 `rax` 中。

需要注意的是，`src_addr` 是内存中的一个地址（字符串所在的位置），而 `[src_addr]` 指的是位于 `src_addr` 的字节。

因此，函数 `foo` 接受一个字节作为其第一个参数并返回一个字节。

### 最高频字节统计

我们将在本关卡中使用动态值多次测试你的代码！这意味着我们将以各种随机方式运行你的代码，以验证其逻辑是否足够健壮以应对正常使用场景。

在本关卡中，你将处理*函数*！这将涉及操作指令指针（`rip`）以及执行比常规任务更复杂的操作。你可能会被要求使用栈来存储值或调用我们提供的函数。

在之前的关卡中，你学习了如何创建自己的第一个函数以及如何调用其他函数。现在我们将处理具有*函数栈帧*的函数。

*函数栈帧*是一组被压入栈的指针和值，用于保存内容以备后用，并为函数变量在栈上分配空间。
首先，我们来谈谈特殊寄存器 `rbp`——*栈基指针*。

`rbp` 寄存器用于指示我们的栈帧最初开始的位置。举例来说，假设我们想要构造一个仅在函数内使用的列表（一段连续的内存空间）。该列表包含 5 个元素，每个元素是一个 `dword`。一个包含 5 个元素的列表会占用 5 个寄存器，因此，我们可以在栈上分配空间！

汇编代码可能如下所示：

```assembly
; setup the base of the stack as the current top
mov rbp, rsp
; move the stack 0x14 bytes (5 * 4) down
; acts as an allocation
sub rsp, 0x14
; assign list[2] = 1337
mov eax, 1337
mov [rbp-0xc], eax
; do more operations on the list ...
; restore the allocated space
mov rsp, rbp
ret
```

请注意 `rbp` 如何被用来将栈恢复到其原始位置。如果我们在使用后不恢复栈，最终将耗尽栈空间。此外，请注意我们是如何从 `rsp` 减去的，因为栈是向下增长的。为了给栈提供更多空间，我们减去所需的空间。`ret` 和 `call` 指令的工作方式保持不变。

考虑到要为 `list` 赋值，我们需要减去 12 个字节（3 个 dword）。这是因为栈向下增长，并且当我们移动 `rsp` 后，我们的栈包含地址 \<`rsp`, `rbp`\>。

请再次创建实现以下逻辑的函数：

```plaintext
most_common_byte(src_addr, size):
  i = 0
  while i <= size-1:
    curr_byte = [src_addr + i]
    [stack_base - curr_byte * 2] += 1
    i += 1

  b = 0
  max_freq = 0
  max_freq_byte = 0
  while b <= 0xff:
    if [stack_base - b * 2] > max_freq:
      max_freq = [stack_base - b * 2]
      max_freq_byte = b
    b += 1

  return max_freq_byte
```
第一个循环统计字节出现次数，第二个循环遍历栈帧查找次数最多的字节
- 从地址提取字节，将栈作为数组（当前字节相对栈帧的偏移），循环++统计次数
- `curr_byte * 2` 设置了每个字节的统计上限为 2 字节，即2*0x100=0x200的总空间
- 确保第0个元素在分配的空间内而不是当前的rsp栈指针
- `[寄存器 - 值]` 的减法运算可能报错，需拆分步骤或转为加法


**假设条件：**
- 任何字节的数量永远不会超过 `0xffff`
- 大小永远不会超过 `0xffff`
- 列表将至少包含一个元素

**约束条件：**
- 你必须将"计数列表"放置在栈上
- 你必须像在常规函数中一样恢复栈
- 你不能修改 `src_addr` 处的数据
