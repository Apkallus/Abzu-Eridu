# 你好，黑客们

到目前为止，你的程序与外部世界的唯一交互就是在 `exit` 时改变其退出代码。
当然，更多的交互是可能的！

在本模块中，我们将学习 `write` 系统调用，它用于向命令行终端`写入`输出！
这将是一段激动人心的旅程：这个程序的逻辑将既是你所能达到的*最接近硬件本身*（例如，你正在编写 CPU 直接理解的原始 x86 汇编语言！），也是你所能达到的*最接近 Linux 操作系统*（例如，你正在直接触发系统调用！）。

## 挑战

### 写入输出

让我们学习编写文本！不出所料，你的程序通过调用系统调用来向屏幕写入文本。具体来说，这是 `write` 系统调用，其系统调用编号为 `1`。

然而，`write` 系统调用还需要通过其参数指定*要写入什么*数据以及*写入到哪里*。你可能还记得，在 Linux 知识库(/linux-luminarium)道场的 练习管道(/linux-luminarium/piping)模块中，介绍了*文件描述符*的概念。作为提醒，每个进程启动时都有三个文件描述符：

-   **fd 0：** 标准*输入*是进程接收输入的通道。例如，你的 shell 使用标准输入来读取你输入的命令。
-   **fd 1：** 标准*输出*是进程输出正常数据的通道，例如之前挑战中打印给你的 flag，或者像 `ls` 这样的实用程序的输出。
-   **fd 2：** 标准*错误*是进程输出错误详细信息的通道。例如，如果你输错了命令，shell 将通过标准错误输出该命令不存在的消息。

事实证明，在你的 `write` 系统调用中，这就是你指定*将数据写入到哪里*的方式！你的 `exit` 系统调用的第一个（也是唯一一个）参数是你的退出代码（`mov rdi, 42`），而 `write` 的第一个（但在这种情况下，不是唯一的！）参数是文件描述符。如果你想写入标准输出，你需要将 `rdi` 设置为 1。如果你想写入标准错误，你需要将 `rdi` 设置为 2。超级简单！

这就剩下*要写入什么*的问题了。现在，你可以想象一个场景，我们通过 `write` 系统调用的另一个寄存器参数来指定要写入的内容。但是这些寄存器容纳不了大量数据，而要写出像这个挑战描述这样长的文本，你需要多次调用 `write` 系统调用。相对而言，这会产生很大的性能开销 —— CPU 需要从执行你的程序指令切换到执行 Linux 本身的指令，进行一系列内部计算，与硬件交互以使实际像素显示在你的屏幕上，然后再切换回来。这个过程很慢，因此我们尝试尽量减少调用系统调用的次数。

当然，解决方案是同时写入多个字符。`write` 系统调用通过为"写什么"提供*两个*参数来实现这一点：一个*起始内存地址*和一个*要写入的字符数*。这些参数分别作为 `write` 的第二和第三个参数传递。在我们从 `strace` 中学到的类 C 语法中，这将是：

```c
write(file_descriptor, memory_address, number_of_characters_to_write)
```

举一个更具体的例子，如果你想将内存地址 `1337000` 处的 10 个字符写入标准输出（文件描述符 1），这将是：

```c
write(1, 1337000, 10);
```

哇，这很简单！现在，我们实际上如何指定这些参数呢？

1.  我们将系统调用的第一个参数，如上所述，放入 `rdi` 寄存器。
2.  我们将通过 `rsi` 寄存器传递第二个参数。Linux 中约定的惯例是使用 `rsi` 作为系统调用的第二个参数。
3.  我们将通过 `rdx` 寄存器传递第三个参数。
    这是整个模块中最令人困惑的部分：`rdi`（存放第一个参数的寄存器）的名称与 `rdx` 如此相似，很容易混淆，不幸的是，这种命名是由于历史原因造成的，并且会一直保留下去。唉...这只是我们必须小心的事情。也许可以这样助记："`rdi` 是 **i**nitial 参数，而 `rdx` 是 e**x**tra 参数"？或者就把它看作是必须区分名字相似的不同朋友，这样你就会没事的。

当然，还有 `write` 系统调用本身在 `rax` 中的索引号：`1`。

除了 `rdi` 和 `rdx` 容易混淆之外，这真的很容易！

现在，你知道如何将寄存器指向一个内存地址（来自 内存(../memory)模块！），你知道如何设置系统调用号，以及如何设置其余寄存器。所以，这应该是小菜一碟！

和之前类似，我们已经在内存地址 `1337000` 处写入了一个秘密字符值。调用 `write` 将该单个字符（暂时如此！我们稍后会进行多字符写入）的值输出到标准输出，我们就会给你 flag！

### 系统调用链式组合

好的，我们之前的解决方案输出了内容但随后崩溃了。
在这一关，你将输出内容，然后*不*崩溃！

我们将通过调用 `write` 系统调用，然后调用 `exit` 系统调用来干净地退出程序来实现这一点。
我们如何调用两个系统调用？
就像你调用两条指令一样！
首先，你设置必要的寄存器并调用 `write`，然后你设置必要的寄存器并调用 `exit`！

你之前的解决方案有 5 条指令（设置 `rdi`、设置 `rsi`、设置 `rdx`、设置 `rax` 和 `syscall`）。
这次的解决方案应该包含那 5 条，再加上用于 `exit` 的 3 条（将 `rdi` 设置为退出代码、将 `rax` 设置为系统调用索引 `60` 以及 `syscall`）。
对于这一关，让我们以退出代码 `42` 退出！

### 写入字符串

好的，本轮挑战我们还剩最后一件事。
你已经写出了一个字节，现在我们将练习写出多个字节。
我已在内存地址 `1337000` 处存储了一个 14 字符的秘密字符串。
你能把它写出来吗？

----

**提示：**
与你之前的解决方案相比，你*唯一*需要更改的就是 `rdx` 中的值！

### 读取数据

你现在已经知道如何使用 `write` 向标准输出输出数据了。
但你的程序是如何接收输入数据的呢？
它通过 `read` 从标准输入读取数据！

与 `write` 类似，`read` 也是一个系统调用，它在文件描述符和内存之间传输数据，其系统调用编号是 `0`。
对于 `read` 来说，它会从提供的文件描述符中读取一定数量的字节，并将其存储在内存中。
其 C 语言风格的语法与 `write` 相同：

```c
read(0, 1337000, 5);
```

这将从文件描述符 `0`（标准输入）读取 `5` 个字节，存入从 `1337000` 开始的内存中。
因此，如果你向标准输入键入（或通过管道传入）`HELLO HACKERS`，上述 `read` 调用将导致以下内存配置：

```text
  Address │ Contents
+────────────────────+
│ 1337000 │ 48       │
│ 1337001 │ 45       │
│ 1337002 │ 4c       │
│ 1337003 │ 4c       │
│ 1337004 │ 4f       │
+────────────────────+
```

这些数字是什么？？
它们是*ASCII* 编码字母的*十六进制*表示。
如果这些术语让你感到困惑，请先学习 数据处理 (/fundamentals/data-dealings)模块的前半部分内容，然后再回到这里！

在本关卡中，我们将把 `read` 与我们之前掌握的 `write` 能力结合起来。
你的程序应该：

1.  首先从标准输入 `read` 8 个字节到地址 `1337000`
2.  然后将这 8 个字节从地址 `1337000` `write` 到标准输出
3.  最后，以退出代码 `42` 退出。

记住：你已经编写过步骤 2 和 3 了。你只需要添加步骤 1！

----

**注意：**
请记住，在这个挑战中，你将写入 8 个字符，而在之前的挑战中，你写入了 14 个。
不要忘记更新你的 `write()` 的大小（在 `rdx` 中）！

**调试：**
遇到问题了吗？
构建你的程序并使用 `strace` 运行它，看看在系统调用层面发生了什么！
