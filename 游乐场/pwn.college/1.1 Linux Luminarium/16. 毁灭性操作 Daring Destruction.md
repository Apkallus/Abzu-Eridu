# 毁灭性操作

在**学习之旅**中，你已掌握了导航、操作和控制 Linux 系统的方法。在让你自由探索之前，我们有必要以一些警示作为结束——**外加一点小破坏**。以下列举了部分看似无害的操作，若在真实系统上执行，可能导致灾难性数据丢失、拒绝服务甚至无法恢复的系统损坏。

这些操作在 pwn.college 上均可恢复（通过重启容器），但对毫无防备的计算机而言却是真实存在的危险。

请动手实践并惊叹其效果，但**切勿**在任何重要环境中运行它们。

## 挑战

### 分支炸弹

正如你在 进程与作业(/linux-luminarium/processes)模块中学到的，每当启动一个程序时，Linux 操作系统都会创建一个新进程。  
如果你创建进程的速度超过内核的处理能力，进程表将被填满，*一切*都会陷入停滞。  

这个新进程（例如执行 `ls` 命令产生的进程）是从父进程（例如一个 shell 实例）“派生”（fork）出来的。  
因此，这种引发的进程爆炸被称为 “Fork 炸弹”。  

你已掌握实现此操作的工具：  
- 编写一个小型脚本（如 命令链 (/linux-luminarium/chaining)模块所示）  
- 使其可执行（如 权限感知 (/linux-luminarium/permissions)模块所示）  
- 让脚本在后台启动自身的副本（如 进程与作业 (/linux-luminarium/processes)模块所示）  
- 接着再启动*另一个*自身的后台副本！  

每个副本会再启动两个副本，如此指数级增长，最终系统将被海量进程淹没，导致新进程无法启动！  

本挑战包含一个 `/challenge/check` 程序，它会检测你的 Fork 炸弹是否生效（例如系统是否无法启动新进程），若成功则提供 flag。  
请务必在启动攻击*前*（在另一个终端中）启动该检测程序，否则你将无法运行它！  

----  

**注意：**  
无需多言，此举将使你的环境无法使用。  
只需重启挑战（或启动其他挑战）即可恢复至可用状态！  

### 磁盘空间末日

该容器中 `/home/hacker` 的可用空间仅有 **1GB**。  
在本关卡中，你将用大量垃圾文件填满 `/home/hacker`，直至系统无法创建哪怕 1MB 的小文件。  
此时，你的工作空间将变得不可用。  
我们将通过本挑战练习如何引发此状况，并在后续进一步拓展。  

如何填满磁盘？  
方法多种多样。  
此处我们将教你使用 `yes` 命令！  

```sh
hacker@dojo:~$ yes | head
y
y
y
y
y
y
y
y
y
y
hacker@dojo:~$
```

`yes` 命令会持续无限输出 `y`。  
其典型用途是通过管道自动确认提示（如“确定要删除此文件吗？”），但这里我们将用它创建一个充满 “y” 行的大文件。  
只需将 `yes` 的输出追加重定向到主目录下的某个文件，即可在一两分钟内填满磁盘！  

本挑战要求你先填满磁盘再清理。  
流程如下：  
1. 填满磁盘  
2. 运行 `/challenge/check`。该程序会尝试创建 1MB 的临时文件。若失败，则通过第一阶段，检查器将提示你释放空间  
3. 删除你创建的文件（使用 `rm`）以释放空间  
4. 再次运行 `/challenge/check`。若此时能成功创建临时文件（即你已清理主目录），即可获得 flag  

----  

**为何分两阶段？**  
你的主目录在挑战实例间持久存在。  
若允许保持填满状态，你的 pwn.college 将无法正常工作。  
这*是迄今为止* pwn.college 上最常见的问题根源！  

**求助：系统故障！**  
若填满磁盘后未清理，需通过 `ssh` 连接并删除相关文件以修复。  
此操作略有难度，具体方法参见[入门](/welcome/welcome)模块中的“通过 SSH 连接”章节。  

### rm -rf / 命令

想要清空重置并重新开始吗？  
你可以做到！  

```sh
hacker@dojo:~$ ls /
bin etc blah blah blah
hacker@dojo:~$ rm -rf /
hacker@dojo:~$ ls /
bash: ls: command not found
hacker@dojo:~$
```

发生了什么？  
如你所知，`rm` 命令用于删除文件。  
`-r`（递归）标志会删除目录及其包含的所有文件。  
`-f`（强制）标志会忽略 `rm` 命令可能遇到的任何错误或提示。  
当这两个标志组合并针对根目录 `/` 使用时，结果将是灾难性的：系统被完全清空。  
在现代系统上，情况并非*那样*简单，但当你实际操作时就会明白。  

在本挑战中，你将进行一次可能不会再重复的操作：清空整个系统。  
我们实际上已稍作修改以保护你的主目录安全（通常情况下它也会被清空！），但除此之外，你与 flag 之间仅隔着你清空磁盘的决心。  
但在清空所有内容之前，请确保先启动 `/challenge/check`，以便它能观察整个过程（并为你提供 flag）！  

----  

注意：  
`rm` 命令需要一段时间才能运行完毕。  
要删除的内容非常多！  

注意：  
由于各种技术原因，你不太可能删除*所有*内容，包括我们在此关卡中用于保护你主目录的技术。  
别担心，你造成的破坏已经足够了！  

### rm -rf / 之后的数据恢复

让我们深入探讨清空整个文件系统所产生的影响。  
你现在已是一名经验丰富的 `rm` 使用者，但在此之前，当你清除文件系统的混乱时，`/challenge/check` 会为你打印出 flag。  
如果它没有这样做呢？  
没有 `cat` 命令，你该如何读取 `/flag` 文件？  

回顾 文档解读(/linux-luminarium/man)模块可知，某些 Shell 命令是*内置命令*。  
虽然 `ls`、`cat` 等不是内置命令，但 `read` 命令（如你在 Shell 变量(/linux-luminarium/variables)模块中所学，它可以读取文件！）*是*内置命令。  
这意味着，即使你清空了整个文件系统，只要有一个正在运行的 bash 实例，你仍然可以读取文件！  

本挑战将迫使你尝试此操作。  
它与前一个挑战几乎相同，但你必须在自己破坏系统后亲自读取 flag。  
在你使用 `rm` 删除所有内容后，之前启动的 `/challenge/check` 会恢复 `/flag` 文件并使其可读。  
然后你就可以使用 `read` 命令来读取它！  

### 在 rm -rf / 后

所以没有 `cat` 命令你也能存活！  
那没有 `ls` 命令呢？  
这次，`/challenge/check` 会将 flag 恢复到一个*随机命名*的文件中。  
你需要在不使用 `ls` 命令的情况下找到它。  
解决此挑战的方法有很多。  
`echo` 是内置命令，你可以通过 文件通配(/linux-luminarium/globbing)将其参数扩展为所有文件！  
例如，`echo *` 会打印出当前目录下所有文件的名称。  
类似地，你可以使用参数的 Tab 键自动补全（多次按 Tab 键）让 Shell 为你列出可能的文件。  
无论采用哪种方法，请在你执行 `rm` 后找到 `/challenge/check` 在 `/` 目录下创建的随机命名文件，读取它并获取 flag！  
