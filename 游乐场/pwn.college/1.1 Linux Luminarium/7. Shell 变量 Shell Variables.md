# Shell Variables

Linux命令行界面实际上是一种复杂的编程语言，您可以用它编写真正的程序！因为命令行界面通常被称为"shell"，所以用这种语言编写的程序被称为"shell脚本"。当您使用命令行时，实际上就是在逐行编写shell脚本！与大多数编程语言一样，shell支持变量。本模块将帮助您熟悉设置、打印和使用这些变量！

### 资源

Linux 文档项目有一个关于 [shell 变量](https://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO-5.html)的部分：

bash中没有数据类型的概念。一个bash变量可以包含数字、字符或字符串。

您不需要声明变量，只需为其引用赋值即可创建它。

1. 示例：使用变量的Hello World!

    ```bash
    #!/bin/bash          
    STR="Hello World!"
    echo $STR
    ```

    第2行创建了一个名为str的变量，并将字符串"Hello World!"赋值给它。然后通过在变量名前添加'$'符号来获取该变量的值。请注意（请尝试！），如果不使用'$'符号，程序的输出将会不同，可能不是您期望的结果。

2. 示例：一个非常简单的备份脚本（稍好版本）

    ```bash
    #!/bin/bash          
    OF=/var/my-backup-$(date +%Y%m%d).tgz
    tar -cZf $OF /home/me/
    ```

    这个脚本引入了另一个概念。首先，您应该熟悉第2行中的变量创建和赋值。注意表达式`$(date +%Y%m%d)`。如果运行该脚本，您会发现它执行了括号内的命令，并捕获其输出。

    由于date命令的格式选项(`+%Y%m%d`)，这个脚本中的输出文件名每天都会不同。您可以通过指定不同的格式来改变这一点。

    更多示例：

        echo ls

        echo $(ls)

3. 局部变量

    可以使用关键字**local**创建局部变量。

    ```bash
    #!/bin/bash
    HELLO=Hello 
    function hello {
        local HELLO=World
        echo $HELLO
    }
    echo $HELLO
    hello
    echo $HELLO
    ```

    这个示例足以展示如何使用局部变量。


## 挑战

### 打印变量

让我们从打印变量开始。`/challenge/run` 程序不会（也不能）直接给你标志，但这没关系，因为标志已经被存入了名为 *FLAG* 的变量中！只需让 shell 打印它即可！你可以通过多种方式实现，但我们从 `echo` 开始。这个命令只是打印内容。例如：

```console
hacker@dojo:~$ echo Hello Hackers!
Hello Hackers!
```

你也可以用 `echo` 打印变量，方法是在变量名前加上 `$`。例如，有一个变量 `PWD` 始终保存当前 shell 的工作目录。你可以这样打印它：

```console
hacker@dojo:~$ echo $PWD
/home/hacker
```

现在轮到你了。让你的 shell 打印出 *FLAG* 变量并解决这个挑战！

### 设置变量

当然，除了读取存储在变量中的值，您也可以向变量写入值。
与其他许多语言一样，这是通过使用 `=` 来完成的。
要将变量 `VAR` 的值设置为 `1337`，您需要使用：

```console
hacker@dojo:~$ VAR=1337
```

请注意，`=` 周围没有空格！
如果您加了空格（例如，`VAR = 1337`），shell 将无法识别这是一个变量赋值，而是会尝试运行 `VAR` 命令（该命令不存在）。

还需注意，这里使用的是 `VAR` 而 *不是* `$VAR`：`$` 符号仅在 *访问* 变量时添加。
用 shell 的术语来说，添加 `$` 前缀会触发所谓的 *变量展开*，并且，出人意料地，这是许多潜在漏洞的根源（如果您对此感兴趣，请在熟悉命令行后查看 Shell 之道 dojo！）。

设置变量后，您可以使用之前学到的技术来访问它们，例如：

```console
hacker@dojo:~$ echo $VAR
1337
```

要解决本关卡，您必须将 `PWN` 变量设置为值 `COLLEGE`。
请小心：变量名和值都是区分大小写的！
`PWN` 与 `pwn` 不同，`COLLEGE` 与 `College` 也不同。

### 多词变量

在本关卡中，您将学习关于*引用*的知识。
空格在 shell 中具有特殊意义，有些地方您不能随意使用它们。
回想一下我们设置变量的例子：

```console
hacker@dojo:~$ VAR=1337
```

这会将 `VAR` 变量设置为 `1337`，但如果您想将其设置为 `1337 SAUCE` 该怎么办呢？
您可能会尝试以下操作：

```console
hacker@dojo:~$ VAR=1337 SAUCE
```

这看起来是合理的，但它并不起作用，原因与需要在 `=` 周围不能有空格类似。
当 shell 遇到空格时，它会结束变量赋值，并将下一个单词（本例中为 `SAUCE`）解释为一个命令。
要将 `VAR` 设置为 `1337 SAUCE`，您需要*引用*它：

```console
hacker@dojo:~$ VAR="1337 SAUCE"
```

在这里，shell 将 `1337 SAUCE` 读取为一个单一的标记，并顺利地将该值设置给 `VAR`。
在本关卡中，您需要将变量 `PWN` 设置为 `COLLEGE YEAH`。
祝您好运！

### 导出变量

默认情况下，您在 Shell 会话中设置的变量仅在该 Shell 进程内局部有效。
也就是说，您运行的其他命令不会继承这些变量。
您可以通过在当前 Shell 中启动另一个 Shell 进程来验证这一点，例如：

```console
hacker@dojo:~$ VAR=1337
hacker@dojo:~$ echo "VAR is: $VAR"
VAR is: 1337
hacker@dojo:~$ sh
$ echo "VAR is: $VAR"
VAR is: 
```

上述输出中，`$` 提示符来自 `sh`——一个被调用为主 Shell 进程*子*进程的最小 Shell 实现。
它确实没有接收到 `VAR` 变量！

这当然是合理的。
您的 Shell 变量可能包含敏感或异常数据，除非明确需要，否则您不会希望这些数据泄漏到其他运行的程序中。
如何标记变量需要传递呢？
您需要*导出*变量。
当您导出变量后，它们会被传递到子进程的*环境变量*中。
您会在其他挑战中遇到环境变量的概念，但可以在此处观察其效果。
示例如下：

```console
hacker@dojo:~$ VAR=1337
hacker@dojo:~$ export VAR
hacker@dojo:~$ sh
$ echo "VAR is: $VAR"
VAR is: 1337
```

这里，子 Shell 接收到了 VAR 的值并成功打印！
您也可以将前两行合并书写：

```console
hacker@dojo:~$ export VAR=1337
hacker@dojo:~$ sh
$ echo "VAR is: $VAR"
VAR is: 1337
```

在本挑战中，您必须调用 `/challenge/run`，要求同时满足：
- 导出 `PWN` 变量并设值为 `COLLEGE`
- 设置 `COLLEGE` 变量为 `PWN` 但*不*导出（即不被 `/challenge/run` 继承）
祝您好运！

### 打印导出的变量

在 Bash 中有多种访问变量的方法。
`echo` 只是其中之一，我们将在本挑战中再学习至少一种方法。

尝试使用 `env` 命令：它会打印出您 Shell 中设置的每一个*导出的*变量，您可以浏览该输出以找到 `FLAG` 变量！

### 存储命令输出

在使用 Shell 的过程中，您经常需要将某些命令的输出结果存储到变量中。
幸运的是，Shell 通过一种称为[*命令替换*](https://www.gnu.org/software/bash/manual/html_node/Command-Substitution.html)的机制使这一操作变得非常简单！
观察示例：

```console
hacker@dojo:~$ FLAG=$(cat /flag)
hacker@dojo:~$ echo "$FLAG"
pwn.college{blahblahblah}
hacker@dojo:~$
```

很简洁！
现在请您练习：将 `/challenge/run` 命令的输出直接读取到名为 `PWN` 的变量中，该变量将包含所需标记！

----
**冷知识：**
除了使用 `$()`，您也可以使用反引号：`` FLAG=`cat /flag` ``（对应上文示例中的 ``FLAG=$(cat /flag)``）。
这是旧式写法，存在一些缺点（例如，假设您需要*嵌套*命令替换：使用反引号如何实现 `$(cat $(find / -name flag))`？）。
pwn.college 的官方立场是推荐使用 `$(blah)` 而非 `` `blah` ``。

### 读取输入

我们将从读取用户（您）的输入开始。
这可以通过 aptly 命名的 `read` 内置命令完成，该命令将输入*读取*到变量中！

以下是一个使用 `-p` 参数的示例，该参数允许您指定提示信息（否则，在下面的示例中，您将很难区分输入和输出）：

```console
hacker@dojo:~$ read -p "INPUT: " MY_VARIABLE
INPUT: Hello!
hacker@dojo:~$ echo "You entered: $MY_VARIABLE"
You entered: Hello!
```

请记住，`read` 从您的标准输入读取数据！
上面第一个 `Hello!` 是*输入*的内容而非*输出*的内容。
让我们对此进行更明确的标注。
此处，我们在每行的开头标注了该行是来自用户的 `INPUT` 还是面向用户的 `OUTPUT`：

```console
 INPUT: hacker@dojo:~$ echo $MY_VARIABLE
OUTPUT:
 INPUT: hacker@dojo:~$ read MY_VARIABLE
 INPUT: Hello!
 INPUT: hacker@dojo:~$ echo "You entered: $MY_VARIABLE"
OUTPUT: You entered: Hello!
```

在本挑战中，您的任务是使用 `read` 将 `PWN` 变量设置为值 `COLLEGE`。
祝您好运！


### 读取文件

通常，当 Shell 用户需要将文件内容读取到环境变量时，他们会这样做：

```console
hacker@dojo:~$ echo "test" > some_file
hacker@dojo:~$ VAR=$(cat some_file)
hacker@dojo:~$ echo $VAR
test
```

这种方法有效，但被挑剔的黑客称为["无用的 Cat 用法"](https://porkmail.org/era/unix/award#cat)。
也就是说，仅仅为了读取文件而运行一个完整的其他程序是一种浪费。
实际上，您可以直接使用 Shell 的强大功能！

之前您已经学过使用 `read` 将用户输入读取到变量中。
您也学过将文件重定向到命令输入！
将两者结合，您就可以用 Shell 直接读取文件。

```console
hacker@dojo:~$ echo "test" > some_file
hacker@dojo:~$ read VAR < some_file
hacker@dojo:~$ echo $VAR
test
```

这里发生了什么？
示例将 `some_file` 重定向到 `read` 的*标准输入*，因此当 `read` 读取到 `VAR` 时，它实际上是从文件读取！
现在，请使用这种方法将 `/challenge/read_me` 的内容读取到 `PWN` 环境变量中，我们将为您提供标记！
请注意 `/challenge/read_me` 的内容会持续变化，因此您需要用*一条命令*将其直接读取到 `PWN` 变量中！
