# Processes and Jobs

计算机通过执行软件来完成各种任务。在现代计算中，软件分为两大类：*操作系统内核*（我们将在系统安全章节详细学习）和*进程*（本节将重点讨论）。当Linux启动时，会运行一个*init*（初始化进程的缩写）进程，该进程随后启动一系列其他进程，这些进程又会启动更多进程，最终您将看到命令行 shell——它本身也是一个进程！Shell 会根据您输入的命令启动相应进程。

本模块将通过多种实用方式学习如何查看和操作进程！

## 挑战

### 列出进程

首先，我们将学习使用 `ps` 命令列出正在运行的进程。根据不同的解释，`ps` 既可代表“进程快照”（process snapshot）也可代表“进程状态”（process status），其功能是列出进程。默认情况下，`ps` 仅列出当前终端中运行的进程，这实际上并不实用：

```bash
hacker@dojo:~$ ps
    PID TTY          TIME CMD
    329 pts/0    00:00:00 bash
    349 pts/0    00:00:00 ps
hacker@dojo:~$
```

在上例中，我们仅看到 shell（`bash`）和 `ps` 进程本身，这就是该特定终端中运行的全部内容。同时可以看到每个进程都有一个数字标识符（*进程 ID*，即 pid），该编号在 Linux 环境中唯一标识每个运行中的进程。我们还看到命令运行的终端（此处为 `pts/0`），以及进程至今消耗的 *CPU 时间* 总量（由于这些进程资源需求极低，甚至尚未消耗满 1 秒！）。大多数情况下，默认 `ps` 命令仅显示这些信息。若要使其实用化，需传递一些参数。

由于 `ps` 是一个历史悠久的实用程序，其使用方法略显混乱。参数指定方式有两种：

**“标准”语法：**  
此语法中，`-e` 用于列出“所有”进程，`-f` 用于显示“完整格式”输出（包括参数）。二者可合并为单一参数 `-ef`。

**“BSD”语法：**  
此语法中，`a` 用于列出所有用户的进程，`x` 用于显示非终端运行的进程，`u` 用于“用户易读”格式输出。三者可合并为单一参数 `aux`。

这两种方法（`ps -ef` 与 `ps aux`）生成的输出略有差异但可相互对应。让我们在实践环境中尝试：

```bash
hacker@dojo:~$ ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
hacker         1       0  0 05:34 ?        00:00:00 /sbin/docker-init -- /bin/sleep 6h
hacker         7       1  0 05:34 ?        00:00:00 /bin/sleep 6h
hacker       102       1  1 05:34 ?        00:00:00 /usr/lib/code-server/lib/node /usr/lib/code-server --auth=none -
hacker       138     102 11 05:34 ?        00:00:07 /usr/lib/code-server/lib/node /usr/lib/code-server/out/node/entr
hacker       287     138  0 05:34 ?        00:00:00 /usr/lib/code-server/lib/node /usr/lib/code-server/lib/vscode/ou
hacker       318     138  6 05:34 ?        00:00:03 /usr/lib/code-server/lib/node --dns-result-order=ipv4first /usr/
hacker       554     138  3 05:35 ?        00:00:00 /usr/lib/code-server/lib/node /usr/lib/code-server/lib/vscode/ou
hacker       571     554  0 05:35 pts/0    00:00:00 /usr/bin/bash --init-file /usr/lib/code-server/lib/vscode/out/vs
hacker       695     571  0 05:35 pts/0    00:00:00 ps -ef
hacker@dojo:~$
```

此处可见挑战环境初始化进程（`docker-init`）、挑战自动终止前的超时设置（`sleep 6h` 表示 6 小时后超时以节约计算资源）、VSCode 环境进程（若干 `code-server` 辅助进程）、shell（`bash`）以及刚执行的 `ps -ef` 命令。使用 `ps aux` 的结果基本一致：

```bash
hacker@dojo:~$ ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
hacker         1  0.0  0.0   1128     4 ?        Ss   05:34   0:00 /sbin/docker-init -- /bin/sleep 6h
hacker         7  0.0  0.0   2736   580 ?        S    05:34   0:00 /bin/sleep 6h
hacker       102  0.4  0.0 723944 64660 ?        Sl   05:34   0:00 /usr/lib/code-server/lib/node /usr/lib/code-serve
hacker       138  3.3  0.0 968792 106272 ?       Sl   05:34   0:07 /usr/lib/code-server/lib/node /usr/lib/code-serve
hacker       287  0.0  0.0 717648 53136 ?        Sl   05:34   0:00 /usr/lib/code-server/lib/node /usr/lib/code-serve
hacker       318  3.3  0.0 977472 98256 ?        Sl   05:34   0:06 /usr/lib/code-server/lib/node --dns-result-order=
hacker       554  0.4  0.0 650560 55360 ?        Rl   05:35   0:00 /usr/lib/code-server/lib/node /usr/lib/code-serve
hacker       571  0.0  0.0   4600  4032 pts/0    Ss   05:35   0:00 /usr/bin/bash --init-file /usr/lib/code-server/li
hacker      1172  0.0  0.0   5892  2924 pts/0    R+   05:38   0:00 ps aux
hacker@dojo:~$
```

`ps -ef` 与 `ps aux` 存在诸多共同点：均显示用户（`user` 列）、pid、终端、进程启动时间（`stime`/`start`）、已用 CPU 时间（`time`）及命令（`cmd`/`command`）。`ps -ef` 额外输出*父进程 ID*（`ppid`），即启动该进程的父进程 pid；而 `ps aux` 则输出进程占用的系统总 CPU 和内存百分比。此外还有其他暂不深入讨论的字段。

现在开始实践！在本关卡中，我再次将 `/challenge/run` 重命名为随机文件名，且设置为你无法通过 `ls` 查看 `/challenge` 目录！但该程序已被启动，因此你可以在进程列表中找到它，确定文件名后直接重新启动以获取 flag！祝你好运！

**注意：**  
`ps -ef` 和 `ps aux` 默认会根据终端宽度截断命令列表（这正是上文示例中右侧对齐的原因）。若无法读取进程的完整路径，可能需要扩大终端窗口（或重定向输出以避免截断）。替代方案是传递两次 `w` 参数（如 `ps -efww` 或 `ps auxww`）来禁用截断。


### 终止进程

你已经启动了进程，查看了进程，现在将学习如何*终止*进程！
在 Linux 中，这一操作通过命名直观的 `kill` 命令完成。使用默认选项（本关卡仅涉及此模式），`kill` 会以允许进程在结束前完成收尾工作的方式终止目标进程。

假设你在另一个终端中启动了一个棘手的 `sleep` 进程（`sleep` 是一个按命令行指定秒数挂起的程序，此处为 1337 秒），如下所示：

```sh
hacker@dojo:~$ sleep 1337
```

如何清除它？  
通过将进程标识符（从 `ps` 获取的 `PID`）作为参数传递给 `kill` 命令来终止它，如下所示：

```sh
hacker@dojo:~$ ps -e | grep sleep
 342 pts/0    00:00:00 sleep
hacker@dojo:~$ kill 342
hacker@dojo:~$ ps -e | grep sleep
hacker@dojo:~$
```

现在，是时候终止你的第一个进程了！  
在本挑战中，当 `/challenge/dont_run` 正在运行时，`/challenge/run` 将拒绝执行！  
你必须找到 `dont_run` 进程并使用 `kill` 终止它。  
若失败，`pwn.college` 将否认与你的任务有任何关联。  
祝你好运。

### 中断进程

你已经学会了使用 `kill` 命令终止其他进程，但有时你只想清除阻塞终端的进程！
幸运的是，终端为此提供了快捷键：`Ctrl-C`（即按住 `Ctrl` 键的同时按下 `C`）会向正在等待终端输入的应用发送"*中断*"信号，通常这将促使应用程序正常退出。

在此尝试吧！  
`/challenge/run` 将在你中断它之前拒绝提供 flag。  
祝你好运！

----

若对此非常感兴趣，可参阅这篇关于终端与"*控制码*"（如 `Ctrl-C`）的[文章](https://catern.com/posts/terminal_quirks.html):
- 使用组合键时，Ctrl键清除按键所对应字符ASCII码的高2位后，保留低5位（ASCII码为7位）。
    于是多个组合键方案可对应同一功能。  
    - Ctrl+char 和 Ctrl+Shift+char 相同。  
        即，Shift设置大小写（差异在高位），Ctrl清除高2位，于是Ctrl组合按键中 Shift无效。  
        实际上，以前终端中的 Shift 键确实只是设置第 6 位。但这已经很久不成立了。Shift 键的效果（大写字母和其他改变字母输入）现在由 X11 处理（或其他平台桌面栈的等效部分），因此你的终端模拟器只是忽略实际的 Shift 键。
- 当按下 Alt+字符时，在发送'字符'之前先发送"ESC"。
    - Alt+char 和 Alt+Shift+char 是不同的，因为它们会发送 Escape，然后是 char 或 Shift+char。
    - 在那些不自行监听 Escape 的应用程序中，您可以通过先按 Escape，然后按 char 来发送 Alt+char。

### 终止异常进程

有时，行为异常的进程可能会干扰你的工作。这些进程可能需要被终止...

在本挑战中，存在一个占用关键资源的*诱饵进程*——位于 `/tmp/flag_fifo` 的命名管道（FIFO）。与管道章节中的 FIFO 挑战类似，`/challenge/run` 需要向该管道写入你的 flag。你需要 `kill` 此诱饵进程。

你的基本操作流程应为：

1.  检查当前运行的进程。
2.  在列表中找到 `/challenge/decoy` 并确定其*进程 ID*。
3.  使用 `kill` 终止它。
4.  运行 `/challenge/run` 以获取 flag，而不会被诱饵进程干扰（你无需重定向其输出；它会自动写入 FIFO）。

祝你好运！

----

**注意：**
即使在终止诱饵进程后，你可能仍会看到一些诱饵 flag 出现。这是因为 Linux 管道是*buffered*（带缓冲的）：从概念上讲，数据在管道中流动需要经过一定长度，你可能在数据仍在管道中时终止了诱饵进程。这些已经进入管道的数据将继续流向另一端（你的 `cat` 命令）。如果你等待一秒，将会看到诱饵停止出现，然后即可运行 `/challenge/run` 并获胜！


### 挂起进程

你已经学会了使用 `Ctrl-C` 中断进程，但还有更温和的方法可以恢复终端控制！
你可以通过 `Ctrl-Z` 将进程*挂起*至后台。在本关卡中，我们将探索这一机制，并在下一关卡学习如何*恢复*这些被挂起的进程！

本关卡的 `run` 程序需要检测到另一个正在运行*且使用同一终端*的自身副本。
如何实现？
在终端中启动该程序，将其挂起，然后在第一个进程处于挂起状态时启动另一个副本！


### 恢复进程

通常情况下，当你挂起进程后，总会需要在某个时间点恢复它们。否则，何不直接终止它们呢？要恢复进程，你的 shell 提供了 `fg` 命令——这是一个*内置命令*，它会获取被挂起的进程，将其恢复并放回你终端的*前台*。

去尝试一下吧！
本挑战的 `run` 程序需要你将其挂起，然后再恢复它。
祝你好运！


### 进程后台运行

你已经学会了使用 `fg` 命令在*前台*恢复进程。
还可以通过 `bg` 命令在*后台*恢复进程！
这会使进程继续运行，同时将 shell 控制权交还给你以便执行其他命令。

本关卡的 `run` 程序需要检测到另一个正在运行（*非挂起状态*）且使用同一终端的自身副本。
如何实现？
在终端中启动该程序，将其挂起，接着用 `bg` 命令将其置入*后台*运行，然后在第一个进程于后台运行时启动另一个副本！


----

**技术细节：**
若想深入了解，可查看挂起进程与后台进程的属性差异！
让我来演示。首先挂起一个 `sleep` 进程：

```sh
hacker@dojo:~$ sleep 1337
^Z
[1]+  Stopped                 sleep 1337
hacker@dojo:~$
```

此时 `sleep` 进程已在后台被*挂起*。通过 `ps` 的 `-o` 选项启用 `stat` 列输出可观察到：

```sh
hacker@dojo:~$ ps -o user,pid,stat,cmd
USER         PID STAT CMD
hacker       702 Ss   bash
hacker       762 T    sleep 1337
hacker       782 R+   ps -o user,pid,stat,cmd
hacker@dojo:~$ 
```

看到 `T` 了吗？这表示进程因 `Ctrl-Z` 操作而被挂起。`bash` 的 `STAT` 列中的 `S` 表示其正在等待输入时处于睡眠状态。`ps` 命令旁的 `R` 表示该进程正在活跃运行，而 `+` 号代表其处于前台！
观察将 `sleep` 在后台恢复时的变化：

```sh
hacker@dojo:~$ bg
[1]+ sleep 1337 &
hacker@dojo:~$ ps -o user,pid,stat,cmd
USER         PID STAT CMD
hacker       702 Ss   bash
hacker       762 S    sleep 1337
hacker      1224 R+   ps -o user,pid,stat,cmd
hacker@dojo:~$
```

看！现在 `sleep` 显示为 `S` 状态。虽然程序本身处于睡眠状态，但进程并未被挂起！由于它在*后台*运行，因此不显示 `+` 号。


### 进程前台运行

假设你有一个在*后台*运行的进程，而你想对其进行进一步操作。
该怎么做？
其实，你可以像恢复挂起进程一样，使用 `fg` 命令将后台进程切换到*前台*！
本关卡将引导你完成这一操作！


### 启动后台进程

当然，你无需先挂起进程再将其置入后台：可以直接启动即进入*后台*运行！
操作非常简单，只需在命令末尾追加 `&` 符号即可，如下所示：

```sh
hacker@dojo:~$ sleep 1337 &
[1] 1771
hacker@dojo:~$ ps -o user,pid,stat,cmd
USER         PID STAT CMD
hacker      1709 Ss   bash
hacker      1771 S    sleep 1337
hacker      1782 R+   ps -o user,pid,stat,cmd
hacker@dojo:~$ 
```

此时 `sleep` 进程正在后台*活跃运行*，且*非挂起*状态。
现在轮到你来实践了！
请以后台运行方式启动 `/challenge/run` 以获取 flag！


### 进程退出码

每个 shell 命令（包括所有程序和内置命令）在运行结束终止时都会返回一个*退出码*。  
shell 或其使用者（也就是你！）可通过该值验证进程是否成功完成了预期功能（当然，具体判断标准取决于进程的预设任务）。  

你可以使用特殊的 `?` 变量获取最近终止命令的退出码（注意读取值时需前缀 `$` 符号）：

```sh
hacker@dojo:~$ touch test-file
hacker@dojo:~$ echo $?
0
hacker@dojo:~$ touch /test-file
touch: cannot touch '/test-file': Permission denied
hacker@dojo:~$ echo $?
1
hacker@dojo:~$
```

如你所见，成功执行的命令通常返回 `0`，而失败命令通常返回非零值（最常见的是 `1`，有时也会返回标识*特定故障模式*的错误码）。  

本挑战要求你获取 `/challenge/get-code` 返回的退出码，并将该错误码作为参数传递给 `/challenge/submit-code` 执行。  
祝你好运！


