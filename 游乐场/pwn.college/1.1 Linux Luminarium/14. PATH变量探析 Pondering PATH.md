# PATH变量探析

到目前为止，您已经通过以下几种方式调用命令：
- 通过绝对路径（例如 `/challenge/run`）
- 通过相对路径（例如 `./run`）
- 通过*裸命令名*（例如 `ls`）

前两种情况（绝对路径和相对路径）很直观：`run` 文件位于 `/challenge` 目录中，两种路径都指向它（当然，前提是相对路径的当前工作目录为 `/challenge`）。  
但最后一种情况呢？`ls` 程序位于何处？shell 如何知道在那里搜索它？  
在本模块中，我们将揭开谜底并回答这个问题！敬请关注。

### 资源

[What is PATH?](https://www.linfo.org/path_env_var.html)

## 挑战

### PATH变量

原来，"shell 如何找到 `ls`？" 这个问题的答案相当简单。  
有一个特殊的 shell 变量，名为 *`PATH`*，它存储了一系列目录路径，shell 会在这些路径中搜索与命令对应的程序。  
如果清空该变量，情况会变得糟糕：

```sh
hacker@dojo:~$ ls
Desktop    Downloads  Pictures  Templates
Documents  Music      Public    Videos
hacker@dojo:~$ PATH=""
hacker@dojo:~$ ls
bash: ls: No such file or directory
hacker@dojo:~$
```

没有 PATH，bash 无法找到 `ls` 命令。

在本关卡中，您将干扰 `/challenge/run` 程序的运行。  
该程序会使用 `rm` 命令**删除**标志文件。  
但是，如果它找不到 `rm` 命令，标志文件就不会被删除，挑战会将文件交给您！  
因此，您必须确保 `/challenge/run` 也找不到 `rm` 命令！

请注意：如果您未成功，且标志文件被删除，您需要重新启动挑战以再次尝试！

### 设置PATH

好的，清空 *`PATH`* 会导致问题。  
但如何利用 *`PATH`* 做些有用的事呢？

让我们探索如何向命令库添加新程序目录。  
回想一下，*`PATH`* 存储了用于查找命令的目录列表，而对于非标准位置的命令，我们通常需要通过路径执行它们：

```sh
hacker@dojo:~$ ls /home/hacker/scripts
goodscript	badscript	okayscript
hacker@dojo:~$ goodscript
bash: goodscript: command not found
hacker@dojo:~$ /home/hacker/scripts/goodscript
YEAH! This is the best script!
hacker@dojo:~$
```

如果您维护了一些希望直接通过裸命令名启动的实用脚本，这会很麻烦。  
但通过向此列表添加或替换目录，您可以让这些程序支持裸命令名启动！  
例如：

```sh
hacker@dojo:~$ PATH=/home/hacker/scripts
hacker@dojo:~$ goodscript
YEAH! This is the best script!
hacker@dojo:~$
```

让我们来实践一下。  
本关卡的 `/challenge/run` 会通过裸命令名运行 `win` 命令，但该命令存在于 `/challenge/more_commands/` 目录中，而该目录初始不在 PATH 中。  
`win` 命令是 `/challenge/run` *唯一*需要的东西，因此您可以直接用该目录覆盖 `PATH`。  
祝您好运！

### 查找命令

当您输入命令名称时，实际执行的是您 `$PATH` 变量所列出的众多目录中的*某个*文件（当然，除非该命令是内置命令！）。  
但具体是*哪个*文件呢？  
您可以使用名称贴切的 `which` 命令来找出答案：

```sh
hacker@dojo:~$ which cat
/bin/cat
hacker@dojo:~$ /bin/cat /flag
YEAH
hacker@dojo:~$
```

`which` 命令模拟 shell 在搜索命令时的行为：按顺序查看 `$PATH` 中的每个目录，并打印找到的第一个与您传入参数同名的文件。
在本挑战中，我们在您的 `$PATH` 某处添加了一个 `win` 命令，但它不会直接给您标志。  
相反，它与一个我们已设为对您可读的 `flag` 文件位于同一目录！  
您必须找到 `win`（使用 `which` 命令），然后通过 `cat` 命令从该目录读取标志！

### 添加命令

回顾上一关的示例：

```sh
hacker@dojo:~$ ls /home/hacker/scripts
goodscript	badscript	okayscript
hacker@dojo:~$ PATH=/home/hacker/scripts
hacker@dojo:~$ goodscript
YEAH! This is the best script!
hacker@dojo:~$
```

这里展示的显然是*黑客*通过引入自定义命令来增强 shell 的实用性。  
随着时间推移，您也可能积累自己的高效工具。  
让我们从 `win` 开始实践！

此前，`/challenge/run` 执行的 `win` 命令存储在 `/challenge/more_commands` 中。  
但这次 `win` 并不存在！  
请回顾 linux-命令链 的最终关卡，创建一个名为 `win` 的 shell 脚本，将其路径添加到 `PATH` 中，并使 `/challenge/run` 能够找到它！

----

**提示：**  
`/challenge/run` 以 `root` 权限运行并会调用 `win`，因此 `win` 可直接通过 `cat` 读取标志文件。  
再次强调，`win` 命令是 `/challenge/run` *唯一*的依赖项，您可直接用单个目录覆盖 `PATH`。  
但请注意：若这样做，您的 `win` 脚本将无法找到 `cat` 命令。

可通过以下三种方式解决：

1. 定位 `cat` 程序在文件系统中的绝对路径。它*必然*存在于 `PATH` 变量的某个目录中，找到包含 `cat` 的目录后使用绝对路径调用。
2. 设置包含旧目录路径*及*新创建的 `win` 脚本目录的 `PATH` 变量。
3. 使用 `read` 命令（再次参考 linux-luminarium Shell 变量）直接读取 `/flag`。由于 `read` 是 `bash` 的内置功能，不受 `PATH` 变动影响。

现在，去赢得胜利吧！

### 命令劫持

掌握了这些知识后，您现在可以执行一些操作了。  
本挑战与本模块的第一个挑战几乎相同。  
同样，此挑战将使用 `rm` 命令删除标志文件。  
但与此前不同，它*不会*为您输出任何信息。

您该如何解决？  
您知道 `rm` 会在 `PATH` 变量所列的目录中搜索。  
您已有在上一个挑战需要时创建 `win` 命令的经验。  
您还能创建什么？
