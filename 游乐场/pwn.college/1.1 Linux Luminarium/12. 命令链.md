# 命令链

在管道模块中，您已经探索了使用多个命令的概念，数据通过管道在它们之间流动，以完成比单个命令更复杂的任务。当然，这一概念也适用于独立于数据传输的情况：有时，您可能希望快速连续运行多个命令以实现某种累积效果。

本模块将介绍除管道外，命令可以被链式组合的几种方式。到最后，您将开始编写*Shell脚本*！

## 挑战

### 使用分号进行命令链

命令链式组合的最简单方式是使用 `;`。在大多数上下文中，`;` 分隔命令的方式类似于用 Enter 键分隔行。因此，以下命令：

```sh
hacker@dojo:~$ echo COLLEGE > pwn
hacker@dojo:~$ cat pwn
COLLEGE
hacker@dojo:~$
```

大致等同于：

```sh
hacker@dojo:~$ echo COLLEGE > pwn; cat pwn
COLLEGE
hacker@dojo:~$
```

本质上，当您按下 Enter 键时，Shell 会执行您输入的命令，并在该命令终止后显示提示符以输入下一条命令。分号的作用类似，只是不会显示提示符，且需要在任何命令执行前输入全部命令。

现在尝试一下吧！在本关卡中，您必须依次运行 `/challenge/pwn` 和 `/challenge/college`，并用分号将它们链式组合。

### 基于成功构建

您已在 Linux-进程 模块中学习了退出码的相关知识。现在让我们运用退出码来实现命令的链式组合！

`&&` 运算符允许您仅在第一个命令成功时（遵循Linux惯例，即退出码为0）才运行第二个命令。这被称为"AND"运算符，因为需要同时满足两个条件：第一个命令必须成功*且*第二个命令才会运行。这对于需要特定操作依赖于其他操作成功执行的复杂命令行工作流非常有用。

语法如下：
```sh
hacker@dojo:~$ command1 && command2
```

这表示："运行command1，*如果*它执行成功，则运行command2。"

示例如下：
```sh
hacker@dojo:~$ touch /home/hacker/file && echo "this will run"
success
this will run
hacker@dojo:~$ touch /file && echo "this will NOT run"
touch: cannot touch '/file': Permission denied
hacker@dojo:~$
```

第二次调用`touch`失败是因为hacker用户没有对`/file`的写入权限，因此`echo`命令未执行。

在本挑战中，您需要使用`&&`运算符将程序`/challenge/first-success`和`/challenge/second`进行链式组合。建议先单独运行每个命令观察结果（此时您将*不*会获得flag）。但若使用`&&`进行链式组合，flag就会出现！

### 处理失败

您刚刚学习了`&&`运算符，它仅在第一个命令成功时才运行第二个命令。现在让我们了解其反向操作符：`||`运算符允许您在第一个命令失败（以非零代码退出）时才运行第二个命令。这被称为*OR*运算符，因为要么第一个命令成功*要么*第二个命令将运行。

语法如下：

```sh
hacker@dojo:~$ command1 || command2
```

这表示："运行command1，*如果*它执行失败，则运行command2。"

示例如下：

```sh
hacker@dojo:~$ touch /file || echo "touch failed, so this runs"
touch: cannot touch '/file': Permission denied
touch failed, so this runs
hacker@dojo:~$ touch /home/hacker/file || echo "this will NOT run"
hacker@dojo:~$
```

`||`运算符对于提供回退命令或错误处理非常有用！

在本挑战中，您需要使用`||`运算符将`/challenge/first-failure`和`/challenge/second`进行链式组合。开始尝试吧！

### 你的第一个 Shell 脚本

当您组合越来越多的命令以实现复杂效果时，组合命令行的长度很快就会变得难以处理。此时，您可以将这些命令放入一个名为*Shell脚本*的文件中，并通过执行该文件来运行它们！
例如，考虑我们之前的分号技术：

```sh
hacker@dojo:~$ echo COLLEGE > pwn; cat pwn
COLLEGE
hacker@dojo:~$
```

我们可以创建一个名为 `pwn.sh` 的Shell脚本（按照惯例，Shell脚本通常以 `sh` 作为后缀命名）：

```sh
echo COLLEGE > pwn
cat pwn
```

然后通过将其作为参数传递给新的Shell实例（`bash`）来执行！
当以这种方式调用Shell时，它不会从用户处获取命令，而是从文件中读取命令。

```sh
hacker@dojo:~$ ls
hacker@dojo:~$ bash pwn.sh
COLLEGE
hacker@dojo:~$ ls
pwn
hacker@dojo:~$
```

您可以看到Shell脚本执行了两个命令，创建并打印了 `pwn` 文件。

现在轮到您了！
与上一关卡相同，依次运行 `/challenge/pwn` 和 `/challenge/college`，但这次需要在一个名为 `x.sh` 的Shell脚本中实现，然后使用 `bash` 运行它！

----

**注意：** 我们尚未介绍Linux出色的命令行文件编辑器。目前请随意使用桌面模式下的`文本编辑器`应用程序（`应用程序->附件->文本编辑器`）或VSCode工作区中的默认编辑器！

### 脚本输出重定向

让我们尝试一些更有挑战性的内容！
您已经使用 `|` 在程序之间建立了输出管道，但到目前为止，这只是在单个命令的输出与另一个命令的输入之间进行。但如果想要将多个程序的输出发送到一个命令该怎么办呢？有几种方法可以实现，这里我们将探讨一种简单的方式：从脚本重定向输出！

对于Shell而言，您的脚本只是另一个命令。这意味着您可以像在 linux-管道 模块中处理命令一样，重定向其输入和输出！例如，您可以将其写入文件：

```sh
hacker@dojo:~$ cat script.sh
echo PWN
echo COLLEGE
hacker@dojo:~$ bash script.sh > output
hacker@dojo:~$ cat output
PWN
COLLEGE
hacker@dojo:~$
```

所有重定向方法都适用：`>` 用于标准输出、`2>` 用于标准错误、`<` 用于标准输入、`>>` 和 `2>>` 用于追加模式重定向、`>&` 用于重定向到其他文件描述符、`|` 用于通过管道传递给其他命令。

在本关卡中，我们将练习从脚本到其他程序的管道传输（`|`）。与之前类似，您需要创建一个脚本，先调用 `/challenge/pwn` 命令，再调用 `/challenge/college` 命令，并将脚本的输出通过管道传输到单次调用的 `/challenge/solve` 命令中！

### 可执行 Shell 脚本

您已经编写了第一个Shell脚本，但通过`bash script.sh`调用很麻烦。为什么需要那个`bash`呢？

当您调用`bash script.sh`时，实际上是在启动`bash`命令并以`script.sh`作为参数。这告诉bash从`script.sh`读取命令，而不是从标准输入读取，因此您的Shell脚本得以执行。

事实上，您可以避免手动调用`bash`的需要。如果您的Shell脚本文件是*可执行的*（请回顾 linux-文件权限），您可以直接通过其相对路径或绝对路径调用它！例如，如果您在主目录中创建`script.sh`*并使其可执行*，则可以通过`/home/hacker/script.sh`、`~/script.sh`或（如果工作目录是`/home/hacker`）`./script.sh`来调用它。

现在尝试一下吧！创建一个用于调用`/challenge/solve`的Shell脚本，使其可执行，并在不显式调用`bash`的情况下运行它！

### 理解释伴（Shebang）

您已经顺利踏上了成为Shell脚本编写者的新征程！
然而到目前为止，您的Shell脚本*只能从Shell中启动*。在上一个关卡中运行良好（因为您是从`bash` shell调用脚本），但如果脚本被其他程序（比如用Python或其他语言编写的程序）调用，则无法正常工作。

当程序在Linux中被调用时，Linux内核会首先检查文件以确定应如何运行。这*不会*使用文件扩展名（这就是为什么您不*必须*将Shell脚本命名为`.sh`扩展名，或将Python脚本命名为`.py`扩展名等等）。相反，Linux通过查看文件开头的几个字节来获取此信息。

程序有多种类型，但如果程序文件以字符`#!`开头（通常称为"[Shebang](https://en.wikipedia.org/wiki/Shebang_(Unix))"），Linux会将文件视为*解释型程序*，并将该行剩余内容视为*解释器*的路径。然后，内核会调用该解释器，并将程序文件的路径作为其唯一参数。

考虑以下Shell脚本：
```bash
#!/bin/bash

echo "Hello Hackers!"
```

可以通过以下方式执行：
```sh
hacker@dojo:~$ chmod a+x script.sh
hacker@dojo:~$ ./script.sh
Hello Hackers!
hacker@dojo:~$
```

当执行`./script.sh`时，Linux打开文件，读取第一行，提取`/bin/bash`作为解释器，并执行`/bin/bash ./script.sh`来启动脚本！

请注意，Shebang行必须位于文件的*第一行*——其前面不能有空行或空格！

在本挑战中，请在`/home/hacker/solve.sh`创建一个包含正确Shebang并输出"hack the planet"的脚本。记得将其设置为可执行，然后运行`/challenge/run`来验证脚本是否正确工作！

----

**有趣的事实：**
您可能会看到的常见Shebang：

- `#!/bin/bash` 用于bash脚本
- `#!/usr/bin/python3` 用于Python脚本
- `#!/bin/sh` 用于POSIX shell脚本——这是`bash`的一个功能较少但更兼容非Linux系统的原始前身！

### 带参数的脚本编写

您已经学会了如何创建Shell脚本，但到目前为止它们还只是命令列表。当脚本能够接受参数时，其功能将变得更加强大！示例可能如下：

```sh
hacker@dojo:~$ bash myscript.sh hello world
```

脚本可以通过特殊变量访问这些参数：
- `$1` 包含第一个参数（"hello"）
- `$2` 包含第二个参数（"world"）
- `$3` 将包含第三个参数（如果存在）
- ...以此类推

以下是一个简单示例：

```bash
hacker@dojo:~$ cat myscript.sh
#!/bin/bash
echo "First argument: $1"
echo "Second argument: $2"
hacker@dojo:~$ bash myscript.sh hello world
First argument: hello
Second argument: world
hacker@dojo:~$
```

在本挑战中，您需要在`/home/hacker/solve.sh`编写一个脚本，要求：
1. 接受两个参数
2. 以*反向*顺序输出它们（先输出第二个参数，再输出第一个参数）

例如：
```sh
hacker@dojo:~$ bash /home/hacker/solve.sh pwn college
college pwn
hacker@dojo:~$
```

当脚本正确运行后，执行`/challenge/run`来获取flag！

### 带条件判断的脚本编写

现在您已经能在脚本中使用参数，接下来让我们通过条件逻辑让脚本变得更智能！

在bash中，您可以使用`if`语句进行条件判断：

```bash
if [ "$1" == "ping" ]
then
    echo "pong"
fi
```

上述代码的含义是：*如果*第一个参数是"ping"，则输出"pong"。其语法规则较为严格，主要有以下原因：首先，*必须*在`if`后、`[`后以及`]`前保留空格（如果您熟悉C等语言，这点有所不同）；其次，`if`、`then`和`fi`必须位于不同行（或用分号分隔），不能将它们合并到同一语句中。另一个特殊之处是：`if`语句的结束标记是`fi`（即*if*的倒写），而非`endif`或`end`等常见形式。这是需要牢记的语法特性。

在本挑战中，请在`/home/hacker/solve.sh`编写一个脚本，要求：
- 接受一个参数
- *如果*参数是"pwn"，则输出"college"
- 对于其他任何输入，不输出任何内容

示例：

```sh
hacker@dojo:~$ bash /home/hacker/solve.sh pwn
college
hacker@dojo:~$ bash /home/hacker/solve.sh foo
hacker@dojo:~$
```

当脚本正确运行后，执行`/challenge/run`来获取flag！
----
注意： 想了解条件判断中除了字符串相等性之外还能检查哪些内容？可通过`help test`命令查看完整说明！

### 带默认情况的脚本编写

您目前的`if`语句已经能处理特定情况，但其他情况该如何处理呢？这时就需要用到`else`！
`else`子句会在`if`条件为假时执行：

```bash
if [ "$1" == "hello" ]
then
    echo "Hi there!"
else
    echo "I don't understand"
fi
```

请注意`else`没有条件——它会捕获所有之前未匹配的情况。它也不需要`then`语句。最后，`fi`需放置在`else`代码块之后，表示整个复合语句的结束！`else`子句是可选的：您在上一关卡中并未使用它，只有当您需要实现特定逻辑时才需要添加。
以下是一个实际示例：

```bash
if [ "$1" == "start" ]
then
    echo "Starting the service..."
else
    echo "Unknown command. Use 'start' to begin."
fi
```

在本挑战中，请在`/home/hacker/solve.sh`编写一个脚本，要求：
- 接受一个参数
- *如果*参数是"pwn"，则输出"college"
- 对于其他任何输入，输出"nope"
示例：

```sh
hacker@dojo:~$ bash /home/hacker/solve.sh pwn
college
hacker@dojo:~$ bash /home/hacker/solve.sh hack
nope
hacker@dojo:~$ bash /home/hacker/solve.sh anything
nope
hacker@dojo:~$
```

当脚本正确运行后，执行`/challenge/run`来获取flag！

### 带多重条件的脚本编写

您已经学会了如何使用单个`if`语句检查条件。但如果需要检查多个条件该怎么办呢？您可以使用`elif`（`else if`的缩写）：

```bash
if [ "$1" == "one" ]
then
    echo "1"
elif [ "$1" == "two" ]
then
    echo "2"
elif [ "$1" == "three" ]
then
    echo "3"
else
    echo "unknown"
fi
```

请注意，与`if`类似，*必须*在`elif`后使用`then`。最后的`else`会捕获所有未匹配的情况。
在本挑战中，请在`/home/hacker/solve.sh`编写一个脚本，要求：
- 接受一个参数
- *如果*参数是"hack"，则输出"the planet"
- *如果*参数是"pwn"，则输出"college"
- *如果*参数是"learn"，则输出"linux"
- 对于其他任何输入，输出"unknown"

示例：
```sh
hacker@dojo:~$ bash /home/hacker/solve.sh hack
the planet
hacker@dojo:~$ bash /home/hacker/solve.sh pwn
college
hacker@dojo:~$ bash /home/hacker/solve.sh learn
linux
hacker@dojo:~$ bash /home/hacker/solve.sh foo
unknown
hacker@dojo:~$
```

当脚本正确运行后，执行`/challenge/run`来获取flag！

----

**注意：**
编写脚本时请严格遵循示例中的空格规则。与许多其他语言不同，bash要求`[`和`]`与其他字符之间用空格分隔，否则无法解析条件。

### 阅读 Shell 脚本

编写Shell脚本的并不止您一人！它们对于执行简单的"系统级"任务非常实用，是开发人员和系统管理员常用的工具。事实上，典型Linux机器上有相当大比例的程序都是Shell脚本。

在本关卡中，我们将学习阅读Shell脚本。`/challenge/run`是一个Shell脚本，它要求您输入秘密密码，而该密码就硬编码在脚本本身中！请阅读该脚本（例如使用`cat`命令），找出密码并获取flag！

----

注意：
欢迎尝试阅读其他挑战的代码！阅读代码是学习新技能的关键策略，因为您可以通过观察特定功能的实现方式，并将这些策略复用到自己的脚本中。但请注意：有些程序文件是机器代码，人类无法直接阅读。您可以使用`file`命令进行区分，不过Linux Luminarium中几乎所有的挑战都是通过Shell脚本实现的，都可以安全地使用`cat`命令查看。
