# File Globbing

即使只进入几层目录，您可能已经厌倦了手动输入完整的文件路径。幸运的是，Shell 提供了解决方案：**通配符扩展**！这正是本模块要学习的内容。  

在执行您输入的命令之前，Shell 会先对其进行*扩展*，而通配符扩展就是其中一种。通过通配符扩展，您无需完整输入文件名或路径即可引用文件。下面我们来深入了解！

### 进一步阅读

Bash 参考手册中关于 [Shell 扩展](https://www.gnu.org/software/bash/manual/html_node/Shell-Expansions.html)的部分可能会有帮助。

## 挑战

### 使用 `*` 进行匹配

我们要学习的第一个通配符是 `*`。当 shell 在任何参数中遇到 `*` 字符时，会将其视为“通配符”，并尝试用匹配该模式的文件替换该参数。演示比解释更直观：

```console
hacker@dojo:~$ touch file_a
hacker@dojo:~$ touch file_b
hacker@dojo:~$ touch file_c
hacker@dojo:~$ ls
file_a	file_b	file_c
hacker@dojo:~$ echo Look: file_*
Look: file_a file_b file_c
```

当然，在这种情况下，通配符匹配到了多个参数，但它同样可以只匹配一个文件。例如：

```console
hacker@dojo:~$ touch file_a
hacker@dojo:~$ ls
file_a
hacker@dojo:~$ echo Look: file_*
Look: file_a
```

当没有文件匹配时，默认情况下 shell 会保持通配符不变：

```console
hacker@dojo:~$ touch file_a
hacker@dojo:~$ ls
file_a
hacker@dojo:~$ echo Look: nope_*
Look: nope_*
```

`*` 可以匹配文件名中除 `/` 或开头的 `.` 字符之外的任何部分。例如：

```console
hacker@dojo:~$ echo ONE: /ho*/*ck*
ONE: /home/hacker
hacker@dojo:~$ echo TWO: /*/hacker
TWO: /home/hacker
hacker@dojo:~$ echo THREE: ../*
THREE: ../hacker
```

现在，请亲自练习！从你的主目录开始，使用通配符将目录切换到 `/challenge`，但确保传递给 `cd` 的参数不超过四个字符！进入目录后，运行 `/challenge/run` 以获取 flag！

### 使用 `?` 进行匹配

接下来，我们来学习 `?` 通配符。
当 shell 在任何参数中遇到 `?` 字符时，会将其视为**单字符**通配符。
它的功能与 `*` 类似，但只匹配*一个*字符。
例如：

```console
hacker@dojo:~$ touch file_a
hacker@dojo:~$ touch file_b
hacker@dojo:~$ touch file_cc
hacker@dojo:~$ ls
file_a	file_b	file_cc
hacker@dojo:~$ echo Look: file_?
Look: file_a file_b
hacker@dojo:~$ echo Look: file_??
Look: file_cc
```

现在，请亲自练习！
从你的主目录开始，将目录切换到 `/challenge`，但在传递给 `cd` 的参数中使用 `?` 字符来替代 `c` 和 `l`！
进入目录后，运行 `/challenge/run` 以获取 flag！

### 使用 `[]` 进行匹配

接下来，我们将介绍 `[]`。
方括号本质上是 `?` 的受限形式，不同于匹配任意字符，`[]` 是用于匹配括号内指定的可能字符子集的通配符。
例如，`[pwn]` 将匹配字符 `p`、`w` 或 `n`。
例如：

```console
hacker@dojo:~$ touch file_a
hacker@dojo:~$ touch file_b
hacker@dojo:~$ touch file_c
hacker@dojo:~$ ls
file_a	file_b	file_c
hacker@dojo:~$ echo Look: file_[ab]
Look: file_a file_b
```

在此尝试！
我们已在 `/challenge/files` 中放置了一批文件。
将工作目录切换到 `/challenge/files`，并使用一个参数运行 `/challenge/run`，该参数需通过方括号通配符匹配 `file_b`、`file_a`、`file_s` 和 `file_h`！

### 使用 `[]` 匹配路径

通配符匹配是在*路径*基础上进行的，因此可以通过通配符参数扩展完整路径。
例如：

```console
hacker@dojo:~$ touch file_a
hacker@dojo:~$ touch file_b
hacker@dojo:~$ touch file_c
hacker@dojo:~$ ls
file_a	file_b	file_c
hacker@dojo:~$ echo Look: /home/hacker/file_[ab]
Look: /home/hacker/file_a /home/hacker/file_b
```

现在轮到你了。
我们再次在 `/challenge/files` 中放置了一批文件。
从你的主目录开始，使用一个参数运行 `/challenge/run`，该参数需通过方括号通配符匹配到 `file_b`、`file_a`、`file_s` 和 `file_h` 文件的绝对路径！

### 多个通配符

到目前为止，你每次只指定一个通配符，但其实可以做得更多！
Bash 支持在单个单词中扩展多个通配符。
例如：

```console
hacker@dojo:~$ cat /*fl*
pwn.college{YEAH}
hacker@dojo:~$
```

上述操作的过程是：shell 在 `/` 目录中查找所有以*任何内容*（包括空字符）开头，接着包含 `f` 和 `l`，并以*任何内容*（包括 `ag`，从而形成 `flag`）结尾的文件。

现在轮到你了。
我们在 `/challenge/files` 中放置了几个名称各异但令人愉快的文件。
请进入该目录（`cd` 到那里）并运行 `/challenge/run`，提供一个参数：一个简短（3 个字符或更少）且包含两个 `*` 通配符的单词，该通配模式需能匹配所有包含字母 `p` 的单词。

### 多种通配符

现在，让我们将前面学到的知识综合运用！
我们在 `/challenge/files` 中放置了几个名称各异但令人愉快的文件。
请进入该目录（`cd` 到那里），并运用你已掌握的通配符知识，编写一个简短（6 个字符或更少）的通配符模式，该模式（作为参数传递给 `/challenge/run` 时）将**仅**匹配文件 "challenging"、"educational" 和 "pwning"！

> **提示：**
请务必查看 `/challenge/files` 目录中文件的名称。
你是否发现了有助于构建通配符模式的规律？

### 排除性通配符

有时，你可能希望在通配符模式中排除某些文件！
幸运的是，`[]` 可以帮助你实现这一目的。
如果方括号内的第一个字符是 `!` 或（在较新版本的 bash 中）`^`，该通配符模式将进行反向匹配，即该方括号实例会匹配*不*在所列出的字符范围内的字符。
例如：

```console
hacker@dojo:~$ touch file_a
hacker@dojo:~$ touch file_b
hacker@dojo:~$ touch file_c
hacker@dojo:~$ ls
file_a	file_b	file_c
hacker@dojo:~$ echo Look: file_[!ab]
Look: file_c
hacker@dojo:~$ echo Look: file_[^ab]
Look: file_c
hacker@dojo:~$ echo Look: file_[ab]
Look: file_a file_b
```

掌握了这一知识后，请前往 `/challenge/files` 目录，并使用 `/challenge/run` 运行所有*不*以 `p`、`w` 或 `n` 开头的文件！

**注意：** 当 `!` 字符不是 `[]` 通配符的首字符时，它在 bash 中具有不同的特殊含义，因此如果遇到理解困难的情况，请记住这一点！`^` 没有这个问题，但在较旧的 shell 中可能不兼容。

### Tab 补全

尽管使用 `*` 来缩短命令行输入内容可能很诱人，但这可能导致错误。
你的通配符可能会扩展到非预期的文件，并且你可能直到 `rm` 命令已经开始运行才会发现这一点！
没有人能完全避免这类错误。

当你试图指定特定目标时，一个更安全的替代方案是*tab自动补全*。
如果你在 shell 中按 tab 键，它会尝试推断你将要输入的内容并自动补全。
自动补全功能非常有用，本次挑战将探索其在指定文件时的应用。

此挑战已将 flag 复制到 `/challenge/pwncollege` 中，你可以自由地 `cat` 该文件。
但你不能手动输入文件名：我们使用了一些高级技巧来确保你*必须*通过 tab 自动补全来输入它。
试试看吧！

```console
hacker@dojo:~$ ls /challenge
DESCRIPTION.md  pwncollege
hacker@dojo:~$ cat /challenge/pwncollege
cat: /challenge/pwncollege: No such file or directory
hacker@dojo:~$ cat /challenge/pwn<TAB>
pwn.college{HECK YEAH}
hacker@dojo:~$
```

当你按下 tab 键时，文件名将自动扩展，你就能读取该文件了。
祝你好运！

### 参数的 Tab 补全

考虑以下情况：

```console
hacker@dojo:~$ ls
flag  flamingo  flowers
hacker@dojo:~$ cat f<TAB>
```

存在多个匹配选项！
会发生什么？

具体行为会根据使用的 shell 及其配置选项而有所不同。
默认情况下，`bash` 会在出现多个匹配选项时自动扩展到第一个分歧点（在此例中为 `fl`）。
当你*第二次*按下 tab 键时，它会列出这些匹配选项。
而其他 shell 或配置则可能会在选项之间循环选择。

本次挑战提供了一个 `/challenge/files` 目录，其中包含一系列以 `pwncollege` 开头的文件。
请从 `/challenge/files/p` 左右开始使用 tab 自动补全，逐步定位到 flag 文件！

补全的匹配选项根据位置，即上下文不同，对应不同文件:
- 命令位置：补的是“可执行命令”（过滤掉普通文件）。
- 参数位置：补的是“文件名/路径”（不过滤普通文件）。

### 命令的 Tab 补全

Tab自动补全的功能远不止于文件操作！
你还可以使用Tab自动补全命令。
本关卡有一个以 `pwncollege` 开头的命令，运行它将为你提供 flag。
请输入 `pwncollege` 并按下 tab 键来自动补全该命令！


> **注意：**
你可以自动补全任何命令，但请务必小心：如果不仔细核对补全结果就贸然执行，一旦意外运行了错误的命令，可能会对你的 shell 环境造成严重破坏！


