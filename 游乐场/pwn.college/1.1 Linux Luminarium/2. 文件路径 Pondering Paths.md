# Pondering Paths

本模块将教你 Linux 文件路径的基础知识！

Linux 文件系统是一棵"树"。
也就是说，它有一个根（写作 `/`）。
文件系统的根是一个目录，每个目录都可以包含其他目录和文件。
你通过文件的*路径*来引用它们。
从文件系统根目录开始的路径以 `/`（即文件系统的根目录）开头，并描述了为找到文件而必须进入的一系列目录。
路径的每一部分都由另一个 `/` 分隔。

掌握了这些知识后，就可以去攻克下面的挑战了。

## 挑战

### 根

好的，文件系统从 `/` 开始。
在此之下，包含了大量的其他目录、配置文件、程序，以及最重要的 *flag*。
在本关卡中，我们在 `/` 目录下直接添加了一个名为 `pwn` 的程序，它将为你提供 flag。
你在此关卡需要做的就是运行这个程序！

你可以通过在命令行中提供程序的路径来运行它。
在本例中，你需要给出从 `/` 开始的精确路径，因此路径就是 `/pwn`。
这种从根目录开始的路径风格，被称为“绝对路径”。

开始挑战，启动终端，使用其绝对路径运行 `pwn` 程序，并夺取 Flag！
祝你好运！

### 程序和绝对路径

让我们来探索一个稍微复杂一点的路径！
除了上一关之外，pwn.college 中的挑战通常都在 `challenge` 目录下，而 `challenge` 目录本身又直接位于根目录 (`/`) 中。
因此，挑战目录的路径是 `/challenge`。
本关卡中挑战程序的名称为 `run`，它位于 `/challenge` 目录中。
因此，`run` 挑战程序的路径是 `/challenge/run`。

此关卡再次要求你通过调用其绝对路径来执行它。
你需要执行位于 `/` 目录下的 `challenge` 目录中的 `run` 文件。
如果你正确调用了该挑战程序，它将为你提供 flag。
祝你好运！

### 定位自己

Linux 文件系统包含大量目录和文件。
你可以使用 `cd`（*c*hange *d*irectory）命令并传入路径作为参数来在不同目录间导航，如下所示：

```console
hacker@dojo:~$ cd /some/new/directory
hacker@dojo:/some/new/directory$
```

这会影响到你进程（在本例中是 bash shell）的“当前工作目录”。
每个进程都有一个它当前所在的目录。
这么设计的原因将在本模块后续内容中变得清晰。

顺便说一下，现在你明白提示符中的 `~` 是什么意思了！
它显示了你的 shell 当前所在的路径。

此关卡将要求你从一个特定的路径（程序会告知你该路径）执行 `/challenge/run` 程序。
你需要先使用 `cd` 命令切换到该目录，然后重新运行挑战程序。
祝你好运！

### 定位其他位置

进行5次目录切换

### 隐式相对路径，从/

现在你已经熟悉了引用绝对路径和更改目录的概念。  
如果你在所有地方都使用绝对路径，那么你当前位于哪个目录其实并不重要，这一点你可能已经在前面三个挑战中发现了。

然而，当前工作目录对于**相对**路径至关重要。

- **相对路径**是指任何不从根目录开始的路径（即不以`/`开头）。
- 相对路径是**相对于**你的**当前工作目录**（current working directory，`cwd`）来解析的。
- 你的`cwd`是终端提示符当前所在的目录。

这意味着你指定特定文件的方式取决于终端提示符所在的位置。

假设我们想访问位于`/tmp/a/b/my_file`的某个文件：

- 如果我的`cwd`是`/`，那么该文件的相对路径是`tmp/a/b/my_file`。
- 如果我的`cwd`是`/tmp`，那么该文件的相对路径是`a/b/my_file`。
- 如果我的`cwd`是`/tmp/a/b/c`，那么该文件的相对路径是`../my_file`。其中`..`表示上级目录。

让我们在这里试试吧！  
你需要在当前工作目录为`/`的情况下，使用**相对路径**运行`/challenge/run`。  
对于这一关，我给你一个提示：  
你的相对路径以字母`c`开头 😊


### 显式相对路径，从 /

此前，你使用的相对路径是"裸"的：它直接指定了从当前目录要进入的子目录。
在本关卡中，我们将探索更明确的相对路径。

在包括 Linux 在内的大多数操作系统中，每个目录都有两个可以在路径中引用的隐含条目：`.` 和 `..`。
第一个，`.`，指代当前目录本身，因此以下绝对路径彼此都是完全相同的：

- `/challenge`
- `/challenge/.`
- `/challenge/./././././././././`
- `/./././challenge/././`

以下相对路径彼此也是完全相同的：

- `challenge`
- `./challenge`
- `./././challenge`
- `challenge/.`

当然，如果你的当前工作目录是 `/`，那么上述相对路径就等同于上述绝对路径。

本关卡将让你在相对路径中使用 `.`。
准备开始吧！

### 隐式相对路径

在这一关中，我们将进一步练习使用点（`.`）来引用路径。  
本挑战需要你在 `/challenge` 目录下运行。  
这里的情况会稍微复杂一些。

Linux 在你提供“裸路径”时会明确避免自动搜索当前目录。  
考虑以下情况：

```console
hacker@dojo:~$ cd /challenge
hacker@dojo:/challenge$ run
```

这*不会*调用 `/challenge/run`。  
这实际上是一种安全措施：如果 Linux 每次在你输入裸路径时都搜索当前目录下的程序，你可能会意外执行当前目录中恰好与核心系统工具同名的程序！  
因此，上述命令将产生以下错误：

```
bash: run: command not found
```

我们将在后续探讨这一概念背后的机制，但在这个挑战中，我们将学习如何在此场景下显式使用相对路径来启动 `run`。  
实现的方法是*告诉* Linux 你明确想要执行当前目录下的程序，使用像前几关那样的点（.）。  
现在就来试试吧！

### 家，甜蜜的家

每个用户都有一个*主目录*，通常位于文件系统的`/home`目录下。
在dojo环境中，你是`hacker`用户，你的主目录是`/home/hacker`。
主目录通常是用户存储大部分个人文件的地方。
当你完成pwn.college的挑战时，这里也将是你存储大部分解决方案的位置。

通常情况下，你的shell会话会以主目录作为当前工作目录开始。
观察初始提示符：

```console
hacker@dojo:~$
```

提示符中的`~`表示当前工作目录，其中`~`是`/home/hacker`的简写形式。
Bash提供并使用这种简写是因为，你大部分时间都会在主目录中操作。
因此，当bash发现参数开头以路径形式出现`~`时，会将其扩展为你的主目录。
例如：

```console
hacker@dojo:~$ echo LOOK: ~
LOOK: /home/hacker
hacker@dojo:~$ cd /
hacker@dojo:/$ cd ~
hacker@dojo:~$ cd ~/asdf
hacker@dojo:~/asdf$ cd ~/asdf
hacker@dojo:~/asdf$ cd ~
hacker@dojo:~$ cd /home/hacker/asdf
hacker@dojo:~/asdf$
```

请注意，`~`的扩展结果是*绝对*路径，且仅开头的`~`会被扩展。
这意味着，例如`~/~`将被扩展为`/home/hacker/~`，而不是`/home/hacker/home/hacker`。

有趣的是：`cd`命令会将你的主目录作为默认目标：

```console
hacker@dojo:~$ cd /tmp
hacker@dojo:/tmp$ cd
hacker@dojo:~$
```

现在轮到你来尝试了！
在这个挑战中，`/challenge/run`会将flag的副本写入你在命令行参数中指定的任何文件，但需满足以下约束条件：

1. 你的参数必须是绝对路径。
2. 路径必须位于你的主目录内。
3. 在扩展之前，你的参数长度必须为三个字符或更少。

重申：你必须将路径作为参数传递给`/challenge/run`，格式如下：

```console
hacker@dojo:~$ /challenge/run YOUR_PATH_HERE
```
