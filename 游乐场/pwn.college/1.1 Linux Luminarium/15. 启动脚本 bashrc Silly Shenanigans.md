# 趣味恶作剧

该模块将通过一系列深入探索加深你对 Linux 系统的理解。理解系统特性如何影响其安全性，是掌握其内部运作机制的重要途径。

## 挑战

### Bashrc 后门

当你的 shell 启动时，它会在你的主目录中寻找 `.bashrc` 文件并将其作为*启动脚本*执行。
你可以通过设置环境变量、调整 shell 配置等方式，自定义 `/home/hacker/.bashrc` 以添加实用功能。

但你*同样*可以将其用于*恶意*用途！
不知情受害者的 `.bashrc` 常被作为恶作剧的目标。
试想潜入朋友的电脑，在其 `.bashrc` 末尾添加一行 `echo "Hackers were here!"`。
这虽有趣，但相同能力也可用于更恶意的目的。
例如，恶意软件常以 `.bashrc` 等启动脚本为目标，以实现持久化驻留！

在本挑战中，我们将模拟你已入侵受害用户机器的场景！
该用户名为 `zardus`，主目录为 `/home/zardus`。
你作为 `hacker` 用户拥有对其 `.bashrc` 的写入权限，且 `zardus` 对 `/flag` 有读取权限。
受害者行为由脚本 `/challenge/victim` 模拟，你可随时运行此脚本观察受害者登录计算机的过程。
你能成功获取 flag 吗？

----

**提示：**
与你曾在 linux-命令链 中探索的脚本类似，`.bashrc` 本身即是 shell 脚本。
添加带命令的新行（如 `echo Hello Hackers`）即可使该命令被执行，因此你只需思考：什么命令能帮你获取 flag？

**注意：**
受害者的 `/home/zardus/.bashrc` 已包含大量内容——shell 启动过程较为复杂。
不必惊慌，只需将你的有效载荷附加到文件末尾即可！

**提示：**
需要以 `zardus` 身份调试方案？
在特权模式下，可使用 `sudo su --login zardus` 进入 Zardus 会话！

### 输入嗅探

在上一关卡中，你通过滥用 Zardus 的 `~/.bashrc` 使其为你执行命令。

本次任务中，Zardus 登录后不会将 flag 存放在可读文件中，而是会运行名为 `flag_checker` 的命令，通过手动输入 flag 进行验证。

你的任务是利用对 Zardus 的 `.bashrc` 的持续写入权限拦截该 flag。还记得你在 PATH 探秘(/linux-luminarium/path)模块中如何劫持命令的吗？能否运用此能力劫持 `flag_checker`？

----

**提示：**
Zardus 是否对你的劫持行为产生警觉？
他十分谨慎——会检查 `flag_checker` 的提示语 `Type the flag`。请确保你的劫持程序也输出该提示（例如使用 `echo "Type the flag"`）。除输出提示外，你的伪 `flag_checker` 可选用以下方案：a) 直接将 Zardus 的输入用 `cat` 输出到标准输出（如使用无参数 `cat`）；b) 用 `read` 读取输入至变量再 `echo` 输出。任选其一即可！

----

**提示：**
勿忘参照 权限认知(/linux-luminarium/permissions)模块所学，将伪 `flag_checker` 设置为*可执行文件*！

### 过度共享目录

好的，Zardus 这次学聪明了——他怎么会保留一个可写的 `.bashrc` 呢？
但更常见的情况是：同一系统上的用户为了便于协作，会将各自的主目录设置为*全局可写*。
这会导致什么问题？

问题在于 Linux 文件/目录权限的一个微妙特性：对目录拥有写入权限的任何人都可以*移动*和*删除*其中的文件。
例如，假设 Zardus 有一个用于协作的全局可写目录：

```sh
zardus@dojo:~$ mkdir /tmp/collab
zardus@dojo:~$ chmod a+w /tmp/collab
zardus@dojo:~$ echo "do pwn.college" > /tmp/collab/todo-list
```

随后攻击者（*尽管并不拥有 todo-list 文件*）进行了如下操作：

```sh
hacker@dojo:~$ ls -l /tmp/collab/todo-list
-rw-r--r-- 1 zardus zardus 15 Jun  6 13:12 /tmp/collab/todo-list
hacker@dojo:~$ rm /tmp/collab/todo-list
rm: remove write-protected regular file '/tmp/collab/todo-list'? y
hacker@dojo:~$ echo "send hacker money" > /tmp/collab/todo-list
hacker@dojo:~$ ls -l /tmp/collab/todo-list
-rw-r--r-- 1 hacker hacker 18 Jun  6 13:12 /tmp/collab/todo-list
hacker@dojo:~$
```

这看似违反直觉：`hacker` 对 `todo-list` 没有写入权限，但最终却能改变其内容。
但可以这样理解：文件与目录的关联关系最终存储在目录中，而对目录有写入权限的用户可以操纵这种关联。
显然，当重要目录被设为全局可写时，会带来安全隐患。

在本挑战中，为方便起见，Zardus 开放了他的主目录权限：

```sh
zardus@dojo:~$ chmod a+w /home/zardus
```

如你所知，该目录内存放大量敏感文件——*例如 `.bashrc`*！
你能否在仅拥有 `/home/zardus` 写入权限（而非 `/home/zardus/.bashrc` 权限）的情况下，复现先前的攻击？

### 诡计链接

好的，Zardus 这次学聪明了！
他不再共享主目录：尽管降低了便利性，Zardus 改为共享 `/tmp/collab` 目录。
他将该目录设为全局可写，并创建了一个记录邪恶命令的列表！

```sh
zardus@dojo:~$ mkdir /tmp/collab
zardus@dojo:~$ chmod a+w /tmp/collab
zardus@dojo:~$ echo "rm -rf /" > /tmp/collab/evil-commands.txt
```

在本挑战中，当你运行 `/challenge/victim` 时，Zardus 会将 `cat /flag` 添加到该命令列表中：

```sh
hacker@dojo:~$ /challenge/victim

Username: zardus
Password: **********
zardus@dojo:~$ echo "cat /flag" >> /tmp/collab/evil-commands.txt
zardus@dojo:~$ exit
logout

hacker@dojo:~$
```

回顾上一关卡可知，拥有 `/tmp/collab` 写入权限的 `hacker` 用户可以替换 `evil-commands.txt` 文件。
同时请记得 命令解析(/linux-luminarium/commands)模块所学：文件可以*链接*到其他文件。
如果 `hacker` 将 `evil-commands.txt` 替换为指向某个 `zardus` 可写入的敏感文件的符号链接，会发生什么？
混乱与恶作剧将随之而来！

你*清楚*需要链接的目标文件。
实施攻击并获取 `/flag`（本关卡中 Zardus 重新获得该文件的读取权限！）。

----

**提示：**
你需要运行两次 `/challenge/victim`：第一次让 `cat /flag` 写入目标位置，第二次触发命令执行！

**使用 `/tmp` 目录是否危险？**
尽管存在上述攻击方式，`/tmp` 目录仍可安全使用。
该目录*虽为全局可写*，但设置了特殊权限位：

```sh
hacker@dojo:~$ ls -ld /tmp
drwxrwxrwt 29 root root 1056768 Jun  6 14:06 /tmp
hacker@dojo:~$
```

末尾的 `t` 位即*粘滞位*。
粘滞位意味着该目录仅允许文件所有者重命名或删除目录中的文件，
其设计初衷正是为了防止此类攻击！
本挑战中的问题在于 Zardus 未对 `/tmp/collab` 启用粘滞位。
若启用该权限位即可修复此特定漏洞：

```sh
zardus@dojo:~$ chmod +t /tmp/collab
```

当然，全局可写目录等共享资源仍存在风险。
在绿带课程的 竞争条件(/system-security/race-conditions)章节中，你将深入探讨此类资源引发安全问题的多种可能！

### 进程参数嗅探

可怜的 Zardus；你已对他进行了相当彻底的入侵。
但他现已学聪明了，并加固了他的主目录安全！
游戏结束了？
未必！
当一台计算机存在多个账户时，人们常常忽略其*命令调用*可能泄露的数据类型。
请记住，当你执行 `ps aux` 时，会看到：

```sh
hacker@dojo:~$ ps aux
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
hacker         1  0.0  0.0   1128     4 ?        Ss   05:34   0:00 /sbin/docker-init -- /bin/sleep 6h
hacker         7  0.0  0.0   2736   580 ?        S    05:34   0:00 /bin/sleep 6h
hacker       102  0.4  0.0 723944 64660 ?        Sl   05:34   0:00 /usr/lib/code-server/lib/node /usr/lib/code-serve
hacker       138  3.3  0.0 968792 106272 ?       Sl   05:34   0:07 /usr/lib/code-server/lib/node /usr/lib/code-serve
hacker       287  0.0  0.0 717648 53136 ?        Sl   05:34   0:00 /usr/lib/code-server/lib/node /usr/lib/code-serve
hacker       318  3.3  0.0 977472 98256 ?        Sl   05:34   0:06 /usr/lib/code-server/lib/node --dns-result-order=
hacker       554  0.4  0.0 650560 55360 ?        Rl   05:35   0:00 /usr/lib/code-server/lib/node /usr/lib/code-serve
hacker       571  0.0  0.0   4600  4032 pts/0    Ss   05:35   0:00 /usr/bin/bash --init-file /usr/lib/code-server/li
hacker      1172  0.0  0.0   5892  2924 pts/0    R+   05:38   0:00 ps aux
hacker@dojo:~$
```

但如果这些命令的某个参数是敏感信息（如 flag 或密码），会发生什么？
这种情况确实存在，共享同一台机器的恶意用户（或能通过其他方式列出进程者）可窃取此类数据并加以利用！
这正是本挑战要探讨的场景。
Zardus 正在使用一个自动化脚本，并将其账户密码作为参数传递给该脚本。
同时 Zardus 被允许使用 `sudo`（因此可执行 `sudo cat /flag`！）。
请窃取该密码，登录 Zardus 的账户（回顾 用户解析(/linux-luminarium/users)模块中的 `su` 命令），并成功获取 flag！

### 配置窥探

即使用户未犯任何错误，仍可能无意中将自身置于风险之中。
例如，典型用户主目录中的许多文件*默认即为全局可读*，尽管这些文件常被用于存储敏感信息。
信不信由你，除非显式修改权限，否则你的 `.bashrc` 就是全局可读的！

```sh
hacker@dojo:~$ ls -l ~/.bashrc
-rw-r--r-- 1 hacker hacker 148 Jun  7 05:56 /home/hacker/.bashrc
hacker@dojo:~$
```

你或许会想“至少默认不是全局可写吧”！但即便是全局可读也可能造成损害。
由于 `.bashrc` 会在 shell 启动时被解析，人们通常在此处设置需要自定义的环境变量初始化项。
多数情况下这仅涉及如 `PATH` 之类无害内容，但有时人们会为方便存取而在此存储 API 密钥。
例如在本挑战中：

```sh
zardus@dojo:~$ echo "FLAG_GETTER_API_KEY=sk-XXXYYYZZZ" > ~/.bashrc
```

此后 Zardus 便可轻松引用该 API 密钥。
本关卡中，用户可使用有效 API 密钥获取 flag：

```sh
zardus@dojo:~$ flag_getter --key $FLAG_GETTER_API_KEY
Correct API key! Do you want me to print the key (y/n)? y
pwn.college{HACKED}
zardus@dojo:~$
```

自然，Zardus 将他的密钥存储在 `.bashrc` 中。
你能窃取该密钥并成功获取 flag 吗？

----

注意：
当你获取 API 密钥后，只需以 `hacker` 用户身份执行 `flag_getter` 即可。
本挑战的 `/challenge/victim` 仅用于场景营造，无需使用。
