# 权限感知

本模块将向您介绍 Linux 权限，这是您后续学习过程中最重要的部分之一，它中介不同用户对文件的访问。在 Linux 中，文件具有不同的权限或文件模式。您可以使用 `ls -l` 查看文件或目录的权限。让我们创建一些文件并查看它们的权限：

```sh
hacker@dojo:~$ mkdir pwn_directory
hacker@dojo:~$ touch college_file
hacker@dojo:~$ ls -l
total 4
-rw-r--r-- 1 hacker hacker    0 May 22 13:42 college_file
drwxr-xr-x 2 hacker hacker 4096 May 22 13:42 pwn_directory
hacker@dojo:~$
```


这里有很多信息，我们将在本模块中学习其中的大部分内容！现在，让我们从高层次看一下上面的输出：

#### 文件类型

每行的第一个字符代表文件类型。对于 `pwn_directory`，`d` 表示它是一个目录；对于 `college_file`，`-` 表示它是一个普通文件。还有其他类型，您将在 pwn.college 的学习过程中遇到其中一些。

#### 权限

接下来的九个字符是文件或目录的实际访问权限，分为三组：前三个字符表示文件所有者（称为“所有者”）对文件的权限，中间三个字符表示文件所属组（称为“组”）对文件的权限，最后三个字符表示所有其他访问（例如其他用户和其他组）对文件的权限。我们将在本模块后面详细学习这些内容。

#### 所有权信息

有两列显示拥有文件的*用户*（本例中为用户 `hacker`）和拥有文件的*组*（本例中同样为组 `hacker`）。您将在这里进行相关操作！

----

在本模块中，您将练习识别权限。让我们开始吧！

访问控制模型中，读取低级别，写入高级别，并且级别中还拥有标签分类。

## 挑战

### 更改文件所有权

首先：文件所有权。
Linux 中的每个文件都由系统上的一个用户拥有。
在您的日常使用中，最常见的文件所有者就是您每天登录的用户。

在共享系统（例如计算机实验室）上，可能有许多拥有不同用户账户的人，他们各自在自己的主目录中拥有自己的文件。
但即使在非共享系统（例如您的个人电脑）上，Linux 仍然有许多用于不同任务的“服务”用户账户。

两个最重要的用户账户是：

1.  您的用户账户！在 pwn.college 上，这是 `hacker` 用户，无论您的用户名是什么。
2.  `root`。这是管理员账户，并且在大多数安全场景中，是最终目标。如果您控制了 `root` 用户，那么您几乎肯定已经实现了您的黑客目标！

那又怎样呢？
事实证明，我们阻止您直接执行 `cat /flag` 的方法是：让 `/flag` 文件由 `root` 用户拥有，配置其权限使得其他用户无法读取它（您将在后面学习如何操作），并配置实际的挑战以 `root` 用户身份运行（您同样将在后面学习如何操作）。
结果是，当您执行 `cat /flag` 时，您会得到：

```sh
hacker@dojo:~$ ls -l /flag
-r-------- 1 root root 53 Jul  4 04:47 /flag
hacker@dojo:~$ cat /flag
cat: /flag: Permission denied
hacker@dojo:~$
```


在这里，您可以看到该 flag 由 `root` 用户（该行中的第一个 `root`）和 `root` 组（该行中的第二个 `root`）拥有。
当我们尝试以 `hacker` 用户身份读取它时，我们被拒绝了。
然而，如果我们是 `root`（黑客的梦想！），读取这个文件将毫无问题：

```sh
root@dojo:~# cat /flag
pwn.college{demo_flag}
root@dojo:~#
```


有趣的是，我们可以更改文件的所有权！
这是通过 `chown` (**ch**ange **own**er，更改所有者) 命令完成的：

```sh
chown [username] [file]
```


通常，`chown` 只能由 `root` 用户调用。
让我们再次假装我们是 `root`（这永远不会过时！），并观看一个典型的 `chown` 用法：

```sh
root@dojo:~# mkdir pwn_directory
root@dojo:~# touch college_file
root@dojo:~# ls -l
total 4
-rw-r--r-- 1 root root    0 May 22 13:42 college_file
drwxr-xr-x 2 root root 4096 May 22 13:42 pwn_directory
root@dojo:~# chown hacker college_file
root@dojo:~# ls -l
total 4
-rw-r--r-- 1 hacker root    0 May 22 13:42 college_file
drwxr-xr-x 2 root   root 4096 May 22 13:42 pwn_directory
root@dojo:~#
```


`college_file` 的所有者已被更改为 `hacker` 用户，现在 `hacker` 用户可以对该文件执行 `root` 用户原本能够对其执行的任何操作！
如果这是 `/flag` 文件，那就意味着 `hacker` 用户将能够读取它！

在这一关中，我们将练习将 `/flag` 文件的所有者更改为 `hacker` 用户，然后读取 flag。
仅针对此挑战，我设置了允许您作为 `hacker` 用户随意使用 chown（再次强调，通常这需要您是 `root` 用户）。
明智地使用此权限，尽情使用 chown 吧！

### 组和文件

共享即是关爱，而共享是 Linux 设计的内置特性。
文件同时拥有一个所属*用户*和一个所属*组*。
一个组可以包含多个用户，而一个用户可以是多个组的成员。

您可以使用 `id` 命令查看您属于哪些组：

```sh
hacker@dojo:~$ id
uid=1000(hacker) gid=1000(hacker) groups=1000(hacker)
hacker@dojo:~$
```

这里，`hacker` 用户*仅*在 `hacker` 组中。
组最常见的用途是控制对不同系统资源的访问。
例如，pwn.college 中的“特权模式”会授予您 root 访问权限，以便进行更好的调试等。
这是通过在您启动特权模式时为您分配一个额外的组来实现的：

```sh
hacker@dojo:~$ id
uid=1000(hacker) gid=1000(hacker) groups=1000(hacker),27(sudo)
hacker@dojo:~$
```

一个典型的 Linux 桌面系统的主要用户通常属于*很多*组。
例如，这是 Zardus 的桌面系统：

```sh
zardus@yourcomputer:~$ id
uid=1000(zardus) gid=1000(zardus) groups=1000(zardus),24(cdrom),25(floppy),27(sudo),29(audio),30(dip),44(video),46(plugdev),100(users),106(netdev),114(bluetooth),117(lpadmin),120(scanner),995(docker)
zardus@yourcomputer:~$
```

所有这些组使 Zardus 能够读取 CD 和软盘、管理系统、播放音乐、向视频监视器绘图、使用蓝牙等等。
通常，这种访问控制是通过文件系统上的组所有权来实现的！
例如，图形输出可以通过特殊的 `/dev/fb0` 文件来完成：

```sh
zardus@yourcomputer:~$ ls -l /dev/fb0
crw-rw---- 1 root video 29, 0 Jun 30 23:42 /dev/fb0
zardus@yourcomputer:~$
```

这个文件是一个特殊的*设备文件*（类型 `c` 表示它是一个“字符设备”），与它交互会导致显示输出的改变（而不是像普通文件那样改变磁盘存储！）。
Zardus 在他机器上的用户账户可以与之交互，因为该文件的组所有权是 `video`，而 Zardus 是 `video` 组的成员。

不过，道场中的 `/flag` 文件就没这么幸运了！
考虑以下情况：

```sh
hacker@dojo:~$ id
uid=1000(hacker) gid=1000(hacker) groups=1000(hacker)
hacker@dojo:~$ ls -l /flag
-r--r----- 1 root root 53 Jul  4 04:47 /flag
hacker@dojo:~$ cat /flag
cat: /flag: Permission denied
hacker@dojo:~$
```

这里，flag 文件由 `root` 用户和 `root` 组拥有，而 `hacker` 用户既不是 `root` 用户，也不是 `root` 组的成员，因此无法访问该文件。
幸运的是，可以使用 `chgrp` (change group，更改组) 命令来更改组所有权！
除非您是文件的所有者*并且*是新组的成员，否则这通常需要 `root` 访问权限，所以让我们以 `root` 身份来查看一下：

```sh
root@dojo:~# mkdir pwn_directory
root@dojo:~# touch college_file
root@dojo:~# ls -l
total 4
-rw-r--r-- 1 root root    0 May 22 13:42 college_file
drwxr-xr-x 2 root root 4096 May 22 13:42 pwn_directory
root@dojo:~# chgrp hacker college_file
root@dojo:~# ls -l
total 4
-rw-r--r-- 1 root hacker    0 May 22 13:42 college_file
drwxr-xr-x 2 root root   4096 May 22 13:42 pwn_directory
root@dojo:~#
```

在本关中，我已将 flag 设置为可被其所属的任何组读取，但目前该组是 `root`。
幸运的是，我还使您能够以 `hacker` 用户身份调用 `chgrp`！
更改 flag 文件的组所有权，然后读取 flag！

### 组名趣味操作

在前面的关卡中，您可能已经注意到您的 `hacker` 用户是 `hacker` 组的成员，而 `zardus` 是 `zardus` 组的成员。
Linux 中有一个惯例，即每个用户都有自己的组，但情况并非必须如此。
例如，许多计算机实验室会将其所有用户都放入一个共享的 `users` 组中。

关键是，您之前使用过 `hacker` 作为组名，但在本关中，那将行不通。
我仍然允许您使用 `chgrp`，但我已将您的用户所属的组名进行了随机化。
您需要使用 `id` 命令来找出该组名，然后使用 `chgrp` 走向成功！

### 更改权限

现在我们已精通所有权。
让我们谈谈硬币的另一面：文件权限。
回顾我们的示例：

```sh
hacker@dojo:~$ mkdir pwn_directory
hacker@dojo:~$ touch college_file
hacker@dojo:~$ ls -l
total 4
-rw-r--r-- 1 hacker hacker    0 May 22 13:42 college_file
drwxr-xr-x 2 hacker hacker 4096 May 22 13:42 pwn_directory
hacker@dojo:~$
```

提醒一下，第一个字符是文件类型。
接下来的九个字符是文件或目录的实际访问权限，分为三组：前三个字符表示所有者的权限（现在您理解了！），中间三个字符表示所属组的权限（现在您也理解了！），最后三个字符表示所有其他访问（例如其他用户和其他组）对文件的权限。

每组三个字符中的每一个代表对不同操作的权限：

```
r - user/group/other can read the file (or list the directory)
w - user/group/other can modify the files (or create/delete files in the directory)
x - user/group/other can execute the file as a program (or can enter the directory, e.g., using `cd`)
- - nothing 
```

对于上面的 `college_file`，权限条目 `rw-r--r--` 解码为：

- `r`：拥有该文件的用户（用户 `hacker`）可以读取它
- `w`：拥有该文件的用户（用户 `hacker`）可以写入它
- `-`：拥有该文件的用户（用户 `hacker`）*不能*执行它
- `r`：属于文件所属组（组 `hacker`）的用户可以读取它
- `-`：属于文件所属组（组 `hacker`）的用户*不能*写入它
- `-`：属于文件所属组（组 `hacker`）的用户*不能*执行它
- `r`：所有其他用户可以读取它
- `-`：所有其他用户*不能*写入它
- `-`：所有其他用户*不能*执行它

现在，让我们看看 `/flag` 的默认权限：

```sh
hacker@dojo:~$ ls -l /flag
-r-------- 1 root root 53 Jul  4 04:47 /flag
hacker@dojo:~$
```

这里，只设置了一个权限位：所有者（本例中为 `root`）的 `r`ead（读取）权限。
所属组（`root` 组）的成员和所有其他用户都无法访问该文件。

您可能想知道，如果文件没有组访问权限，`chgrp` 关卡是如何工作的。
嗯，对于那些关卡，我设置了不同的权限：

```sh
hacker@dojo:~$ ls -l /flag
-r--r----- 1 root root 53 Jul  4 04:47 /flag
hacker@dojo:~$
```

组有访问权限！
这就是为什么 `chgrp` 更改文件所属组后，您就能读取该文件。

无论如何！
与所有权类似，文件权限也可以更改。
这是通过 `chmod` (change mode，更改模式) 命令完成的。
chmod 的基本用法是：

```sh
chmod [OPTIONS] MODE FILE
```

您可以通过两种方式指定 `MODE`：一种是修改现有的权限模式，另一种是使用全新的模式覆盖旧模式。

在本关中，我们将介绍前者：修改现有模式。
`chmod` 允许您使用 `WHO`+/-`WHAT` 的模式格式来调整权限，其中 `WHO` 是 user/group/other，`WHAT` 是 read/write/execute。
例如，要为所属*用户*添加*读取*访问权限，您可以指定模式为 `u+r`。
为 `g`roup（组）和 `o`ther（其他用户）或 `a`ll（所有用户）添加 `w`rite（写入）和 e`x`ecute（执行）权限的指定方式相同。
更多示例：

- `u+r`，如上所述，为用户权限添加读取权限
- `g+wx` 为组权限添加写入和执行权限
- `o-w` 为其他用户*移除*写入权限
- `a-rwx` 为用户、组和其他所有用户移除所有权限

所以：

```sh
root@dojo:~# mkdir pwn_directory
root@dojo:~# touch college_file
root@dojo:~# ls -l
total 4
-rw-r--r-- 1 root root    0 May 22 13:42 college_file
drwxr-xr-x 2 root root 4096 May 22 13:42 pwn_directory
root@dojo:~# chmod go-rwx *
root@dojo:~# ls -l
total 4
-rw------- 1 hacker root    0 May 22 13:42 college_file
drwx------ 2 root   root 4096 May 22 13:42 pwn_directory
root@dojo:~#
```

在此挑战中，您必须更改 `/flag` 文件的权限才能读取它！
通常，您需要是文件的所有者才能更改其权限，但我在本关中使 `chmod` 命令变得无所不能，即使您是 `hacker` 用户，也可以 `chmod` 任何您想要修改的文件。
这是一种终极权力。
`/flag` 文件由 `root` 拥有，您无法更改这一点，但您可以使其可读。
去解决这个挑战吧！

### 可执行文件

到目前为止，您主要处理的是*读取*权限。
这很合理，因为您一直在使 `/flag` 文件可读以便读取它。
在本关中，我们将探索执行权限。

当您调用一个程序时，例如 `/challenge/run`，Linux 只有在您对该程序文件拥有执行访问权限时才会实际执行它。
考虑以下情况：

```sh
hacker@dojo:~$ ls -l /challenge/run
-rwxr-xr-x 1 root root    0 May 22 13:42 /challenge/run
hacker@dojo:~$ /challenge/run
Successfully ran the challenge!
hacker@dojo:~$
```

在这种情况下，`/challenge/run` 能够运行，因为它对 `hacker` 用户是可执行的。
由于该文件由 `root` 用户和 `root` 组拥有，这就要求在 `other`（其他用户）权限上设置了执行位。
如果我们移除这些权限，执行将会失败！

```sh
hacker@dojo:~$ chmod o-x /challenge/run
hacker@dojo:~$ ls -l /challenge/run
-rwxr-xr-- 1 root root    0 May 22 13:42 /challenge/run
hacker@dojo:~$ /challenge/run
bash: /challenge/run: Permission denied
hacker@dojo:~$
```

在此挑战中，`/challenge/run` 程序将向您提供 flag，但您必须首先使其可执行！
记住您的 `chmod` 命令，让 `/challenge/run` 告诉您 flag！

### 权限调整实践

您认为您会使用 `chmod` 吗？让我们来练习吧！

此挑战将要求您连续多次以特定方式更改 `/challenge/pwn` 文件的权限。
如果您设置的权限错误，游戏将重置，您可以重试。
如果您连续八次正确设置权限，挑战将允许您使用 `chmod` 使 `/flag` 对您自己可读 :-)
启动 `/challenge/run` 开始吧！

### 权限设置实践

除了像上一关那样添加和移除权限外，`chmod` 也可以直接设置权限，完全覆盖旧的权限。
这是通过使用 `=` 而不是 `-` 或 `+` 来实现的。
例如：

- `u=rw` 为用户设置读取和写入权限，并清除执行权限
- `o=x` 仅为其他所有用户设置执行权限，清除读取和写入权限
- `a=rwx` 为用户、组和其他所有用户设置读取、写入和执行权限！

但是，如果您想以不同于组权限的方式来设置用户权限呢？
比如说，您想为所属用户设置 `rw`，但只为所属组设置 `r`？
您可以通过使用 `,` 将多个模式链接到 `chmod` 命令来实现！

- `chmod u=rw,g=r /challenge/pwn` 将用户权限设置为读取和写入，将组权限设置为只读
- `chmod a=r,u=rw /challenge/pwn` 将用户权限设置为读取和写入，将组和其他所有用户的权限设置为只读

此外，您可以使用 `-` 来清零权限：

- `chmod u=rw,g=r,o=- /challenge/pwn` 将用户权限设置为读取和写入，将组权限设置为只读，并将其他所有用户的权限完全移除

请记住，出现在 `=` 之后的 `-` 所处的上下文，与它直接出现在 `u`、`g` 或 `o` 之后（在这种情况下，它将导致移除特定的权限位，而不是所有权限）是不同的。

本关扩展了前一关的内容，要求进行更彻底的权限更改，您将需要使用 `=` 和 `,` 链接模式来实现。
祝您好运！

### SUID权限位

正如您在上一模块中所探索的，在许多情况下，非 `root` 用户需要提升权限才能执行某些系统任务。
系统管理员不可能在用户每次想要执行只有 `root`/sudoers 才能做的任务时都去提供密码。
取而代之的是，"设置用户ID"（SUID）权限位允许用户以该程序文件所有者的身份运行程序。

这实际上是用于让您运行的挑战程序能够读取 flag 的机制，或者，在 pwn.college 之外，用于启用系统管理工具（如 `su`、`sudo` 等）的机制。
具有 SUID 位的文件的权限看起来像这样：

```sh
hacker@dojo:~$ ls -l /usr/bin/sudo
-rwsr-xr-x 1 root root 232416 Dec 1 11:45 /usr/bin/sudo
hacker@dojo:~$
```

原本是可执行位的位置出现的 `s` 表示该程序是*带有 SUID* 可执行的。
这意味着，无论哪个用户运行该程序（只要他们有执行权限），该程序都将以其所有者用户（在本例中为 `root` 用户）的身份执行。

作为文件的所有者，您可以使用 chmod 设置文件的 SUID 位：

```sh
chmod u+s [program]
```

但要小心！
将 SUID 位授予由 `root` 拥有的可执行文件，可能会为攻击者提供一个可能成为 `root` 的攻击向量。
您将在程序滥用模块中了解更多相关信息。

现在，我们将允许您向 `/challenge/getroot` 程序添加 SUID 位，以便为您生成一个 `root` shell，让您自己使用 `cat` 命令读取 flag！
