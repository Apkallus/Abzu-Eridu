本地复刻 c 源码程序在编译后可能不拥有原版的工具链与符号，尝试复制 /challenge/server 可执行程序后使用 LD_PRELOAD 进行库打桩：
- LD_PRELOAD 概念：
    对动态链接的 ELF（如 dynamically linked），程序运行时会先启动动态链接器 `ld-linux`，由它来加载依赖库（`libc` 等）并解析符号（比如 `bind`, `setresuid` 这些函数地址）。
    - `LD_PRELOAD=/path/to/x.so` 会告诉动态链接器：先把这个 .so 加载进来
    - 如果这个 `.so` 里也定义了 `bind()`，那么程序里对 `bind()` 的调用会优先命中这个版本（即 symbol interposition 符号劫持）
    - 在自己的包装函数 `bind()` 中：
        - 改参数（把特权端口 80 改成 8080）
        - 再去调用“真正的 `bind`”（通过 `dlsym(RTLD_NEXT, "bind")` 拿到 `libc` 里的原始实现）
    - 对于 `__attribute__((constructor))`，会被编译器/链接器把函数地址写进可执行文件的 `.init_array`。
        `void __attribute__((constructor)) init() {...}`
        - 程序启动时，动态链接器按 `.init_array` 里写死的地址 call 过去执行
        - 能做的是：改变它的条件 / 改变它调用到的库函数的行为 / 或 patch 二进制。
            - preload 的库通常先于主程序 constructor 执行（同属动态加载初始化阶段，但顺序上常见是“先库后主程序”）。

    重要限制:
    - 对 setuid/setgid 程序，LD_PRELOAD 通常会被忽略/清理（安全机制）。“拷贝版”（不再是 setuid），所以可以用它做本地调试。
    - 只影响当前进程，不会改磁盘上的二进制。
- 修改内容：
    - `bind(server_fd, ... port 80 ...)`
        把端口 80 改成一个非特权端口（如 8080/18080），避免 EACCES。

    ```c
    int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {

        // 设置与原始函数的参数与返回值类型相同的函数指针
        // dlsym(RTLD_NEXT, "bind") 在库打桩中，于当前的自定义构造库后（原库）查找函数，从而得到原始函数以包装。
        static int (*real_bind)(int, const struct sockaddr*, socklen_t) = 0;
        if (!real_bind) real_bind = dlsym(RTLD_NEXT, "bind");

        // 调用 bind 时，将结构 struct sockaddr_in 转为 struct sockaddr
        // 此处逆向转回以访问端口字段
        struct sockaddr_in tmp = *(const struct sockaddr_in*)addr;

        // 修改原端口 80，到自选端口
        // 填入字段时使用 htons(80) 设置字节顺序，此处使用 ntohs 转回数字后比较
        if (ntohs(tmp.sin_port) == 80) {
            tmp.sin_port = htons(9999);
            return real_bind(sockfd, (struct sockaddr*)&tmp, sizeof(tmp));
        }
        
        // 修改参数后调用原函数
        return real_bind(sockfd, addr, addrlen);
    }
    ```

    - `setresuid/setresgid`
        设置包装函数返回 0，让程序继续跑下去。

    - disable_aslr 构造函数

        分析：
        ```c
        int current = personality(-1);                 // 读当前mask
        assert(current_personality != -1);      // 若mask已被修改则抛出异常
        if ((current & ADDR_NO_RANDOMIZE) == 0) {  // 从mask中提取flag位，如果“未禁用 ASLR”进入分支
            personality(current | ADDR_NO_RANDOMIZE); // 就把“禁用 ASLR”这个flag位设置到当前mask中
            execve("/proc/self/exe", ...);         // 重新启动，让新 personality 生效
        }
        ```
        导致此程序仅可执行一次。

        构造：
        ```c
        int current = personality(-1);                
        if ((current & ADDR_NO_RANDOMIZE) == 0) {  
            personality(current | ADDR_NO_RANDOMIZE);      
        }
        ```
        移除assert，并设置禁用空间随机化这个flag位

- 将c文件打包为共享库
    `gcc -shared -fPIC -ldl -o preload.so preload.c`
    - `-shared`：指示编译器生成共享库。
    - `-fPIC`：生成位置无关代码，这是共享库的硬性要求。
    - `-ldl`：链接 libdl 库，如果代码使用了 dlsym，则必须添加此选项。

    避免当前环境的包装函数污染导致的不匹配：
    `env -i PATH=/usr/bin:/bin /usr/bin/gcc -shared -fPIC -ldl -o preload.so preload.c`
    - `env -i PATH=/usr/bin:/bin`：用“干净环境”启动，避免继承可能影响链接的变量。
    - `/usr/bin/gcc`：使用 Ubuntu 的 gcc/ld

- 使用库打桩,命令行中设置 LD_PRELOAD 环境变量后启动目标程序
    `LD_PRELOAD=./preload.so /home/hacker/server`

- 使用gdb调试时，启动gdb后设置环境变量
    `(gdb) set environment LD_PRELOAD=/home/hacker/preload.so`