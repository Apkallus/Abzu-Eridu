工具链：
- 设置寄存器（作为函数参数）
- 调用现成函数（PLT/重定位表（GOT）/函数指针）
- 栈迁移（stack pivot）到更大的可控内存
    1. 设置 `rbp`
    2. `leave ; ret` 相当于 `mov rsp, rbp ; pop rbp ; ret`
        - :warning: 在设置 `rsp` 后，当前栈已经迁移至 `.bss` 伪栈，后续的 `pop rbp ; ret` 将对伪栈作用。即，应当设置在伪栈中。


查找工具链：
- `objdump -R /challenge/server | egrep ' read@| write@'`  
    在程序被动态链接时，像 close、accept、read、write 这些来自 libc 的函数地址在程序启动前是未知的，它们被存储在全局偏移表（GOT）中。

    很多 ret2csu 的 “call 段”形如：

    `call QWORD PTR [r15+rbx*8]`
    它需要你给一个“内存地址 r15”，里面存着函数指针。GOT 表项正好满足：

    `write@GOT/read@GOT` 里存着动态链接解析后的 `write/read` 实际地址

- `readelf -S /challenge/server | egrep '\.bss|\.data'`
    查 `.bss/.data` 等“固定可写内存”:

    `.bss` 是未初始化全局变量区：可写、地址固定（No PIE 时）、空间通常够大

    常用于：
    - 放其他阶段 ROP
    - 放字符串
    - 放 `read()` 读入的更多 payload（避免受最初文件长度/栈空间限制） 

- `ROPgadget --binary /challenge/server | grep -n "leave ; ret"`  
    ROPgadget：批量搜 gadget

    区分“干净 gadget”和“脏 gadget”
    - 干净：`leave ; ret` 前面没有别的会崩的副作用
    - 脏：像 `add byte ptr [rax], al ; leave ; ret`  
        这会写内存 `[rax]`，`rax` 不可控时非常容易 Bus error   

- `ret2csu` 的两段:

    - `pop` 段：`ROPgadget --binary /challenge/server | grep -E "pop rbx|pop r12|pop r13|pop r14|pop r15"`  
        一次性从栈里 `pop` 出一组寄存器（包括 `r12/r13/r14/r15` 等）

    
    - `call` 段：`objdump -d -M intel /challenge/server | grep -n "__libc_csu_init" -A80`  
        把 `r12/r13/r14` 搬运到 `edi/rsi/rdx`，再` call [r15+rbx*8]` 

       - `__libc_csu_init` 函数的末尾包含一系列连续的 pop 指令和 mov 指令。这些指令片段可以组合起来，实现对 rdi、rsi、rdx 这三个关键参数寄存器的控制。  


复刻程序构造工具链地址：
- ret2csu - pop 设置被调寄存器
    `objdump -d -M intel server | grep -n "__libc_csu_init" -A80`
    
    ```c
    972-  401faa:   5b                      pop    rbx
    973-  401fab:   5d                      pop    rbp
    974-  401fac:   41 5c                   pop    r12
    975-  401fae:   41 5d                   pop    r13
    976-  401fb0:   41 5e                   pop    r14
    977-  401fb2:   41 5f                   pop    r15
    978-  401fb4:   c3                      ret
    ```
- ret2csu - call 从被调寄存器中设置调用寄存器并调用函数
    `objdump -d -M intel server | grep -n "__libc_csu_init" -A80`

    ```c
    964-  401f90:   4c 89 f2                mov    rdx,r14
    965-  401f93:   4c 89 ee                mov    rsi,r13
    966-  401f96:   44 89 e7                mov    edi,r12d
    967-  401f99:   41 ff 14 df             call   QWORD PTR [r15+rbx*8]
    968-  401f9d:   48 83 c3 01             add    rbx,0x1
    969-  401fa1:   48 39 dd                cmp    rbp,rbx
    970:  401fa4:   75 ea                   jne    401f90 <__libc_csu_init+0x40>
    971-  401fa6:   48 83 c4 08             add    rsp,0x8
    972-  401faa:   5b                      pop    rbx
    973-  401fab:   5d                      pop    rbp
    974-  401fac:   41 5c                   pop    r12
    975-  401fae:   41 5d                   pop    r13
    976-  401fb0:   41 5e                   pop    r14
    977-  401fb2:   41 5f                   pop    r15
    978-  401fb4:   c3                      ret
    ```
- 函数/片段地址
    本地复刻服务器 && 原版服务器：
    ```sh
    objdump -R server | egrep ' read@| write@'
    0000000000403f30 R_X86_64_JUMP_SLOT  write@GLIBC_2.2.5
    0000000000403f70 R_X86_64_JUMP_SLOT  read@GLIBC_2.2.5
    0000000000403f68 R_X86_64_JUMP_SLOT  close@GLIBC_2.2.5
    0000000000403fc8 R_X86_64_JUMP_SLOT  accept@GLIBC_2.2.5

    hacker@integrated-security~the-watering-hole:~$ readelf -S server | egrep '\.bss|\.data'
    [24] .data             PROGBITS         0000000000404000  00003000
    [25] .bss              NOBITS           0000000000404020  00003010

    ROPgadget --binary server | grep -n "pop rbp"
    85:0x000000000040145d : pop rbp ; ret

    ROPgadget --binary server | grep -n "leave ; ret"
    62:0x000000000040154a : leave ; ret

    
    (gdb) x/30gx $rsp
    0x404020 <stdout@@GLIBC_2.2.5>: 0x00007ffff7faf6a0      0x0000000000000000
    0x404030 <stdin@@GLIBC_2.2.5>:  0x00007ffff7fae980      0x0000000000000000
    0x404040 <stderr@@GLIBC_2.2.5>: 0x00007ffff7faf5c0      0x0000000000000000
    0x404050:       0x0000000000000000      0x0000000000000000
    ```
    - bss中的 `stdin/stdout/stderr` 这些不是“文件描述符 0/1/2”，而是 glibc 里的全局变量 `FILE *stdin, *stdout, *stderr`。你的可执行文件如果引用了它们，动态链接器会通过 COPY relocation（拷贝重定位） 在主程序的 `.bss/.data` 里为它们分配槽位，并在启动时把 `libc` 里的初始值“拷贝”过来，于是它们正好落在 `.bss` 起始处:
        ```sh
        hacker@integrated-security~the-watering-hole:~$ nm server | egrep 'stdin|stdout|stderr'
        0000000000402000 R _IO_stdin_used
        0000000000404040 B stderr@@GLIBC_2.2.5
        0000000000404030 B stdin@@GLIBC_2.2.5
        0000000000404020 B stdout@@GLIBC_2.2.5
        ```
        - 使用bss时不应当设置为bss的起始处