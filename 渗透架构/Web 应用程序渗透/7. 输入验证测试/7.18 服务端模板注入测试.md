# 服务端模板注入测试

## 概述

Web 应用通常使用服务器端模板技术（Jinja2、Twig、FreeMarker 等）生成动态 HTML 响应。**服务器端模板注入（SSTI）漏洞**会在用户输入以不安全方式嵌入模板时出现，导致服务器发生远程代码执行。任何支持高级用户自定义标记的功能均可能受 SSTI 影响，包括维基页面、评论系统、营销应用和内容管理系统（CMS）等。部分模板引擎采用沙箱机制、允许列表等防护措施来抵御 SSTI 攻击。

### Twig 示例

以下示例摘自 [Extreme Vulnerable Web Application](https://github.com/s4n7h0/xvwa) 项目。

```php
public function getFilter($name)
{
        [snip]
        foreach ($this->filterCallbacks as $callback) {
        if (false !== $filter = call_user_func($callback, $name)) {
            return $filter;
        }
    }
    return false;
}
```

在 getFilter 函数中，`call_user_func($callback, $name)` 存在服务器端模板注入（SSTI）漏洞：`name` 参数从 HTTP GET 请求中获取并由服务器执行：

![SSTI XVWA 示例](images/SSTI_XVWA.jpeg)\
*图 WSTG 4.7.18-1：SSTI XVWA 示例*

### Flask/Jinja2 示例

以下示例使用 Flask 和 Jinja2 模板引擎。`page` 函数从 HTTP GET 请求接收 'name' 参数，并渲染包含 `name` 变量内容的 HTML 响应：

```python
@app.route("/page")
def page():
    name = request.values.get('name')
    output = Jinja2.from_string('Hello ' + name + '!').render()
    return output
```

这段代码片段存在跨站脚本攻击（XSS）漏洞，同时也存在服务器端模板注入（SSTI）漏洞。在 `name` 参数中使用以下负载：

```bash
$ curl -g 'https://www.target.com/page?name={{7*7}}'
Hello 49!
```

## 测试目标

- 检测模板注入漏洞点
- 识别模板引擎类型
- 构建漏洞利用方案

## 测试方法

服务器端模板注入（SSTI）漏洞存在于文本上下文或代码上下文中。在纯文本上下文中，允许用户使用包含直接 HTML 代码的自由格式文本；在代码上下文中，用户输入可能被放置在模板语句内（例如变量名中）。

### 识别模板注入漏洞

测试纯文本上下文中的 SSTI 时，第一步是构造各种模板引擎常用的模板表达式作为负载，并通过观察服务器响应来识别哪些表达式被服务器执行。

常用模板表达式示例：

```text
a{{bar}}b
a{{7*7}}
{var} ${var} {{var}} <%var%> [% var %]
```

此阶段建议使用详细的[模板表达式测试字符串/负载列表](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)。

代码上下文中的 SSTI 测试方法略有不同。测试人员首先构造会导致服务器返回空白或错误响应的请求。在以下示例中，HTTP GET 参数被插入到模板语句的 `personal_greeting` 变量中：

```text
personal_greeting=username
Hello user01
```

使用以下负载时，服务器返回空白的 "Hello" 响应：

```text
personal_greeting=username<tag>
Hello
```

下一步是通过以下负载跳出模板语句并在其后注入 HTML 标签：

```text
personal_greeting=username}}<tag>
Hello user01 <tag>
```

### 识别模板引擎

基于前一步获取的信息，测试人员需要通过提交不同的模板表达式来识别目标使用的模板引擎类型。通过分析服务器响应内容可推断出实际使用的模板引擎。手动识别方法的详细说明可参考PortSwigger的文章[“服务器端模板注入”](https://portswigger.net/blog/server-side-template-injection?#Identify)。为自动化检测SSTI漏洞及识别模板引擎，可使用[Tplmap](https://github.com/epinna/tplmap)或Burp Suite扩展[Backslash Powered Scanner](https://github.com/PortSwigger/backslash-powered-scanner)等工具。

### 构建远程代码执行漏洞利用

本阶段的主要目标是通过研究模板文档和技术资料，构建能实现对服务器进一步控制的远程代码执行漏洞利用方案。需要重点关注以下内容：

- **面向模板开发人员**的基础语法章节
- **安全注意事项**章节
- 内置方法、函数、过滤器和变量列表
- 扩展/插件列表

测试人员可通过聚焦`self`对象来识别其他可被调用的对象、方法及属性。若`self`对象不可用且文档未披露技术细节，建议采用变量名暴力破解方式。识别到可用对象后，需遍历该对象的所有方法、属性和特征，这些可能暴露包括权限提升、应用程序密码/API密钥泄露、配置信息及环境变量等在内的其他安全风险。

## Tools

- [Tplmap](https://github.com/epinna/tplmap)
- [Backslash Powered Scanner Burp Suite extension](https://github.com/PortSwigger/backslash-powered-scanner)
- [Template expression test strings/payloads list](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Template%20Injection)

## References

- [WSTG-INPV-18](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/18-Testing_for_Server-side_Template_Injection.md)
- [James Kettle: Server-Side Template Injection:RCE for the modern webapp (whitepaper)](https://portswigger.net/kb/papers/serversidetemplateinjection.pdf)
- [Server-Side Template Injection](https://portswigger.net/blog/server-side-template-injection)
- [Exploring SSTI in Flask/Jinja2](https://www.lanmaster53.com/2016/03/exploring-ssti-flask-jinja2/)
- [Server-Side Template Injection: from detection to Remote shell](https://www.okiok.com/server-side-template-injection-from-detection-to-remote-shell/)
- [Extreme Vulnerable Web Application](https://github.com/s4n7h0/xvwa)
- [Exploiting SSTI in Thymeleaf](https://www.acunetix.com/blog/web-security-zone/exploiting-ssti-in-thymeleaf/)