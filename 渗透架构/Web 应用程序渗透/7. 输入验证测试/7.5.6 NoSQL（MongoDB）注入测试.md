# NoSQL（MongoDB）注入测试

## 概述

NoSQL数据库相比传统SQL数据库提供更宽松的一致性约束。通过减少关系约束和一致性检查要求，NoSQL数据库通常具有性能和扩展性优势。然而即使不使用传统SQL语法，这些数据库仍可能受到注入攻击。由于NoSQL注入攻击可能在[过程式编程语言](https://en.wikipedia.org/wiki/Procedural_programming)而非[声明式SQL语言](https://en.wikipedia.org/wiki/Declarative_programming)中执行，其潜在影响比传统SQL注入更大。

NoSQL数据库调用通过应用程序编程语言、自定义API调用或遵循通用约定（如`XML`、`JSON`、`LINQ`等）进行编写。针对这些规范设计的恶意输入可能不会触发主要应用程序的净化检查。例如，过滤常见HTML特殊字符（如`< > & ;`）无法防范针对JSON API的攻击，因为其特殊字符包含`/ { } :`。

现有数百种NoSQL数据库可供应用程序使用，这些数据库提供多种语言和关系模型的API。每种数据库都具有不同的特性与限制。由于它们之间缺乏通用查询语言，示例注入代码无法适用于所有NoSQL数据库。因此，测试人员需要熟悉目标数据库的语法、数据模型及底层编程语言，才能制定针对性的测试方案。

NoSQL注入攻击与传统SQL注入的攻击执行层面存在差异。SQL注入在数据库引擎层执行，而NoSQL变体可能根据所使用的API和数据模型，在应用层或数据库层执行。通常NoSQL注入攻击发生在攻击字符串被解析、评估或拼接进NoSQL API调用的环节。

由于NoSQL数据库缺乏并发性检查，可能还存在额外的时序攻击风险（此类攻击不属于注入测试范畴）。当前MongoDB是最广泛使用的NoSQL数据库，因此所有示例将基于MongoDB API进行演示。

## 测试方法

### MongoDB的NoSQL注入漏洞检测

MongoDB API要求使用BSON（二进制JSON）调用，并提供了安全的BSON查询组装工具。但根据MongoDB文档说明，部分替代查询参数允许使用未序列化的JSON和[JavaScript表达式](https://docs.mongodb.org/manual/faq/developers/#javascript)。最常允许任意JavaScript输入的API调用是`$where`操作符。

MongoDB的`$where`操作符通常用作简单筛选或检查，类似于SQL中的用法：

`db.collection.find({ $where: "this.credits == this.debits" })`

此外，JavaScript表达式也可被评估以实现更复杂的条件：

`db.myCollection.find( { $where: function() { return obj.credits - obj.debits < 0; } } );`

### 示例1

若攻击者能够操纵传入`$where`操作符的数据，则可在MongoDB查询中注入待执行的任意JavaScript代码。当用户输入未经净化直接传入MongoDB查询时，以下代码暴露了典型漏洞：

`db.myCollection.find( { active: true, $where: function() { return obj.credits - obj.debits < $userInput; } } );;`


与其他注入测试类似，验证漏洞无需完整利用。通过注入目标API相关的特殊字符并观察响应，测试者可判断应用程序是否正确净化了输入。例如在MongoDB中，若包含以下任一特殊字符的字符串未经净化直接传入，将触发数据库错误：

`' " \ ; { }`

传统SQL注入漏洞允许攻击者执行任意SQL命令以操控数据，而JavaScript作为功能完整的编程语言，不仅允许数据操控，还能执行任意代码。例如，完整利用过程会通过特殊字符构造有效JavaScript代码，而非仅触发报错。

将输入`0;var date=new Date(); do{curDate = new Date();}while(curDate-date<10000)`代入示例代码的`$userInput`后，将执行以下JavaScript函数。此特定攻击字符串会导致MongoDB实例在10秒内持续保持100% CPU使用率：

`function() { return obj.credits - obj.debits < 0;var date=new Date(); do{curDate = new Date();}while(curDate-date<10000); }`

### 示例2

即使查询中使用的输入已被完全净化或参数化，仍存在一种替代路径可能触发NoSQL注入。许多NoSQL实例拥有自己的保留变量名，独立于应用程序编程语言。

例如在MongoDB中，`$where`语法本身是一个保留查询操作符。它需要按所示方式精确传入查询；任何改动都会导致数据库错误。然而，由于`$where`也是一个有效的PHP变量名，攻击者可能通过创建一个名为`$where`的PHP变量来向查询中注入代码。PHP MongoDB文档明确警告开发者：

请确保对所有特殊查询操作符（以`$`开头）使用单引号，以防PHP尝试用变量`$exists`的值替换`$exists`。

即使查询不依赖用户输入，如下例所示，攻击者也可能通过替换操作符为恶意数据来利用MongoDB：

`db.myCollection.find( { $where: function() { return obj.credits - obj.debits < 0; } } );`

一种可能向PHP变量赋值的方式是通过HTTP参数污染（参见：[测试HTTP参数污染/WSTG](04-Testing_for_HTTP_Parameter_Pollution.md)）。通过参数污染创建一个名为`$where`的变量，可能触发MongoDB错误，表明查询不再有效。`$where`的任何值，只要不是字符串`$where`本身，就足以证明漏洞存在。攻击者会通过插入以下内容来开发完整利用：

`$where: function() { //arbitrary JavaScript here }`

## 参考资料

- [WSTG-INPV-05-05](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.6-Testing_for_NoSQL_Injection.md)

### 注入载荷

- [NoSQL注入载荷词表（含MongoDB示例）](https://github.com/cr0hn/nosqlinjection_wordlists)

### 白皮书

- [Adobe公司Bryan Sullivan：《NoSQL，但安全性更弱》](https://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20NoSQL%20But%20Even%20Less%20Security.pdf)
- [Bekk咨询公司Erlend：NoSQL注入安全](https://erlend.oftedal.no/blog/?blogid=110)
- [Syhunt公司Felipe Aragon：《NoSQL/SSJS注入》](https://www.syhunt.com/en/?n=Articles.NoSQLInjection)
- [MongoDB官方文档：“MongoDB如何应对SQL或查询注入？”](https://docs.mongodb.org/manual/faq/developers/#how-does-mongodb-address-sql-or-query-injection)
- [PHP官方文档：“MongoDB驱动类”](https://www.php.net/manual/en/book.mongodb.php)
- [NodeJS与MongoDB渗透技术](https://blog.websecurify.com/2014/08/hacking-nodejs-and-mongodb.html)
- [NodeJS与MongoDB攻击实践](https://blog.websecurify.com/2014/08/attacks-nodejs-and-mongodb-part-to.html)
