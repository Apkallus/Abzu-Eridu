# HTTP拆分与走私测试

## 概述

本节通过利用 Web 应用程序的弱点或不同代理解析 HTTP 消息方式的特殊性，举例说明针对 HTTP 协议特定功能发起的攻击。

本节将分析两种针对特定 HTTP 头部的不同攻击：

-   HTTP 拆分
-   HTTP 走私

第一种攻击利用了输入净化机制的缺陷，使得攻击者能够在应用程序响应的头部中插入回车（CR）和换行（LF）字符，从而将该响应“拆分”成两个不同的 HTTP 消息。此类攻击的目标可能从缓存投毒到跨站脚本攻击（XSS）不等。

在第二种攻击中，攻击者利用了一些特殊构造的 HTTP 消息可能因接收代理的不同而被以不同方式解析和解释的特性。HTTP 走私攻击需要对处理 HTTP 消息的不同代理（如 Web 服务器、代理服务器、防火墙）有一定程度的了解，因此这类测试通常仅包含在灰盒测试部分。

## 测试目标

-   评估应用程序是否容易受到拆分攻击，并识别可能实现的攻击类型。
-   评估通信链路是否容易受到走私攻击，并识别可能实现的攻击类型。

## 测试方法

### 黑盒测试

#### HTTP 拆分

某些 Web 应用程序会使用部分用户输入来生成其响应中某些头部的值。最直接的例子是重定向操作，其目标 URL 依赖于某些用户提交的值。例如，假设要求用户选择他们偏好标准版还是高级版 Web 界面。该选择将作为一个参数传递，并将在响应头中用于触发向相应页面的重定向。

更具体地说，如果参数 'interface' 的值为 'advanced'，应用程序将返回如下响应：

```http
HTTP/1.1 302 Moved Temporarily
Date: Sun, 03 Dec 2005 16:22:19 GMT
Location: https://victim.com/main.jsp?interface=advanced
<snip>
```

当浏览器接收到此消息时，将把用户带到 Location 头部指示的页面。然而，如果应用程序不过滤用户输入，则测试者将有可能在 'interface' 参数中插入序列 %0d%0a（代表用于分隔不同行的 CRLF 序列）。此时，测试者能够触发一个会被任何解析它的人（例如，位于我们和应用程序之间的 Web 缓存）解释为两个不同响应的响应。攻击者可以利用这一点来毒化该 Web 缓存，从而在所有后续请求中提供虚假内容。

假设在前面的例子中，测试者将以下数据作为 interface 参数传递：

`advanced%0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20200%20OK%0d%0aContent-Type:%20text/html%0d%0aContent-Length:%2035%0d%0a%0d%0a<html>Sorry,%20System%20Down</html>`

存在漏洞的应用程序因此将返回如下响应：

```http
HTTP/1.1 302 Moved Temporarily
Date: Sun, 03 Dec 2005 16:22:19 GMT
Location: https://victim.com/main.jsp?interface=advanced
Content-Length: 0

HTTP/1.1 200 OK
Content-Type: text/html
Content-Length: 35

<html>Sorry,%20System%20Down</html>
<other data>
```

Web 缓存将会看到两个不同的响应。因此，如果攻击者在第一个请求之后立即发送第二个请求来获取 `/index.html`，该 Web 缓存将把此请求与第二个响应匹配并缓存其内容。这样一来，所有后续经由该 Web 缓存发往 `victim.com/index.html` 的请求都将收到“system down”的消息。通过这种方式，攻击者能够有效地对所有使用该 Web 缓存（如果该 Web 缓存是 Web 应用程序的反向代理，则意味着整个互联网的用户）的用户进行网站篡改（deface）。

或者，攻击者可以向这些用户传递一个能够发起跨站脚本攻击（例如窃取 Cookie）的 JavaScript 代码片段。需要注意的是，虽然漏洞存在于应用程序中，但此处的攻击目标是其用户。因此，为了寻找此漏洞，测试人员需要识别所有影响响应中一个或多个头部的用户可控输入，并检查是否能够成功地向其中注入 CR+LF 序列。

最有可能成为此攻击目标的头部包括：

-   `Location` 
-   `Set-Cookie` 

需要特别注意的是，在真实场景中成功利用此漏洞可能相当复杂，因为必须考虑以下几个因素：

1.  测试人员必须正确设置伪造响应中的头部，以确保其能被成功缓存（例如，设置一个未来日期的 `Last-Modified` 头部）。此外，他们可能还需要通过在其请求头中包含 `Pragma: no-cache` 来发起一个初步请求，以清除目标页面先前缓存的版本。
2.  应用程序虽然可能不过滤 CR+LF 序列，但可能会过滤掉成功攻击所需的其他字符（例如 `<` 和 `>`）。在这种情况下，测试人员可以尝试使用其他编码方式（例如 UTF-7）。
3.  某些目标（例如 ASP）会对 Location 头部的路径部分（例如 `www.victim.com/redirect.asp`）进行 URL 编码，这使得 CRLF 序列失效。然而，它们可能未能对查询部分（例如 `?interface=advanced`）进行编码，这意味着仅需一个前导问号就足以绕过此过滤机制。

关于此攻击的更详细讨论以及其他可能场景和应用的信息，请查阅本节末尾引用的论文。

### 灰盒测试

#### HTTP 拆分

成功利用 HTTP 拆分在很大程度上得益于了解 Web 应用程序和攻击目标的一些详细信息。例如，不同的目标可能使用不同的方法来判断第一个 HTTP 消息的结束和第二个消息的开始。有些目标会像前面的例子那样使用消息边界。其他目标可能会假定不同的消息将由不同的数据包承载。还有一些目标会为每个消息分配预定长度的多个数据块（chunk）：在这种情况下，第二个消息必须恰好在一个数据块的开始处，这将要求测试者在两个消息之间使用填充数据（padding）。当需要在 URL 中发送存在漏洞的参数时，这可能会带来一些麻烦，因为很长的 URL 很可能被截断或过滤。灰盒测试场景可以帮助攻击者找到变通方法：例如，某些应用服务器允许使用 POST 方法而非 GET 方法来发送请求。

#### HTTP 走私

如概述中所述，HTTP 走私利用了精心构造的 HTTP 消息可能被不同代理（浏览器、Web 缓存、应用防火墙）以不同方式解析和解释的特性。这种相对较新的攻击类型在 2005 年由 Chaim Linhart, Amit Klein, Ronen Heled 和 Steve Orrin 首次发现。它存在多种可能的用途，我们将分析其中最引人注目的一种：绕过应用防火墙。更详细的信息和其他场景请参阅原始白皮书（链接在本页底部）。

##### 应用防火墙绕过

有多种产品允许系统管理员根据请求中包含的某些已知恶意模式来检测并阻断恶意的 Web 请求。例如，考虑那个臭名昭著的、古老的[针对 IIS 服务器的 Unicode 目录遍历攻击](https://www.securityfocus.com/bid/1806)，攻击者可以通过发出如下请求来突破网站根目录（www root）：

`https://target/scripts/..%c1%1c../winnt/system32/cmd.exe?/c+<command_to_execute>`

当然，通过检测 URL 中是否存在 ".." 和 "cmd.exe" 等字符串来发现并过滤此攻击是相当容易的。然而，IIS 5.0 对于请求体大小在 48K 字节以内的 POST 请求处理相当严格，并且当 Content-Type 头部不是 application/x-www-form-urlencoded 时，它会截断超出此限制的所有内容。测试者可以利用这一点，创建一个结构如下的、非常大的请求：


```html
POST /target.asp HTTP/1.1        <-- Request #1
Host: target
Connection: Keep-Alive
Content-Length: 49225
<CRLF>
<49152 bytes of garbage>
```

```html
POST /target.asp HTTP/1.0        <-- Request #2
Connection: Keep-Alive
Content-Length: 33
<CRLF>
```

```html
POST /target.asp HTTP/1.0        <-- Request #3
xxxx: POST /scripts/..%c1%1c../winnt/system32/cmd.exe?/c+dir HTTP/1.0   <-- Request #4
Connection: Keep-Alive
<CRLF>
```

此处的情况是，`Request #1` 由 49223 字节组成，这其中也包含了 `Request #2` 的数据行。因此，防火墙（或除 IIS 5.0 之外的任何其他代理）将看到 Request #1，会无法识别 `Request #2`（其数据将被视为 #1 的一部分），会看到 `Request #3` 但会漏掉 `Request #4`（因为其 POST 数据将被视为虚假头部 xxxx 的一部分）。

那么 IIS 5.0 会如何处理呢？它会在处理完 49152 字节的垃圾数据后立即停止解析 `Request #1`（因为它达到了 48K=49152 字节的限制），从而将 `Request #2` 解析为一个新的、独立的请求。`Request #2` 声明其内容长度为 33 字节，该长度包含了直到 "xxxx: " 之前的所有内容，这使得 IIS 漏掉 `Request #3`（其被解释为 `Request #2` 的一部分），但能识别 `Request #4`，因为其 POST 数据紧接在 `Request #2` 的第 33 个字节之后开始。这有点复杂，但关键在于，攻击 URL 将不会被防火墙检测到（它会被解释为前一个请求的正文），但会被 IIS 正确解析（并执行）。

虽然上述情况利用了 Web 服务器的一个漏洞，但在其他场景中，我们可以利用不同支持 HTTP 的设备对不完全符合 RFC 规范的消息的解析差异。例如，HTTP 协议只允许一个 Content-Length 头部，但并未规定如何处理包含两个此头部实例的消息。某些实现会使用第一个实例，而其他实现则会采用第二个实例，这就为 HTTP 走私攻击打开了方便之门。另一个例子是在 GET 消息中使用 Content-Length 头部。

需要注意的是，HTTP 走私*并不*利用目标 Web 应用程序中的任何漏洞。因此，在渗透测试项目中，要说服客户无论如何都应寻求应对措施可能有些棘手。

## 参考资料

- [WSTG-INPV-15](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/15-Testing_for_HTTP_Splitting_Smuggling.md)

### 白皮书

-   [Amit Klein, "Divide and Conquer: HTTP Response Splitting, Web Cache Poisoning Attacks, and Related Topics"](https://packetstormsecurity.com/files/32815/Divide-and-Conquer-HTTP-Response-Splitting-Whitepaper.html)
-   [Amit Klein: "HTTP Message Splitting, Smuggling and Other Animals"](https://www.slideserve.com/alicia/http-message-splitting-smuggling-and-other-animals-powerpoint-ppt-presentation)
-   [Amit Klein: "HTTP Request Smuggling - ERRATA (the IIS 48K buffer phenomenon)"](https://www.securityfocus.com/archive/1/411418)
-   [Amit Klein: "HTTP Response Smuggling"](https://www.securityfocus.com/archive/1/425593)
-   [Chaim Linhart, Amit Klein, Ronen Heled, Steve Orrin: "HTTP Request Smuggling"](https://www.cgisecurity.com/lib/http-request-smuggling.pdf)
