# 客户端注入测试

## 概述

当应用程序采用 [Web SQL 数据库](https://www.w3.org/TR/webdatabase/)技术且未正确验证输入或未对查询变量进行参数化时，会发生客户端 SQL 注入。该数据库通过 JavaScript（JS）API 调用进行操作，例如创建或打开现有数据库的 `openDatabase()`。

## 测试目标

以下测试场景将验证是否执行了正确的输入验证。若实现存在漏洞，攻击者可读取、修改或删除数据库内存储的信息。

## 测试方法

### 识别 Web SQL 数据库的使用

若被测应用程序实现了 Web SQL 数据库，以下三个调用将出现在客户端核心代码中：

- `openDatabase()`
- `transaction()`
- `executeSQL()`

以下代码展示了 API 实现的示例：

```javascript
var db = openDatabase(shortName, version, displayName, maxSize);

db.transaction(function(transaction) {
    transaction.executeSql('INSERT INTO LOGS (time, id, log) VALUES (?, ?, ?)', [dateTime, id, log]);
});
```

### Web SQL 数据库注入

在确认使用 `executeSQL()` 后，攻击者即可测试并验证其实现的安全性。

Web SQL 数据库的实现基于 [SQLite 语法](https://www.sqlite.org/lang.html)。

#### 条件绕过

以下示例展示了如何在客户端利用此漏洞：

```javascript
// URL example: https://example.com/user#15
var userId = document.location.hash.substring(1,); 
// Grabs the ID without the hash -> 15

db.transaction(function(transaction){
    transaction.executeSQL('SELECT * FROM users WHERE user = ' + userId);
});
```

要返回所有用户的信息（而非仅返回与攻击者对应的用户），可在 URL 片段中使用：`15 OR 1=1`。

> **注意：** 将条件 `OR 1=1` 注入 SQL 查询时需谨慎。虽然在该注入初始上下文中可能无害，但应用程序通常会在多个不同查询中复用同一请求的数据。例如，若该条件触及 UPDATE 或 DELETE 语句，可能导致意外数据丢失。

更多 SQL 注入负载请参阅 [SQL 注入测试/WSTG](05-Testing_for_SQL_Injection.md) 场景。

## 修复措施

请遵循 [SQL注入测试的修复措施章节/WSTG](05-Testing_for_SQL_Injection.md#remediation) 中的相同修复方案。

## 参考资料

- [WSTG-INPV-05-05](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.8-Testing_for_Client-side.md)
- [W3C Web SQL 数据库规范](https://www.w3.org/TR/webdatabase/)
- [Apple JavaScript 数据库教程](https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/SafariJSDatabaseGuide/UsingtheJavascriptDatabase/UsingtheJavascriptDatabase.html)
- [Tutorialspoint HTML5 Web SQL 数据库教程](https://www.tutorialspoint.com/html5/html5_web_sql.htm)
- [Portswigger 客户端SQL注入详解](https://portswigger.net/web-security/dom-based/client-side-sql-injection)
