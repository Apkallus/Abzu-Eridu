# OAuth授权服务器漏洞测试

## 概述

OAuth 将用户身份及其对应的访问权限存储在授权服务器（AS）中。授权服务器在 OAuth 流程中扮演关键角色，因为它负责向客户端授予资源访问权限。为确保安全实现此功能，授权服务器必须正确验证 OAuth 流程中的各项参数。

若未能有效验证参数，可能导致账户接管、未授权资源访问及权限提升等安全风险。

## 测试目标

- 识别授权服务器中存在的安全弱点。

## 测试方法

为检测授权服务器（AS）的安全弱点，测试目标包括：

1.  获取用于授权的凭证。
2.  通过强制浏览为自己授予对任意资源的访问权限。
3.  绕过授权机制。

### 测试重定向 URI 验证不足

如果 `redirect_uri` 未得到正确验证，攻击者可以构造一个指向其控制服务器的链接。这可用于诱骗授权服务器将授权代码发送给攻击者。以下示例中，`client.evil.com` 被用作伪造的 `redirect_uri`。

```text
https://as.example.com/authorize?client_id=example-client&redirect_uri=http%3A%2F%client.evil.com%2F&state=example&response_mode=fragment&response_type=code&scope=openid&nonce=example
```

如果用户在用户代理（如浏览器）中打开此链接，授权服务器会将用户代理重定向至恶意 URL。

攻击者可截获伪造 URL 中传递的 `code` 值，然后将其提交至授权服务器的令牌端点。

以下请求示例展示了一个向授权服务器发送 `redirect_uri` 的授权请求。客户端 `client.example.com` 向授权服务器 `as.example.com` 发送授权请求，其中包含经过 URL 编码的重定向 URI `http%3A%2F%2Fclient.example.com%2F`。

```http
GET /authorize
    ?redirect_uri=http%3A%2F%2Fclient.example.com%2F
    &client_id=example-client
    &errorPath=%2Ferror
    &scope=openid%20profile%20email
    &response_type=code
    &response_mode=query
    &state=example
    &nonce=example
    &code_challenge=example
    &code_challenge_method=S256 HTTP/1.1
Host: as.example.com
```

授权服务器（AS）通过包含授权代码的重定向进行响应。该代码可在令牌请求中兑换为访问令牌。如下所示，`Location` 头部中的 URL 即为前一步 `redirect_uri` 参数所指定的 URI。

```http
HTTP/1.1 302 Found
Date: Mon, 18 Oct 2021 20:46:44 GMT
Content-Type: text/html; charset=utf-8
Content-Length: 340
Location: https://client.example.com/?code=example&state=example
```

要测试授权服务器是否存在重定向 URI 验证不足的漏洞，可使用 ZAP 等 HTTP 拦截代理捕获流量：

1.  启动 OAuth 流程，并在授权请求阶段暂停。
2.  修改 `redirect_uri` 的值，并观察服务器的响应。
3.  分析响应内容，确认授权服务器是否接受了任意构造的 `redirect_uri` 参数。

如果授权服务器将用户代理重定向至您指定的 `redirect_uri`，则表明其未对 `redirect_uri` 进行正确验证。

此外，可参考 [服务器端请求伪造测试（WSTG）](../07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery.md) 中的“常见过滤绕过”章节，以识别重定向 URI 验证的常见绕过方法。

### 测试授权码注入

在授权码流程的代码交换过程中，授权服务器（AS）会向客户端颁发一个授权码，随后该代码将在令牌端点处被交换以获取访问令牌和刷新令牌。

对授权服务器执行以下测试：

1.  尝试使用属于另一个 `client_id` 的有效授权码。
2.  尝试使用属于另一个资源所有者（用户）的有效授权码。
3.  尝试使用为另一个 `redirect_uri` 颁发的有效授权码。
4.  多次重复发送同一个授权码（代码重放攻击）。

#### 测试公共客户端

发送到令牌端点的请求包含授权码，该代码将被交换为令牌。使用 ZAP 等 HTTP 拦截代理捕获此请求，并修改其中的参数值后重新发送请求。

```http
POST /oauth/token HTTP/1.1
Host: as.example.com
[...]

{
    "errorPath":"/error",
    "client_id":"example-client",
    "code":"INJECT_CODE_HERE",
    "grant_type":"authorization_code",
    "redirect_uri":"https://client.example.com"
}
```

如果授权服务器响应并返回了 `access_token`，则表明授权码注入成功。

#### 测试机密客户端

由于机密客户端的 OAuth 流程额外受到客户端密钥的保护，无法直接向令牌端点提交授权码。替代方法是，将授权码注入到客户端中。随后，被注入的代码将由机密客户端连同客户端密钥一起，在令牌请求中发送。

首先，从授权服务器捕获一个授权码：
1.  以用户 Alice 的身份启动授权码流程。在从授权服务器收到代码时暂停流程。
2.  不要将该代码提交给客户端，并记下该代码及对应的 state 参数值。

然后，注入该授权码：
1.  以用户 Mallory 的身份启动授权码流程，并将先前为用户 Alice 获取的代码和 state 值注入到此流程中。
2.  当攻击成功时，客户端此时应获得一个授权令牌，该令牌授予了对用户 Alice 所拥有资源的访问权限。

```http
GET /callback?code=INJECT_CODE_HERE&state=example HTTP/1.1
Host: client.example.com
[...]

```

### 测试 PKCE 降级攻击

在某些情况下，PKCE 扩展可能会从授权码流程中被移除。这可能导致原本受 PKCE 扩展保护的公钥客户端面临该扩展所防御的攻击风险。

这种情况可能发生在以下场景：

-   授权服务器不支持 PKCE。
-   授权服务器未能正确验证 PKCE。

两者均可使用 ZAP 等 HTTP 拦截代理进行测试。请执行以下测试：

1.  发送不包含 `code_challenge=sha256(xyz)` 和 `code_challenge_method` 参数的授权请求。
2.  发送 `code_challenge=sha256(xyz)` 参数值为空的授权请求。
3.  发送 `code_challenge=sha256(xyz)` 参数值为伪造值的授权请求。

以下示例标明了需要修改的值：

```http
GET /authorize
    ?redirect_uri=http%3A%2F%client.example.com
    &client_id=example-client
    &errorPath=%2Ferror
    &scope=openid%20profile%20email
    &response_type=code
    &response_mode=web_message
    &state=example-state
    &nonce=example-nonce
    &code_challenge=MODIFY_OR_OMIT_THIS
    &code_challenge_method=MODIFY_OR_OMIT_THIS
    &prompt=none HTTP/1.1
Host: as.example.com
[...]

```

授权服务器应在令牌交换时验证 `code_verifier` 的值。测试方法如下：

1.  发送不包含 `code_verifier` 的令牌请求。
2.  发送 `code_verifier` 为空的令牌请求。
3.  发送包含针对另一个授权码的有效 `code_verifier` 的令牌请求。

```http
POST /oauth/token HTTP/1.1
Host: as.example.com
[...]

{
"client_id":"example-client",
"code_verifier":"MODIFY_OR_OMIT_THIS",
"code":"example",
"grant_type":"authorization_code",
"redirect_uri":"https://client.example.com"
}
```

### 测试同意页面跨站请求伪造（CSRF）

CSRF 攻击在 [CSRF（WSTG）](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md) 章节中有详细描述。OAuth 也可能受到 CSRF 攻击。

为防范 CSRF 攻击，OAuth 利用 `state` 参数作为反 CSRF 令牌。

其他措施同样可以预防 CSRF 攻击。PKCE 流程能够缓解 CSRF。`nonce` 值也可用作反 CSRF 令牌。

请根据 [CSRF（WSTG）](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md) 测试用例中描述的测试方法，对包含 OAuth 所使用的任一反 CSRF 参数的每个请求进行测试。

同意页面会向用户显示，以确认该用户是否同意客户端代表其访问资源。利用CSRF攻击同意页面可能导致任意客户端在用户不知情的情况下获得资源访问权限。该流程的步骤如下：

1.  客户端生成一个 state 参数，并将其随同意请求一同发送。
2.  用户代理显示同意页面。
3.  资源所有者向客户端授予访问权限。
4.  同意信息连同已确认的权限范围一起发送给授权服务器。

使用 ZAP 等 HTTP 拦截代理来测试 state 参数是否得到正确验证。

```http
POST /u/consent?state=Tampered_State HTTP/1.1
Host: as.example.com
[...]

state=MODIFY_OR_OMIT_THIS
&audience=https%3A%2F%2Fas.example.com%2Fuserinfo
&scope%5B%5D=profile
&scope%5B%5D=email
&action=accept
```

### 测试点击劫持（Clickjacking）

点击劫持攻击在[点击劫持测试（WSTG）](../11-Client-side_Testing/09-Testing_for_Clickjacking.md)中有详细说明。当授权同意页面存在点击劫持漏洞，且攻击者掌握`client_id`（公开客户端）或客户端密钥（机密客户端）时，攻击者可伪造用户同意操作，通过恶意客户端获取目标资源的访问权限。

#### 测试方法

要实现此攻击，攻击者需将授权页面加载到 iframe 中。  
以下 HTML 页面可用于在 iframe 中加载授权页面：  

```html
<html>
    <head>
        <title>Clickjack test page</title>
    </head>
    <body>
        <iframe src="https://as.example.com/auth/realms/example/login-actions/required-action?execution=OAUTH_GRANT&client_id=example-client" width="500" height="500"></iframe>
    </body>
</html>
```

若页面成功加载，则表明该站点存在点击劫持漏洞。  
关于如何实施此类攻击的详细说明，请参阅[点击劫持测试（WSTG）](../11-Client-side_Testing/09-Testing_for_Clickjacking.md)。

### 测试令牌生命周期

OAuth 包含两种类型的令牌：访问令牌和刷新令牌。访问令牌的有效期应当受到限制，即应为短期有效：合理的有效期取决于具体应用场景，通常为 5 到 15 分钟。

刷新令牌的有效期则应更长，且应为一次性令牌，每次使用后即被替换。

#### 测试访问令牌生命周期验证

当使用 JSON Web Token（JWT）作为访问令牌时，可通过解码 JWT 获取其有效期信息（详见 [JSON Web Tokens 测试（WSTG）](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md)）。授权服务器可能存在未正确验证 JWT 生命周期的情况。

测试访问令牌生命周期时，可使用 ZAP 等 HTTP 拦截代理。截获包含访问令牌的端点请求后，在重放工具中暂存该请求并等待目标时间流逝。访问令牌的有效期应根据资源敏感度设定在 5 至 15 分钟之间。

此类请求示例如下（令牌也可能通过 Cookie 等其他方式传输）：

```http
GET /userinfo HTTP/1.1
Host: as.example.com
[...]
Authorization: Bearer eyJhbGciOiJkaXIiL[...]

```

通过在不同时间间隔（如 5 分钟、10 分钟、30 分钟后）重复发送请求来测试生命周期验证。

可通过自动化步骤和记录服务器响应来优化此过程。当收到 HTTP 状态码 403（而非 200）时，表明访问令牌可能已失效。

#### 测试刷新令牌生命周期验证

刷新令牌的有效期比访问令牌更长。因其有效期较长，当被用于兑换访问令牌后，应立即失效。

刷新令牌与访问令牌在同一令牌请求中签发给客户端。

使用 ZAP 等 HTTP 拦截代理进行测试，步骤如下：
1. 获取有效的刷新令牌
2. 截获用于兑换新访问令牌的刷新令牌请求
3. 将捕获的请求发送至重放工具

以下示例中，刷新令牌通过 POST 请求体传输：

```http
POST /token HTTP/1.1
Host: as.example.com
Cookie: [...]
[...]

grant_type=refresh_token
&refresh_token=eyJhbGciOiJIUz[...]
&client_id=example-client

```

执行以下测试：

1.  发送刷新令牌，确认授权服务器是否会颁发访问令牌。
2.  使用同一个刷新令牌重复上述步骤，以评估单个刷新令牌可被接受的次数。

当使用 JSON Web Token (JWT) 作为刷新令牌时，可通过解码 JWT 获取其有效期信息（详见 [JSON Web Tokens 测试（WSTG）](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md)）。刷新令牌的有效期可能较长，但应设有明确的过期时间。

通过引入盗用检测机制可以增强安全性。如果在令牌交换中使用的刷新令牌超出了其有效期（或生命周期），授权服务器应立即使该用户（资源所有者）对应的此客户端的所有刷新令牌失效。测试此机制的方法如下：

1.  发送刷新令牌，确认授权服务器是否会颁发访问令牌。
2.  使用同一个刷新令牌重复上述步骤，直到该令牌失效为止。
3.  尝试使用上一次令牌响应中获得的新刷新令牌。

如果授权服务器使颁发给该客户端（针对此资源所有者）的所有刷新令牌全部失效，则说明其具备令牌盗用检测能力。

## Related Test Cases

- [Testing for Cross Site Request Forgery（WSTG）](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md)
- [Testing for Client-side URL Redirect（WSTG）](../11-Client-side_Testing/04-Testing_for_Client-side_URL_Redirect.md)
- [Testing for Server-Side Request Forgery（WSTG）](../07-Input_Validation_Testing/19-Testing_for_Server-Side_Request_Forgery.md)
- [Testing JSON Web Tokens（WSTG）](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md)
- [Testing for Clickjacking（WSTG）](../11-Client-side_Testing/09-Testing_for_Clickjacking.md)
- [Testing Cross Origin Resource Sharing（WSTG）](../11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing.md)

## 修复措施

大多数针对 OAuth 授权服务器的攻击，可通过在授权码和令牌交换阶段验证参数的存在性及内容来缓解。

限制授权码和刷新令牌等凭证的有效时间及使用次数。这不仅能缓解特定类型的攻击，还能在凭证泄露时限制攻击者的利用空间。

正确配置安全防护措施（如 CORS、反 CSRF 令牌和防点击劫持头部）可减轻或限制攻击影响：

- 始终验证所有参数是否存在，并校验其取值有效性
- 使用 PKCE 扩展机制确保授权码和令牌交换的安全性
- 禁止安全功能（如 PKCE 扩展）的回退机制
- 严格限制凭证的生命周期
- 在可能的情况下确保凭证仅使用一次（如授权码）
- 配置可用的安全防护措施（包括 CORS、反 CSRF 令牌和防点击劫持头部）

## Tools

- [BurpSuite](https://portswigger.net/burp/releases)
- [EsPReSSO](https://github.com/portswigger/espresso)
- [ZAP](https://www.zaproxy.org/)

## References

- [WSTG-ATHZ-05-01](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/05-Authorization_Testing/05.1-Testing_for_OAuth_Authorization_Server_Weaknesses.md)
- [User Authentication with OAuth 2.0](https://oauth.net/articles/authentication/)
- [The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)
- [The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)
- [OAuth 2.0 Threat Model and Security Considerations](https://datatracker.ietf.org/doc/html/rfc6819)
- [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-16)
- [Authorization Code Flow with Proof Key for Code Exchange](https://auth0.com/docs/authorization/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)