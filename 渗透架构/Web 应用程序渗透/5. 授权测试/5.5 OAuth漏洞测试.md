# OAuth漏洞测试

## 概述

[OAuth 2.0](https://oauth.net/2/)（以下简称 OAuth）是一个授权框架，允许客户端代表其用户访问资源。

为实现这一机制，OAuth 重度依赖令牌在不同实体间进行通信，每个实体承担不同的[角色](https://datatracker.ietf.org/doc/html/rfc6749#section-1.1)：

- **资源所有者（Resource Owner）：** 授权访问资源的实体，通常是用户本人
- **客户端（Client）：** 代表资源所有者请求访问资源的应用程序。客户端分为两种[类型](https://oauth.net/2/client-types/)：
    - **公开客户端（Public）：** 无法保护密钥的客户端（例如前端应用，如单页应用、移动应用等）
    - **机密客户端（Confidential）：** 能够通过安全保存注册密钥与授权服务器进行安全认证的客户端（例如后端服务）
- **授权服务器（Authorization Server）：** 存储授权信息并授予访问权限的服务器
- **资源服务器（Resource Server）：** 向客户端提供所访问内容的应用程序

由于 OAuth 的职责是将所有者的访问权限委托给客户端，这使其成为攻击者非常有吸引力的目标。不当的实现会导致对用户资源和信息的未授权访问。

为了向客户端应用程序提供访问权限，OAuth 依赖几种[授权许可类型](https://oauth.net/2/grant-types/)来生成访问令牌：

- [授权码模式（Authorization Code）](https://oauth.net/2/grant-types/authorization-code/)： 供机密客户端和公开客户端使用，用于将授权码交换为访问令牌，但建议仅由机密客户端使用
- [代码交换证明密钥（PKCE）](https://oauth.net/2/pkce/)： PKCE 建立在授权码模式之上，为公开客户端使用该模式提供了更强的安全性，并提升了机密客户端的安全态势
- [客户端凭证模式（Client Credentials）](https://oauth.net/2/grant-types/client-credentials/)： 用于机器对机器的通信，此处的"用户"是向资源服务器请求访问其资源的机器
- [设备码模式（Device Code）](https://oauth.net/2/grant-types/device-code/)： 用于输入能力有限的设备
- [刷新令牌模式（Refresh Token）](https://oauth.net/2/grant-types/refresh-token/)： 授权服务器提供的令牌，允许客户端在用户的访问令牌失效或过期后对其进行刷新。此许可类型需与其他一种许可类型结合使用。

在 [OAuth 2.1](https://oauth.net/2.1/) 版本中，有两种流程将被弃用，不建议继续使用：

- **[隐式流程\*（Implicit Flow）](https://oauth.net/2/grant-types/implicit/)**：PKCE 的安全实现使该流程过时。在 PKCE 出现之前，客户端应用（如[单页应用](https://en.wikipedia.org/wiki/Single-page_application)）使用隐式流程，因为 [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) 放宽了站点间相互通信的[同源策略](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)。有关为何不推荐使用隐式授权的更多信息，请参阅此[章节](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#section-2.1.2)。
- **[资源所有者密码凭证（Resource Owner Password Credentials）](https://oauth.net/2/grant-types/password/)**：此流程用于直接通过客户端交换用户凭证，然后客户端将这些凭证发送给授权服务器以换取访问令牌。有关为何不推荐使用此流程的信息，请参阅此[章节](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics#section-2.4)。

*：仅在 OAuth 中的隐式流程已被弃用，但在 Open ID Connect (OIDC) 中，它仍然是获取 `id_tokens` 的可行解决方案。请务必理解隐式流程的使用方式，如果仅使用 `/authorization` 端点来获取访问令牌，而完全不依赖 `/token` 端点，则可以识别出这种用法。示例可参见[此处](https://auth0.com/docs/get-started/authentication-and-authorization-flow/implicit-flow-with-form-post)。

*请注意，OAuth 流程是一个复杂的话题，以上仅包含关键领域的摘要。内联参考文献包含有关特定流程的更多信息。*

## 测试目标

- 确定 OAuth2 实现是否存在漏洞，或是否使用了已弃用或自定义的实现。

## 测试方法

### 测试已弃用的授权类型

已弃用的授权类型因安全和功能原因被淘汰。识别是否正在使用这些类型可以帮助我们快速审查其是否存在相关使用威胁。某些威胁可能超出攻击者的范围（例如客户端使用用户凭证的方式），这种情况应记录并提交给内部工程团队。

对于公开客户端，通常可以通过向 `/token` 端点发送的请求中的 `grant_type` 参数来识别授权类型。

以下示例展示了带 PKCE 的授权码授权流程：

```json
POST /oauth/token HTTP/1.1
Host: as.example.com
[...]

{
  "client_id":"example-client",
  "code_verifier":"example",
  "grant_type":"authorization_code",
  "code":"example",
  "redirect_uri":"https://client.example.com"
}
```

`grant_type` 参数的取值及其对应的授权类型如下：

- `password`：表示资源所有者密码凭证（ROPC）授权
- `client_credentials`：表示客户端凭证授权
- `authorization_code`：表示授权码授权

隐式流程（Implicit Flow）类型不会通过 `grant_type` 参数表示，因为令牌是在对 `/authorization` 端点请求的响应中直接返回的，而是可以通过 `response_type` 参数来识别。示例如下：

```http
GET /authorize
  ?client_id=<some_client_id>
  &response_type=token 
  &redirect_uri=https%3A%2F%2Fclient.example.com%2F
  &scope=openid%20profile%20email
  &state=<random_state>
```

以下URL参数指示正在使用的OAuth流程：

- `response_type=token`：表示隐式流程，因为客户端直接向授权服务器请求返回令牌
- `response_type=code`：表示授权码流程，因为客户端请求授权服务器返回代码，该代码随后将用于交换令牌
- `code_challenge=sha256(xyz)`：表示PKCE扩展，因为没有其他流程使用此参数

以下是一个带有PKCE的授权码流程的授权请求示例：

```http
GET /authorize
    ?redirect_uri=https%3A%2F%2Fclient.example.com%2F
    &client_id=<some_client_id>
    &scope=openid%20profile%20email
    &response_type=code
    &response_mode=query
    &state=<random_state>
    &nonce=<random_nonce>
    &code_challenge=<random_code_challenge>
    &code_challenge_method=S256 HTTP/1.1
Host: as.example.com
[...]
```

#### 公共客户端

推荐公共客户端使用带有PKCE扩展的授权码授权。带有PKCE的授权码流程授权请求应包含 `response_type=code` 和 `code_challenge=sha256(xyz)` 参数。

令牌交换请求应包含授权类型 `authorization_code` 和 `code_verifier` 参数。

公共客户端的不当授权类型包括：
- 未使用PKCE扩展的授权码授权
- 客户端凭证授权
- 隐式流程
- 资源所有者密码凭证（ROPC）

#### 机密客户端

推荐机密客户端使用授权码授权（Authorization Code grant），也可同时使用PKCE扩展。

机密客户端的不当授权类型包括：
- 客户端凭证授权（机器对机器场景除外——详见下文）
- 隐式流程
- 资源所有者密码凭证（ROPC）

##### 机器对机器场景

在没有用户交互且客户端均为机密客户端的情况下，可以使用客户端凭证授权。
如果已知 `client_id` 和 `client_secret`，可通过传递 `client_credentials` 授权类型来获取令牌。

```bash
$ curl --request POST \
  --url https://as.example.com/oauth/token \
  --header 'content-type: application/json' \
  --data '{"client_id":"<some_client_id>","client_secret":"<some_client_secret>","grant_type":"client_credentials"}' --proxy https://localhost:8080/ -k
```

### 凭据泄露

根据OAuth流程的不同，OAuth会在URL参数中传输多种类型的凭据。以下令牌可被视为泄露的凭据：
- 访问令牌（access token）
- 刷新令牌（refresh token）
- 授权码（authorization code）
- PKCE代码挑战/验证器（code challenge / code verifier）

由于OAuth的工作机制，授权`code`以及`code_challenge`、`code_verifier`可能作为URL的一部分存在。如果`response_mode`未设置为[`form_post`](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html)，隐式流程（implicit flow）会将授权令牌作为URL片段传输。这可能导致请求的令牌或代码通过Referrer标头、日志文件和代理服务器泄露，因为这些参数会通过查询字符串或片段传递。

隐式流程泄露令牌的风险远高于泄露`code`或其他`code_*`参数的风险，因为后者与特定客户端绑定，泄露后更难被滥用。

测试此场景时，请使用ZAP等HTTP拦截代理工具拦截OAuth流量：
- 逐步执行授权流程，识别URL中存在的任何凭据
- 如果OAuth流程涉及的外部资源被加载，分析其请求头。凭据可能通过Referrer标头泄露

完成OAuth流程并使用应用程序后，HTTP拦截代理的请求历史中会捕获若干请求。在请求历史中搜索包含授权服务器和客户端URL的HTTP Referrer标头（例如`Referer: https://idp.example.com/`）。

检查HTML元标签（尽管该标签[并非所有浏览器都支持](https://caniuse.com/mdn-html_elements_meta_name_referrer)）或[Referrer-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Referrer-Policy)有助于评估是否通过Referrer标头发生凭据泄露。

## 相关测试案例

- [测试JSON Web令牌](../06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md)

## 修复措施

- 实施OAuth时，始终考虑所使用的技术，以及应用程序是能够避免泄露密钥的服务端应用，还是无法避免的客户端应用
- 在几乎所有情况下，都应使用带PKCE的授权码流程（Authorization Code flow with PKCE）。机器对机器流程（machine-to-machine flows）可能是个例外
- 使用POST参数或标头值来传输密钥
- 当不存在其他可能性时（例如无法迁移的遗留应用程序），实施额外的安全标头，如`Referrer-Policy`

## Tools

- [BurpSuite](https://portswigger.net/burp/releases)
- [EsPReSSO](https://github.com/portswigger/espresso)
- [ZAP](https://www.zaproxy.org/)

## References

- [WSTG-ATHZ-05](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/05-Authorization_Testing/05-Testing_for_OAuth_Weaknesses.md)
- [User Authentication with OAuth 2.0](https://oauth.net/articles/authentication/)
- [The OAuth 2.0 Authorization Framework](https://datatracker.ietf.org/doc/html/rfc6749)
- [The OAuth 2.0 Authorization Framework: Bearer Token Usage](https://datatracker.ietf.org/doc/html/rfc6750)
- [OAuth 2.0 Threat Model and Security Considerations](https://datatracker.ietf.org/doc/html/rfc6819)
- [OAuth 2.0 Security Best Current Practice](https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-16)
- [Authorization Code Flow with Proof Key for Code Exchange](https://auth0.com/docs/authorization/flows/authorization-code-flow-with-proof-key-for-code-exchange-pkce)