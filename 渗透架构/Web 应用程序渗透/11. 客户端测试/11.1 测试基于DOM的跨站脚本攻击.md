# 测试基于DOM的跨站脚本攻击

## 概述

[基于DOM的跨站脚本](https://owasp.org/www-community/attacks/DOM_Based_XSS)是对一类[XSS](https://owasp.org/www-community/attacks/xss/)漏洞的事实标准命名，这类漏洞源于页面中浏览器端的动态内容（通常是JavaScript）通过[源](https://github.com/wisec/domxsswiki/wiki/sources)获取用户输入，并在[接收器](https://github.com/wisec/domxsswiki/wiki/Sinks)中使用该输入，从而导致注入代码的执行。本文仅讨论导致XSS的JavaScript漏洞。

DOM（[文档对象模型](https://en.wikipedia.org/wiki/Document_Object_Model)）是浏览器中用于表示文档的结构化格式。DOM使得动态脚本（如JavaScript）能够引用文档的组件，例如表单字段或会话Cookie。浏览器也利用DOM进行安全控制——例如限制不同域上的脚本获取其他域的会话Cookie。当动态内容（如JavaScript函数）被特制请求修改，使得攻击者可以控制DOM元素时，就可能出现基于DOM的XSS漏洞。

并非所有XSS漏洞都需要攻击者控制服务器返回的内容，而是可能通过滥用不良的JavaScript编码实践来实现相同效果。其后果与典型的XSS漏洞相同，只是传递方式不同。

与其他类型的跨站脚本漏洞（[反射型和存储型](https://owasp.org/www-community/attacks/xss/)）相比，后者是服务器传递未净化的参数并返回给用户，在用户浏览器上下文中执行；而基于DOM的XSS漏洞通过利用文档对象模型（DOM）的元素以及攻击者精心编制的代码来控制代码流程。

基于DOM的XSS漏洞因其特性，在许多情况下可在服务器无法确定实际执行内容的情况下被触发。这可能导致许多常规的XSS过滤和检测技术对此类攻击失效。

以下为假设性示例，使用客户端代码：

```html
<script>
document.write("Site is at: " + document.location.href + ".");
</script>
```

攻击者可在受影响页面URL后附加`#<script>alert('xss')</script>`，该代码执行时将显示警告框。在此场景中，附加代码不会发送至服务器，因为浏览器将`#`字符后的内容视为片段（fragment）而非查询参数。本例中代码被立即执行，页面显示"xss"警告框。与更常见的跨站脚本类型（[反射型和存储型](https://owasp.org/www-community/attacks/xss/)）不同，后者需将代码发送至服务器再返回浏览器执行，而此攻击直接在用户浏览器中执行，无需与服务器交互。

基于DOM的XSS漏洞的[危害后果](https://owasp.org/www-community/attacks/xss/)与更广为人知的XSS形式同样广泛，包括Cookie窃取、进一步恶意脚本注入等，因此应视为具有同等严重性的安全威胁。

## 测试目标

- 识别DOM接收器
- 针对各类接收器类型构建有效载荷

## 测试方法

JavaScript应用程序与其他类型应用程序存在显著差异，因其通常由服务器动态生成。为理解实际执行的代码，需要对被测网站进行爬取分析，以确定所有JavaScript执行实例及用户输入接收点。许多网站依赖大型函数库，这些库通常包含数十万行代码且非内部开发。在此类场景中，自上而下测试往往成为唯一可行方案，因为多数底层函数未被调用，若通过分析它们来识别接收器将消耗超限时间。如果未能先识别输入点或缺乏输入数据，自上而下测试同样会面临效率问题。

用户输入主要分为两种形式：

- 由服务器写入页面且不允许直接XSS的输入
- 从客户端JavaScript对象获取的输入

以下是服务器向JavaScript插入数据的两个示例：

```js
var data = "<escaped data from the server>";
var result = someFunction("<escaped data from the server>");
```

以下是客户端JavaScript对象输入的两个示例：

```js
var data = window.location;
var result = someFunction(window.referrer);
```

虽然在JavaScript代码中获取这些输入的方式差异不大，但需要注意的是，当输入通过服务器接收时，服务器可以对数据进行任意的转换处理。而另一方面，JavaScript对象所执行的转换方式则较为明确且已有详细记录。如果上述示例中的 `someFunction` 是一个接收器，那么在前一种情况下，其可利用性将取决于服务器的过滤机制，而在后一种情况下，则取决于浏览器对 `window.referrer` 对象的编码方式。Stefano Di Paulo 撰写了一篇非常出色的文章，详细介绍了浏览器在请求各种 [URL 元素（通过 document 和 location 属性）](https://github.com/wisec/domxsswiki/wiki/location,-documentURI-and-URL-sources) 时返回的内容。

此外，JavaScript 通常会在 `<script>` 块之外执行，这一点从历史上众多导致 XSS 过滤器绕过的攻击向量中可以得到印证。在爬取应用程序时，需要重点关注事件处理器等场景中脚本的使用情况，以及带有 expression 属性的 CSS 块。同时应注意，任何外部 CSS 或脚本对象都需要经过评估以确定其执行的代码内容。

自动化测试在识别和验证基于 DOM 的 XSS 方面效果有限，因为其通常通过发送特定载荷并尝试在服务器响应中观测结果来识别 XSS。对于下面这个消息参数反射给用户的简单示例，这种方法可能有效：

```html
<script>
var pos=document.URL.indexOf("message=")+5;
document.write(document.URL.substring(pos,document.URL.length));
</script>
```

但在以下人为设计的场景中，漏洞可能无法被检测到：

```html
<script>
var navAgt = navigator.userAgent;

if (navAgt.indexOf("MSIE")!=-1) {
        document.write("You are using IE as a browser and visiting site: " + document.location.href + ".");
}
else
{
    document.write("You are using an unknown browser.");
}
</script>
```

因此，除非测试工具能够对客户端代码进行额外分析，否则自动化测试无法检测到可能易受基于DOM的XSS攻击的区域。

因此需要开展手动测试，可通过检查代码中可能对攻击者有用的参数引用区域来实现。此类区域的示例包括：动态写入页面的代码位置、DOM被修改的位置，甚至直接执行脚本的位置。

## 修复方案

有关预防基于DOM的XSS的措施，请参阅[基于DOM的XSS防护速查表](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html)。

## References
- [WSTG-CLNT-01](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/11-Client-side_Testing/01-Testing_for_DOM-based_Cross_Site_Scripting.md)
- [DomXSSWiki](https://github.com/wisec/domxsswiki/wiki/)