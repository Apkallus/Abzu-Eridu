# 测试支付功能

## 概述

众多应用都实现了支付功能，包括电商网站、订阅服务、慈善机构、捐赠网站和货币兑换平台。该功能的安全性至关重要，因为漏洞可能使攻击者窃取组织资金、进行欺诈性交易，甚至盗取其他用户的支付卡信息。

## 测试目标

- 评估电商功能的业务逻辑是否健全
- 理解支付功能的工作机制
- 判定支付功能是否安全

## 测试方法

### 支付网关集成方式

应用程序可通过多种不同方式集成支付功能，测试方法将根据具体采用的方式而有所差异。最常见的集成方式包括：

- 将用户重定向至第三方支付网关
- 在应用程序的IFRAME中加载第三方支付网关
- 通过HTML表单向第三方支付网关发起跨域POST请求
- 直接接收银行卡信息，然后从应用后端向支付网关API发起POST请求

### PCI DSS

支付卡行业数据安全标准（PCI DSS）是组织处理借记卡和信用卡支付时必须遵循的标准（需注意该标准并非法律）。本文指南（及大多数渗透测试）不对此标准进行完整讨论，但测试人员了解以下几个关键点将有所助益。

PCI DSS 标准适用于任何"存储、处理或传输"此类信息的系统。具体需要遵循哪些要求取决于所采用的支付网关集成方式。[Visa电子商务支付处理指南](https://www.visa.co.uk/dam/VCOM/regional/ve/unitedkingdom/PDF/risk/processing-e-commerce-payments-guide-73-17337.pdf)对此提供了详细说明，简要总结如下：

| 集成方式 | 自我评估问卷(SAQ) |
|--------------------|-------------------------------------|
| Redirect | [SAQ A](https://www.pcisecuritystandards.org/documents/PCI-DSS-v3_2_1-SAQ-A.pdf) |
| IFRAME | [SAQ A](https://www.pcisecuritystandards.org/documents/PCI-DSS-v3_2_1-SAQ-A.pdf) |
| Cross-domain POST | [SAQ A-EP](https://www.pcisecuritystandards.org/documents/PCI-DSS-v3_2-SAQ-A_EP-rev1_1.pdf) |
| Backend API | [SAQ D](https://www.pcisecuritystandards.org/documents/PCI-DSS-v3_2_1-SAQ-D_Merchant.pdf) |

除各种集成方式的攻击面和风险状况存在差异外，SAQ A（22项要求）与SAQ D（329项要求）之间需满足的要求数量也存在显著差异。

### 数量篡改

大多数电商网站允许用户在开始结账流程前将商品添加至购物车。该购物车应记录已添加的商品及其数量。数量通常应为正整数，但如果站点未进行适当验证，则可能允许输入小数数量（如`0.1`）或负数数量（如`-1`）。根据后端处理逻辑，添加负数数量的商品可能产生负值，从而降低购物车总金额。

通常存在多种可修改购物车内容的途径需进行测试，例如：
- 添加商品的负数数量
- 重复移除商品直至数量为负
- 将数量更新为负值

部分站点可能提供有效数量的下拉菜单（例如必须按10件装购买的商品），此时可能存在篡改请求以添加其他商品数量的风险。

若完整购物车明细被传递至支付网关（而非仅传递总金额），则在该阶段也可能存在篡改数值的漏洞。

最后，如果应用程序存在[HTTP参数污染/WSTG](../07-输入验证测试/04-HTTP参数污染测试.md)漏洞，则通过多次传递参数（例如：`quantity=1&quantity=-1`）可能引发异常行为。

```http
POST /api/basket/add
Host: example.org

item_id=1&quantity=5&quantity=4
```

### 价格篡改

#### 应用程序层面

当向购物车添加商品时，应用程序应仅包含商品标识和数量，如下方示例请求所示：

```http
POST /api/basket/add HTTP/1.1
Host: example.org

item_id=1&quantity=5
```

然而在某些情况下，应用程序可能同时包含价格参数，这意味着存在被篡改的可能性：

```http
POST /api/basket/add HTTP/1.1
Host: example.org

item_id=1&quantity=5&price=2.00
```

不同类型的商品可能适用不同的验证规则，因此需对每种商品类型进行单独测试。部分应用程序还允许用户在购买过程中附加向慈善机构的可选捐赠，该捐赠金额通常可设置为任意数值。若未对该金额进行有效验证，则可能存在通过设置负捐赠金额来降低购物车总金额的风险。

#### 支付网关层面

若结账流程在第三方支付网关完成，则可能存在应用程序与网关之间的价格篡改风险。

向网关的数据传输可能通过跨域POST请求实现，如下方HTML示例所示：
> 注：此请求不包含银行卡信息 - 用户将在支付网关页面输入这些信息：

```html
<form action="https://example.org/process_payment" method="POST">
    <input type="hidden" id="merchant_id" value="123" />
    <input type="hidden" id="basket_id" value="456" />
    <input type="hidden" id="item_id" value="1" />
    <input type="hidden" id="item_quantity" value="5" />
    <input type="hidden" id="item_total" value="20.00" />
    <input type="hidden" id="shipping_total" value="2.00" />
    <input type="hidden" id="basket_total" value="22.00" />
    <input type="hidden" id="currency" value="GBP" />
    <input type="submit" id="submit" value="submit" />
</form>
```

通过修改HTML表单或拦截POST请求，可能存在篡改商品价格从而实现低价购买的可能性。需注意多数支付网关会拒绝金额为零的交易，因此总金额设为0.01的成功率更高。但部分支付网关可能接受负数值（用于处理退款）。当存在多个金额参数时（如商品价格、运费和购物车总金额），应对所有参数进行测试。

若支付网关采用IFRAME方式，则可通过修改IFRAME的URL发起类似攻击：

```html
<iframe src="https://example.org/payment_iframe?merchant_id=123&basket_total=22.00" />
```

> 注：支付网关通常由第三方运营，因此可能不在测试范围内。

#### 加密交易详情

为防止交易数据被篡改，部分支付网关会对发送至其服务器的请求详情进行加密。例如，[PayPal](https://developer.paypal.com/api/nvp-soap/paypal-payments-standard/integration-guide/encryptedwebpayments/#link-usingewptoprotectmanuallycreatedpaymentbuttons)即采用公钥加密技术实现此功能。

首先可尝试发送未加密请求进行测试，因为某些支付网关在未明确配置拒绝非安全交易时，仍会允许此类请求通过。

若上述方法无效，则需获取用于加密交易详情的公钥。该公钥可能存在于应用程序的备份文件中，或通过目录遍历漏洞获取。

此外，应用程序可能重复使用相同的公钥/私钥对用于支付网关及其数字证书。可通过以下命令从服务器获取公钥：

```bash
echo -e '\0' | openssl s_client -connect example.org:443 2>/dev/null | openssl x509 -pubkey -noout
```

获取该密钥后，即可根据支付网关的文档规范尝试创建加密请求，并提交至网关验证是否被接受。

#### 安全哈希

其他支付网关采用安全哈希（或HMAC）对交易详情进行防篡改保护。具体实现方式因服务商而异（例如[Adyen](https://docs.adyen.com/online-payments/classic-integrations/hosted-payment-pages/hmac-signature-calculation)使用HMAC-SHA256算法），但通常包含交易详情和密钥值。例如，哈希值可能通过以下方式计算：

```php
$secure_hash = md5($merchant_id . $transaction_id . $items . $total_value . $secret)
```

该值随后被添加至发送至支付网关的POST请求中，用于验证交易是否遭篡改。

首先可尝试删除安全哈希参数进行测试，因为部分支付网关在未设置特定配置选项时仍允许非安全交易。

POST请求应包含计算哈希所需的所有参数（密钥除外）。这意味着若掌握哈希计算规则（支付网关文档应包含此说明），则可尝试暴力破解密钥。此外，若站点运行的是现成应用程序，配置文件或源代码中可能存在默认密钥。最后，通过获取站点备份文件或访问配置文件，也可能从中发现密钥。
一旦获取该密钥，即可篡改交易详情并生成能被支付网关验证通过的自定义安全哈希。

#### 货币篡改

若无法直接篡改实际价格，可尝试变更交易使用的货币类型（尤其适用于支持多币种的应用程序）。例如，应用程序可能验证价格是否为10，但若将支付货币从英镑(GBP)改为美元(USD)，即可实现以更低成本购买商品。

#### 时间延迟请求

若站点商品价值随时间波动（如货币兑换场景），则可通过本地代理拦截请求并延迟发送，从而以旧价格完成交易。此攻击需满足以下条件：价格参数直接包含于请求中，或与请求中的某些元素（如会话ID、交易ID）关联。以下示例展示在黄金交易平台的可能利用方式：
- 查看站点当前黄金价格
- 发起1盎司黄金的购买请求
- 拦截并冻结该请求
- 等待1分钟后再次检查黄金价格：
    - 若价格上涨，放行交易以低于现价购入黄金
    - 若价格下跌，丢弃该请求

若站点支持加密货币支付（通常波动性更大），可通过锁定加密货币计价的价格，观察其与站点主货币的汇率波动来实施利用 。

### 折扣码

如果应用程序支持折扣码，则应执行以下各项检查：

- 折扣码是否容易被猜出（如TEST、TEST10、SORRY、SORRY10、公司名称等）？
    - 若折扣码包含数字，是否可通过递增数字发现更多折扣码？
- 是否存在暴力破解防护机制？
- 能否同时应用多个折扣码？
- 折扣码是否可以重复使用？
- 能否注入通配符（如`%`或`*`）？
- 折扣码是否在HTML源码或应用程序任意位置的隐藏`<input>`字段中暴露？

除上述内容外，还需对SQL注入等常规漏洞进行测试。

### 支付流程绕过

如果应用程序的结账或支付流程包含多个阶段（例如：添加商品至购物车、输入折扣码、填写配送信息、输入账单信息），则可能通过非预期顺序执行这些步骤引发异常行为。例如，可尝试以下操作：

- 在输入账单信息后修改配送地址以降低运费；
- 在填写配送信息后移除商品以规避最低购物金额限制；
- 应用折扣码后修改购物车内容；
- 完成结账流程后修改购物车内容。

还可能存在跳过整个交易支付流程的可能性。例如，若应用程序跳转至第三方支付网关，支付流程可能如下：

1. 用户在应用程序端输入信息；
2. 用户被重定向至第三方支付网关；
3. 用户输入银行卡信息：
    - 若支付成功，则重定向至应用程序的 `success.php` 页面；
    - 若支付失败，则重定向至应用程序的 `failure.php` 页面；
4. 应用程序更新订单数据库，并在支付成功时处理订单。

根据应用程序是否实际验证支付网关的支付成功状态，攻击者可能通过强制跳转至 `success.php` 页面（若需要可附带交易ID），导致网站误判支付成功并处理订单。此外，重复请求 `success.php` 页面可能导致订单被多次处理。

### 利用交易处理费用漏洞

商家通常需要为每笔交易支付处理费用，这些费用通常由小额固定费用和交易总额的百分比组成。这意味着接收极小金额支付（如0.01美元）可能导致商家实际亏损，因为交易处理费用可能超过交易总额。

该漏洞在电子商务网站上很少可利用，因为最便宜商品的价格通常足以防止这种情况。但若网站允许客户进行任意金额支付（如捐款），需检查其是否设置了合理的最低金额限制。

### 测试支付卡

大多数支付网关都提供预定义的测试卡详细信息，供开发人员在测试和调试阶段使用。这些测试卡应仅在网关的开发或沙盒版本中有效，但若生产环境配置错误，可能被实际网站接受。

以下列举不同支付网关的测试卡示例：

- [Adyen - 测试卡号](https://docs.adyen.com/development-resources/test-cards/test-card-numbers)
- [Globalpay - 测试卡](https://developer.globalpay.com/resources/test-card-numbers)
- [Stripe - 基础测试卡号](https://stripe.com/docs/testing#cards)

### 物流测试

在应用程序上测试支付功能可能带来额外复杂性，特别是在测试线上环境时。需要考虑的方面包括：

- 获取适用于该应用程序的测试卡支付信息：
    - 若无法获取，可尝试使用预付卡或其他替代方案；
- 记录所有测试订单以便后续取消和退款；
- 避免提交不可取消的订单，或会触发其他操作（如商品被立即从仓库发出）的订单。

#### 来源与目的地相同

若转账来源与目的地账户相同，可能导致仅向账户增加金额而未发生实际转账。应测试此场景以验证应用程序是否能阻止此类操作。

#### 两步支付/转账

对于需要两个步骤（发起和确认）的支付或转账操作，需确保在两个阶段均执行验证检查。例如：
- 发起两笔独立支付；
- 分别进行确认。
验证在确认阶段是否执行必要检查（如每日限额或余额验证）。若未执行此类检查，可能导致负余额或绕过限额。

#### 支付发起后添加商品

测试以下场景：支付发起后向购物车添加商品。确认支付是否可能导致新增商品被标记为已支付，从而引发支付流程不一致。

#### 竞态条件

- **并发支付确认**
  使用Burp Intruder或自定义脚本同时发起同一订单的多个确认请求（如`POST /confirm-payment`），可能导致同一订单被重复处理。

- **回调重放或泛洪攻击**
    截获支付网关的回调请求（如发往`success.php`或`/payment/callback`）并快速并行重放。若后端缺乏幂等性检查，可能造成：
    - 触发多次订单履约事件（如发货、积分发放）；
    - 同一订单被重复标记为"已支付"；
    - 引发余额膨胀或库存错误。

#### 多输入系统（批量支付）

在支持批量支付的系统中，测试总金额保持为正但个别输入包含负值的场景。例如：

```plaintext
account_id_1 = $5
account_id_2 = -$4
Total = $1 paid, but $5 credited
```

需确保应用程序能正确处理此类情况并防止漏洞利用。

## WSTG 相关测试用例

- [HTTP参数污染测试](../07-Input_Validation_Testing/04-Testing_for_HTTP_Parameter_Pollution.md)
- [SQL注入测试](../07-Input_Validation_Testing/05-Testing_for_SQL_Injection.md)
- [工作流绕过测试](06-Testing_for_the_Circumvention_of_Work_Flows.md)

## 修复措施

- 尽量避免存储、传输或处理银行卡详细信息：
    - 使用重定向或IFRAME方式接入支付网关；
- 查阅支付网关文档并启用所有可用安全功能（如加密和安全哈希）；
- 在服务端处理所有价格相关信息：
    - 客户端请求应仅包含商品ID和数量；
- 实施适当的输入验证和业务逻辑约束（如检查负值商品数量或金额）；
- 确保应用程序支付流程健壮性，防止步骤被乱序执行。

## 参考资料

- [WSTG-BUSL-10](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/10-Business_Logic_Testing/10-Test-Payment-Functionality.md#exploiting-transaction-processing-fees)
- [支付卡行业数据安全标准（PCI DSS）](https://www.pcisecuritystandards.org/documents/PCI_DSS_v3-2-1.pdf)
- [Visa电商支付处理指南](https://www.visa.co.uk/dam/VCOM/regional/ve/unitedkingdom/PDF/risk/processing-e-commerce-payments-guide-73-17337.pdf)
