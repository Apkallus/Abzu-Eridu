# 会话超时测试

## 摘要

在此阶段，测试人员需验证应用程序是否能在用户空闲一定时间后自动将其登出，确保同一会话无法被"重复使用"，且敏感数据不会残留在浏览器缓存中。

所有应用程序都应实现会话的空闲或非活动超时机制。该超时机制定义了当用户无操作时会话保持活跃的时长，若自上次收到给定会话ID的HTTP请求后，空闲时间达到预设值，则会关闭并使会话失效。最合理的超时设置需在安全性（较短的超时）与可用性（较长的超时）之间取得平衡，且高度依赖应用程序处理数据的敏感级别。例如：公共论坛设置60分钟登出时间是可接受的，但如此长的超时对家庭银行应用则过长（建议最长不超过15分钟）。无论如何，任何未强制执行基于超时的登出机制的应用程序都应视为不安全，除非特定功能需求要求该行为。

空闲超时能降低攻击者猜测并利用其他用户有效会话ID的机会，并在特定情况下保护公共计算机免受会话重用攻击。然而，若攻击者已劫持某个会话，空闲超时无法限制其操作——攻击者可通过定期发送请求维持会话活跃，从而延长会话有效期。

会话超时管理与过期机制必须在服务器端强制执行。如果使用客户端控制的某些数据（例如Cookie值或其他客户端参数）来追踪时间参考（如登录后的分钟数），攻击者可能篡改这些数据以延长会话持续时间。因此，应用程序需要在服务器端跟踪非活动时间，并在超时后自动使当前用户会话失效，同时删除客户端存储的所有数据。

这两项操作必须谨慎实施，以避免因用户忘记登出应用程序时引入可被攻击者利用的漏洞。具体而言，对于登出功能，必须确保所有会话令牌（如Cookie）被正确销毁或失效，并在服务器端实施严格控制以防止会话令牌被重用。若未妥善执行这些操作，攻击者可能重放这些会话令牌以"复活"合法用户的会话并实施冒充（此类攻击通常称为"Cookie重放攻击"）。当然，缓解因素是攻击者需要能访问这些令牌（存储在受害者电脑上），但在多种场景下，这并非不可能或特别困难。

此类攻击最常见的情景是使用公共计算机访问私人信息（如网页邮箱、网上银行账户）。若用户未主动登出且应用程序未实现会话超时机制，攻击者仅需点击浏览器"返回"按钮即可访问同一账户。

## 测试目标

- 验证是否存在强制会话超时机制

## 测试方法

### 黑盒测试

测量超时登出时可采用与[测试登出功能（WSTG）](06-Testing_for_Logout_Functionality.md)章节相同的方法。测试方法非常相似：
1. 首先测试人员需验证是否存在超时机制，例如通过登录后等待触发超时登出。与登出功能一样，超时过后所有会话令牌应被销毁或失效。
2. 若已配置超时，测试人员需确认超时是由客户端还是服务器端（或双方）强制执行。如果会话Cookie是非持久性的（或更一般地说，会话Cookie不存储任何时间相关数据），可推定超时由服务器端强制执行。
3. 如果会话Cookie包含时间相关数据（例如登录时间、最后访问时间或持久性Cookie的过期日期），则客户端可能参与超时执行。此时测试人员可尝试修改Cookie值（若未加密保护）并观察会话状态变化。例如：将Cookie过期日期设为未来很远的时间，检验会话是否被延长。

核心原则：所有校验应在服务器端完成，且通过重新设置会话Cookie为先前值的方式不应能再次访问应用。

### 灰盒测试

测试人员需要验证以下内容：
- 登出功能是否有效销毁所有会话令牌，或至少使其失效
- 服务器是否对会话状态执行正确检查，阻止攻击者重放已销毁的会话标识符
- 是否强制执行超时机制，且由服务器端正确实施。若服务器使用从客户端发送的会话令牌中读取的过期时间（不建议此方式），则该令牌必须具有加密防篡改保护

需重点注意：应用在服务器端使会话失效是最关键的。通常这意味着代码必须调用相应方法，例如Java中的`HttpSession.invalidate()`或.NET中的`Session.abandon()`。清除浏览器Cookie是建议操作但非必需，因为只要服务器端正确使会话失效，浏览器中残留的Cookie将无法被攻击者利用。

## References

- [WSTG-SESS-07](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/06-Session_Management_Testing/07-Testing_Session_Timeout.md)

### OWASP Resources

- [Session Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)