# 跨站请求伪造（CSRF）测试

## 概述

跨站请求伪造（[CSRF](https://owasp.org/www-community/attacks/csrf)）是一种攻击方式，它强制终端用户在其已通过身份验证的 Web 应用程序上执行非预期的操作。通过简单的社会工程学手段（例如通过电子邮件或聊天发送链接），攻击者可能强制 Web 应用程序的用户执行攻击者指定的操作。成功的 CSRF 攻击可能危害终端用户的数据和操作（当目标为普通用户时）。若目标终端用户是管理员账户，CSRF 攻击则可能危害整个 Web 应用程序。

CSRF 依赖于以下要素：

1.  Web 浏览器处理会话相关信息（如 Cookie 和 HTTP 认证信息）的行为机制。
2.  攻击者对有效 Web 应用程序 URL、请求或功能的了解。
3.  应用程序会话管理仅依赖于浏览器已知的信息。
4.  存在能直接访问 HTTP[S] 资源的 HTML 标签（例如图片标签 `img`）。

其中，要素 1、2 和 3 是该漏洞存在的必要条件；而要素 4 虽然有利于实际利用，但并非严格必需。

1.  浏览器会自动发送用于识别用户会话的信息。假设 *site* 是托管 Web 应用程序的站点，用户 *victim* 刚刚通过 *site* 的身份验证。作为响应，*site* 会向 *victim* 发送一个 Cookie，该 Cookie 将 *victim* 发送的请求标识为属于 *victim* 的已验证会话。一旦浏览器收到 *site* 设置的 Cookie，它就会自动将该 Cookie 随同后续发送给 *site* 的任何请求一起发送。
2.  如果应用程序未在 URL 中使用会话相关信息，则可以识别应用程序 URL、其参数及合法值。这可通过代码分析实现，或通过访问应用程序并记录 HTML 或 JavaScript 中嵌入的表单和 URL 来实现。
3.  "浏览器已知"指的是诸如 Cookie 或基于 HTTP 的身份验证信息（例如基本身份验证，而非基于表单的身份验证）等信息。这些信息由浏览器存储，随后在每次向要求该身份验证的应用程序区域发送请求时都会携带。下文讨论的漏洞适用于完全依赖此类信息来识别用户会话的应用程序。

为简化说明，以 GET 请求可访问的 URL 为例（尽管讨论同样适用于 POST 请求）。如果 *victim* 已通过身份验证，则提交另一个请求会导致 Cookie 自动随该请求发送。下图展示了用户访问 `www.example.com` 上应用程序的情形。

![Session Riding](images/Session_riding.GIF)\
*图 WSTG 4.6.5-1：Session Riding*

用户可以通过以下几种不同方式发送 GET 请求：

- 使用 Web 应用程序
- 直接在浏览器中输入 URL
- 点击指向该 URL 的外部链接

应用程序无法区分这些调用方式。其中第三种方式尤为危险。现有多种技术手段和漏洞可掩盖链接的真实属性：该链接可能被嵌入电子邮件、出现在诱导用户访问的恶意网站，或存在于第三方托管内容（如其他网站或 HTML 邮件）中并指向应用程序资源。若用户点击该链接，由于他们已在 *site* 的 Web 应用程序完成身份验证，浏览器将向 Web 应用程序发出附带认证信息（会话 ID Cookie）的 GET 请求。这将导致在用户不知情的情况下执行有效操作，例如在网银应用中完成资金转账。

若采用上文第 4 点所述的 `img` 等标签，甚至无需用户主动点击链接。假设攻击者向用户发送诱导邮件，使其访问包含如下（过度简化的）HTML 的页面：

```html
<html>
    <body>
...
<img src="https://www.company.example/action" width="0" height="0">
...
    </body>
</html>
```

当浏览器显示此页面时，它也会尝试从 `https://www.company.example` 加载指定的零维（因此不可见）图像。这将导致自动向托管在 *site* 上的 Web 应用程序发送请求。图像 URL 是否指向真实图像并不重要，因为它的存在无论如何都会触发 `src` 字段中指定的请求 `action`。此行为的前提是浏览器未禁用图像下载。大多数浏览器不会禁用图像下载，否则将导致绝大多数 Web 应用无法正常使用。

该问题是以下因素共同导致的结果：

- 页面中的 HTML 标签会触发自动 HTTP 请求执行（`img` 是其中之一）。
- 浏览器无法判断 `img` 引用的资源是否为合法图像。
- 无论所谓的图片来源位于何处，图像加载都会发生——即表单和图像本身无需位于同一主机甚至同一域中。

与 Web 应用程序无关的 HTML 内容可能引用应用程序中的组件，且浏览器会自动向该应用程序发起有效请求——这两个事实共同构成了此类攻击的基础。除非使攻击者无法与应用功能进行交互，否则无法阻止该行为。

在集成邮件/浏览器环境中，仅需显示一封包含该图像引用的邮件，就会触发附带浏览器 cookie 向 Web 应用程序执行请求的操作。邮件可能引用看似合法的图像 URL，例如：

```html
<img src="https://[attacker]/picture.gif" width="0" height="0">
```

在此示例中，`[attacker]` 表示攻击者控制的站点。通过利用重定向机制，恶意站点可能使用 `https://[attacker]/picture.gif` 将受害者引导至 `https://[thirdparty]/action` 并触发该`action`。

Cookie 并非此类漏洞的唯一载体。会话信息完全由浏览器提供的 Web 应用程序同样易受攻击。这包括仅依赖 HTTP 认证机制的应用程序——由于认证信息由浏览器保存，且会在每次请求时自动发送。但基于表单的认证不在此列，因其仅发生一次并生成会话相关信息（通常为 Cookie）。

假设受害者已登录防火墙的 Web 管理控制台。用户需通过身份验证才能登录，会话信息存储在 Cookie 中。

再假设该防火墙管理控制台具有一项功能：认证用户可通过数字 ID 删除指定规则，若用户输入 `*`（星号）则可删除配置中的所有规则（现实中属危险功能，但本例更具演示意义）。删除页面显示如下。为简化说明，假设该表单发起 GET 请求。要删除编号为 1 的规则：

```text
https://[target]/fwmgt/delete?rule=1
```

要删除所有规则：

```text
https://[target]/fwmgt/delete?rule=*
```

此示例虽故意设计得简单，但以简化的方式展示了 CSRF（跨站请求伪造）的危险性。

![会话劫持防火墙管理](images/Session_Riding_Firewall_Management.gif)\
*图 WSTG 4.6.5-2：会话劫持防火墙管理*

使用上图中显示的表单，输入值 `*` 并点击删除按钮将提交以下 GET 请求：

```text
https://www.company.example/fwmgt/delete?rule=*
```

这将删除所有防火墙规则。

![会话劫持防火墙管理 2](images/Session_Riding_Firewall_Management_2.gif)\
*图 WSTG 4.6.5-3：会话劫持防火墙管理 2*

用户也可以通过手动提交以下 URL 实现相同结果：

```text
https://[target]/fwmgt/delete?rule=*
```

或者通过点击指向上述 URL 的直接链接或经重定向的链接。又或者，通过访问嵌有指向同一 URL 的 `img` 标签的 HTML 页面来实现。

在所有这些情况下，如果用户当前已登录防火墙管理应用程序，请求将会成功执行并修改防火墙的配置。可以设想针对敏感应用程序的攻击场景，例如自动拍卖出价、转账、下单、更改关键软件组件的配置等。

值得注意的是，这些漏洞的利用可能发生在防火墙后面；也就是说，只要受害者能够访问被攻击的链接，而攻击者无需直接访问即可。特别是，这可能是任何内网 Web 服务器；例如，前面提到的防火墙管理场景，这类应用通常不太可能直接暴露在互联网上。

自脆弱应用程序（即同时被用作攻击载体和目标的应用程序，例如 Web 邮件应用）会使情况变得更糟。由于用户在阅读电子邮件时处于登录状态，此类存在漏洞的应用程序可能允许攻击者执行删除邮件或发送看似来自受害者的邮件等操作。

## 测试目标

- 确定是否可能在用户未主动发起的情况下，以其身份发起请求。

## 测试方法

审计应用程序以确认其会话管理是否存在漏洞。若会话管理仅依赖于客户端值（浏览器可获取的信息），则该应用存在漏洞。"客户端值"指 Cookie 和 HTTP 认证凭证（基本认证及其他 HTTP 认证形式；不包括基于表单的应用级认证）。

通过 HTTP GET 请求访问的资源极易受到攻击，尽管 POST 请求也可通过 JavaScript 实现自动化攻击，同样存在风险。因此，仅使用 POST 方法不足以消除 CSRF 漏洞的产生。

对于 POST 请求，可以使用以下示例。

1.  创建一个类似于下方所示的 HTML 页面
2.  将该 HTML 页面托管在恶意或第三方网站上
3.  将该页面的链接发送给受害者，并诱导其点击。

```html
<html>
<body onload='document.CSRF.submit()'>

<form action='https://targetWebsite/Authenticate.jsp' method='POST' name='CSRF'>
    <input type='hidden' name='name' value='Hacked'>
    <input type='hidden' name='password' value='Hacked'>
</form>

</body>
</html>
```

对于开发人员使用 JSON 进行浏览器与服务器通信的 Web 应用程序，可能会出现一个问题：JSON 格式没有查询参数，而自提交表单必须要有查询参数。为了绕过这种情况，我们可以使用包含隐藏输入字段的 JSON 负载自提交表单来利用 CSRF。我们需要将编码类型 (`enctype`) 更改为 `text/plain` 以确保负载按原样传递。漏洞利用代码如下所示：

```html
<html>
 <body>
  <script>history.pushState('', '', '/')</script>
   <form action='https://victimsite.com' method='POST' enctype='text/plain'>
     <input type='hidden' name='{"name":"hacked","password":"hacked","padding":"'value='something"}' />
     <input type='submit' value='Submit request' />
   </form>
 </body>
</html>
```

POST 请求如下所示：

```http
POST / HTTP/1.1
Host: victimsite.com
Content-Type: text/plain

{"name":"hacked","password":"hacked","padding":"=something"}
```

当这些数据作为 POST 请求发送时，服务器将正常接收 name 和 password 字段，并忽略名为 padding 的字段，因为服务器不需要它。

## Remediation

- See the [OWASP CSRF Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html) for prevention measures.

## Tools

- [ZAP](https://www.zaproxy.org/)
- [CSRF Tester](https://wiki.owasp.org/index.php/Category:OWASP_CSRFTester_Project)
- [Pinata-csrf-tool](https://code.google.com/archive/p/pinata-csrf-tool/)

## References

- [WSTG-SESS-05](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md)
- [Peter W: "Cross-Site Request Forgeries"](https://web.archive.org/web/20160303230910/http://www.tux.org/~peterw/csrf.txt)
- [Thomas Schreiber: "Session Riding"](https://web.archive.org/web/20160304001446/https://www.securenet.de/papers/Session_Riding.pdf)
- [Oldest known post](https://web.archive.org/web/20000622042229/https://www.zope.org/Members/jim/ZopeSecurity/ClientSideTrojan)
- [Cross-site Request Forgery FAQ](https://www.cgisecurity.com/csrf-faq.html)
- [A Most-Neglected Fact About Cross Site Request Forgery (CSRF)](https://yehg.net/lab/pr0js/view.php/A_Most-Neglected_Fact_About_CSRF.pdf)
- [Multi-POST CSRF](https://www.lanmaster53.com/2013/07/17/multi-post-csrf/)
- [SANS Pen Test Webcast: Complete Application pwnage via Multi POST XSRF](https://www.youtube.com/watch?v=EOs5PZiiwug)