# 会话固定测试

## 概述

会话固定（Session fixation）漏洞的成因是认证前后未更新会话 Cookie 值的不安全实践。这种情况通常发生在会话 Cookie 在登录前就被用于存储状态信息时，例如在支付认证前将商品加入购物车。

在会话固定漏洞的通用利用方式中，攻击者无需认证即可从目标网站获取一组会话 Cookie。随后，攻击者可通过不同技术手段将这些 Cookie 强制植入受害者浏览器。若受害者后续在目标网站完成认证，且登录时未刷新这些 Cookie，受害者会话将被攻击者预设的 Cookie 标识。此时，攻击者即可利用这些已知 Cookie 冒充受害者身份。

修复此问题可通过在认证流程结束后刷新会话 Cookie 实现。替代方案是确保会话 Cookie 的完整性以防御攻击。针对网络攻击者（即控制受害者所用网络的攻击者），应启用完整的 [HSTS](https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security) 或在 Cookie 名称前添加 `__Host-` / `__Secure-` 前缀。

完整 HSTS 机制要求主机为自身及其所有子域名激活 HSTS，该方案在 Stefano Calzavara、Alvise Rabitti、Alessio Ragazzo 和 Michele Bugliesi 的论文《Web会话完整性缺陷测试》（*Testing for Integrity Flaws in Web Sessions*）中有详细阐述。

## 测试目标

- 分析认证机制及其流程
- 强制植入 Cookie 并评估影响

## 测试方法

本节将解释下一节演示的测试策略。

第一步是向被测网站（例如 `www.example.com`）发起请求。若测试者发送如下请求：

```http
GET / HTTP/1.1
Host: www.example.com
```

将获得以下响应：

```html
HTTP/1.1 200 OK
Date: Wed, 14 Aug 2008 08:45:11 GMT
Server: IBM_HTTP_Server
Set-Cookie: JSESSIONID=0000d8eyYq3L0z2fgq10m4v-rt4:-1; Path=/; secure
Cache-Control: no-cache="set-cookie,set-cookie2"
Expires: Thu, 01 Dec 1994 16:00:00 GMT
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: text/html;charset=Cp1254
Content-Language: en-US
```

此时应用程序为客户端设置了新的会话标识符 `JSESSIONID=0000d8eyYq3L0z2fgq10m4v-rt4:-1`。

接下来，若测试者通过向 `https://www.example.com/authentication.php` 发送如下 POST 请求成功通过认证：

```http
POST /authentication.php HTTP/1.1
Host: www.example.com
[...]
Referer: https://www.example.com
Cookie: JSESSIONID=0000d8eyYq3L0z2fgq10m4v-rt4:-1
Content-Type: application/x-www-form-urlencoded
Content-length: 57

Name=Meucci&wpPassword=secret!&wpLoginattempt=Log+in
```

测试者将观察到服务器的响应：

```http
HTTP/1.1 200 OK
Date: Thu, 14 Aug 2008 14:52:58 GMT
Server: Apache/2.2.2 (Fedora)
X-Powered-By: PHP/5.1.6
Content-language: en
Cache-Control: private, must-revalidate, max-age=0
X-Content-Encoding: gzip
Content-length: 4090
Connection: close
Content-Type: text/html; charset=UTF-8
...
HTML data
...
```

由于成功认证后未签发新 Cookie，测试者即可判定：除非会话 Cookie 的完整性得到保证，否则可能发生会话劫持。

测试者可将有效会话标识符发送给用户（可能采用社会工程学手段），等待用户完成认证，随后验证该 Cookie 是否已被授予访问权限。

### 强制Cookie测试

此测试策略主要针对网络攻击者，因此仅需应用于未采用完整HSTS机制的网站（采用完整HSTS的网站是安全的，因其所有Cookie均具备完整性）。我们假设在被测网站拥有两个测试账户，分别模拟受害者和攻击者。测试模拟攻击者将登录后未重新签发且不具备完整性的Cookie强制植入受害者浏览器的场景。受害者登录后，攻击者提交这些强制植入的Cookie访问网站：若凭这些Cookie足以代表受害者进行操作，则存在会话固定漏洞。

测试执行步骤如下：

1. 访问网站登录页面
2. 保存登录前的Cookie jar快照（排除名称中包含`__Host-`或`__Secure-`前缀的Cookie）
3. 以受害者身份登录网站，访问任意需要认证的安全功能页面
4. 将Cookie存储库恢复至第2步保存的快照状态
5. 触发第3步识别的安全功能
6. 观察第5步操作是否成功执行。若成功，则攻击生效
7. 清空Cookie存储库，以攻击者身份登录并访问第3步的页面
8. 将第2步保存的Cookie逐个写入Cookie存储库
9. 再次触发第3步识别的安全功能
10. 清空Cookie存储库，重新以受害者身份登录
11. 观察第9步操作是否在受害者账户中成功执行。若成功，则攻击生效；否则网站具备会话固定防护能力

建议为受害者和攻击者使用两台不同设备或浏览器。若Web应用采用指纹验证技术检测特定Cookie的访问权限，此方法可降低误报率。该测试策略还有一个更简短但精确度较低的变体版本，仅需一个测试账户，步骤与前六步相同，在第6步终止。

## 修复方案

在用户成功通过身份验证后，实施会话令牌更新机制。

应用程序在认证用户之前，应首先使现有会话 ID 无效；如果认证成功，再分配新的会话 ID。

## Tools

- [ZAP](https://www.zaproxy.org)

## References

- [WSTG-SESS-03](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/06-Session_Management_Testing/03-Testing_for_Session_Fixation.md)
- [Session Fixation](https://owasp.org/www-community/attacks/Session_fixation)
- [ACROS Security](https://www.acrossecurity.com/papers/session_fixation.pdf)
- [Chris Shiflett](https://shiflett.org/articles/session-fixation)