# JSON Web令牌（JWT）测试

## 摘要

JSON Web Token（JWT）是一种经过加密签名的 JSON 令牌，旨在实现系统间的声明共享。它们常用作身份验证或会话令牌，尤其在 REST API 中广泛应用。

JWT 是常见的安全漏洞来源，既可能源于应用程序的实现方式，也可能来自底层库的缺陷。由于 JWT 用于身份验证，一旦存在漏洞，极易导致整个应用被完全攻陷。

## 测试目标

- 检测 JWT 是否暴露敏感信息。
- 验证 JWT 是否可被篡改或修改。

## 测试方法

### 概述

JWT 由三个组成部分构成：

- 头部
- 载荷（或主体）
- 签名

每个部分都经过 base64 编码，并使用句点（`.`）分隔。需要注意的是，JWT 中使用的 base64 编码会去除等号（`=`），因此在解码各个部分时可能需要将其补回。

### 内容分析

#### 头部

头部定义了令牌的类型（通常为 `JWT`）以及用于签名的算法。如下所示一个解码后的头部示例：

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

计算签名主要使用以下三类算法：

| 算法类型 | 描述                  |
|-----------|-----------------------------|
| HSxxx   | 使用密钥和SHA-xxx的HMAC算法 |
| RSxxx / PSxxx | 使用RSA的公钥签名         |
| ESxxx   | 使用ECDSA的公钥签名       |

此外，还存在多种[其他算法](https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms)，可用于加密令牌（JWE），但这些算法相对少见。

#### 载荷

JWT 的载荷包含实际数据。如下所示一个载荷示例：

```json
{
  "username": "administrator",
  "is_admin": true,
  "iat": 1516239022,
  "exp": 1516242622
}
```

载荷通常未经加密，因此需要检查其中是否包含任何敏感或潜在不当数据。

此 JWT 包含了用户名、用户的管理员状态以及两个标准声明（`iat` 和 `exp`）。这些声明定义于 [RFC 5719](https://tools.ietf.org/html/rfc7519#section-4.1) 中，下表对其进行了简要说明：

| 声明 | 全称 | 描述 |
|-------|-----------|-------------|
| `iss` | 签发者（Issuer） | 令牌签发方的身份标识。 |
| `iat` | 签发时间（Issued At） | 令牌签发时的 Unix 时间戳。 |
| `nbf` | 生效时间（Not Before） | 令牌可开始使用的最早时间的 Unix 时间戳。 |
| `exp` | 过期时间（Expires） | 令牌过期时的 Unix 时间戳。 |

#### 签名

签名使用 JWT 头部定义的算法进行计算，然后进行 Base64 编码并附加到令牌中。修改 JWT 的任何部分都应导致签名失效，从而使服务器拒绝该令牌。

### 使用审查

JWT 不仅需要自身具备加密安全性，还需要以安全的方式存储和发送。这应包括以下检查：

-   始终通过[加密（HTTPS）连接/WSTG](../09-Testing_for_Weak_Cryptography/03-Testing_for_Sensitive_Information_Sent_via_Unencrypted_Channels.md)发送。
-   如果存储在 Cookie 中，则应[标记适当的属性/WSTG](../06-Session_Management_Testing/02-Testing_for_Cookies_Attributes.md)。

还应基于 `iat`、`nbf` 和 `exp` 声明来审查 JWT 的有效性，以确定：

-   JWT 对于应用程序而言具有合理的生命周期。
-   应用程序会拒绝过期的令牌。

### 签名验证

JWT 最严重的安全漏洞之一是应用程序未能正确验证签名。这通常发生在开发人员使用了类似 NodeJS 中的 `jwt.decode()` 函数（该函数仅对 JWT 的主体进行解码），而不是使用 `jwt.verify()` 函数（该函数会在解码 JWT 之前验证其签名）。

可以通过修改 JWT 的主体部分（同时保持头部和签名不变）并将其提交到请求中来轻松测试此漏洞，观察应用程序是否会接受它。

#### None 算法

除了基于公钥和 HMAC 的算法外，JWT 规范还定义了一种名为 `none` 的签名算法。顾名思义，这意味着 JWT 没有签名，允许其被任意修改。

测试此漏洞的方法是将 JWT 头部的签名算法字段修改为 `none`，如下例所示：

```json
{
        "alg": "none",
        "typ": "JWT"
}
```

然后，将头部和载荷部分重新进行 base64 编码，并移除签名部分（保留末尾的句点）。使用上面的头部和[载荷](#载荷)部分中列出的载荷，将得到以下 JWT：

```txt
eyJhbGciOiAibm9uZSIsICJ0eXAiOiAiSldUIn0K.eyJ1c2VybmFtZSI6ImFkbWluaW5pc3RyYXRvciIsImlzX2FkbWluIjp0cnVlLCJpYXQiOjE1MTYyMzkwMjIsImV4cCI6MTUxNjI0MjYyMn0.
```

一些实现试图通过显式阻止使用 `none` 算法来避免此问题。如果这种阻止是大小写不敏感的，则可能通过指定如 `NoNe` 这样的算法来绕过限制。

#### ECDSA "通灵签名"

在 Java 15 至 18 版本中发现一个安全漏洞：某些情况下未能正确验证椭圆曲线数字签名算法（ECDSA）签名（[CVE-2022-21449](https://neilmadden.blog/2022/04/19/psychic-signatures-in-java/)，即"通灵签名"）。若使用这些受影响版本解析采用 `ES256` 算法的 JWT 时，攻击者可通过篡改 JWT 主体并将签名替换为以下值来完全绕过签名验证：

```txt
MAYCAQACAQA
```

最终生成的 JWT 将呈现如下形式：

```txt
eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJhZG1pbiI6InRydWUifQ.MAYCAQACAQA
```

### 弱 HMAC 密钥风险

若 JWT 采用基于 HMAC 的算法（如 HS256）进行签名，其签名的安全性完全依赖于 HMAC 所用密钥的强度。

若应用程序使用现成或开源软件，首要步骤是检查代码，确认是否存在默认的 HMAC 签名密钥。

若未发现默认密钥，则可能通过猜测或暴力破解获取密钥。最简单的方法是使用 [crackjwt.py](https://github.com/Sjord/jwtcrack) 脚本，该工具仅需提供 JWT 和字典文件即可进行破解。

更强大的方案是利用 [jwt2john.py](https://github.com/Sjord/jwtcrack/blob/master/jwt2john.py) 脚本将 JWT 转换为 [John the Ripper](https://github.com/openwall/john) 可识别的格式。随后可使用 John 对密钥实施更高级的攻击策略。

若 JWT 体积过大超出 John 支持的最大限制，可通过修改源码解决：在 `/src/hmacSHA256_fmt_plug.c`（或其他 HMAC 格式的对应文件）中增大 `SALT_LIMBS` 变量值并重新编译 John，具体操作详见此 [GitHub issue](https://github.com/openwall/john/issues/1904)。

一旦成功获取密钥，攻击者即可伪造任意 JWT 签名，通常将导致应用系统被完全控制。

### HMAC 与公钥算法混淆风险

若应用程序使用基于公钥签名的 JWT，但未正确校验实际使用的签名算法，则可能遭受签名类型混淆攻击。要成功实施此类攻击，需同时满足以下条件：

1.  应用程序预期 JWT 应使用基于公钥的算法（即 `RSxxx` 或 `ESxxx`）进行签名。
2.  应用程序未实际校验 JWT 签名所使用的具体算法。
3.  用于验证 JWT 的公钥需对攻击者可见。

<!-- s -->
未实际校验，即应用程序对签名的校验不正确。
获得两个 JWT 即可使用公开的脚本提取公钥。见portswigger
<!-- e -->

若上述条件全部满足，攻击者即可使用公钥通过基于 HMAC 的算法（如 `HS256`）对 JWT 进行签名。例如 [Node.js jsonwebtoken](https://www.npmjs.com/package/jsonwebtoken) 库使用同一函数处理公钥和 HMAC 令牌，如下所示：

```javascript
// Verify a JWT signed using RS256
jwt.verify(token, publicKey);

// Verify a JWT signed using HS256
jwt.verify(token, secretKey);
```

这意味着若以 `publicKey` 作为 `HS256` 算法的密钥对 JWT 签名，该签名将被视为有效。

要利用此漏洞需先获取公钥。最常见的情况是应用程序将同一密钥**复用**于 JWT 签名和 TLS 证书。此时可通过如下命令从服务器下载密钥：

```sh
openssl s_client -connect example.org:443 | openssl x509 -pubkey -noout
```

此外，公钥可能存在于网站公共文件中（例如 `/.well-known/jwks.json`）。

测试时需修改 JWT 内容，并用获取的公钥通过 `HS256` 算法重新签名。但在**无法访问源代码**或实现细节的情况下测试难度较大：密钥格式必须与服务器完全一致，空格或 CRLF 编码等差异均会导致密钥匹配失败。

<!-- s -->
需对服务器的公钥格式进行猜测：
- base64字符串是否换行
- 末尾是否换行

需多次修改格进行测试
<!-- e -->

### 攻击者提供的公钥

[JSON Web签名标准 (JWS)](https://tools.ietf.org/html/rfc7515)（定义了JWT使用的头部和签名规范）允许将用于签名令牌的密钥**嵌入头部**。如果验证令牌的库支持此功能且**未将密钥与预授权密钥列表进行比对**，攻击者即可使用自选的任意密钥对JWT进行签名。

以下脚本可用于实现此攻击：
- [jwk-node-jose.py](https://github.com/zi0Black/POC-CVE-2018-0114)
- [jwt_tool](https://github.com/ticarpi/jwt_tool)

## 相关测试用例

- [测试未加密通道传输敏感信息/WSTG](../09-Testing_for_Weak_Cryptography/03-Testing_for_Sensitive_Information_Sent_via_Unencrypted_Channels.md)
- [测试Cookie属性/WSTG](../06-Session_Management_Testing/02-Testing_for_Cookies_Attributes.md)
- [测试浏览器存储/WSTG](../11-Client-side_Testing/12-Testing_Browser_Storage.md)

## 修复建议

- 使用**安全且更新**的库处理JWT
- 确保签名有效且使用**预期算法**
- 采用**高强度HMAC密钥**或**唯一私钥**进行签名
- 避免在JWT载荷中暴露敏感信息
- 确保JWT在存储和传输过程中**全程加密**
- 参考[OWASP JSON Web令牌备忘单](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)

## Tools

- [John the Ripper](https://github.com/openwall/john)
- [jwt2john](https://github.com/Sjord/jwtcrack)
- [jwt-cracker](https://github.com/brendan-rius/c-jwt-cracker)
- [JSON Web Tokens Burp Extension](https://portswigger.net/bappstore/f923cbf91698420890354c1d8958fee6)
- [ZAP JWT Add-on](https://github.com/SasanLabs/owasp-zap-jwt-addon)

## References

- [WSTG-SESS-10](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/06-Session_Management_Testing/10-Testing_JSON_Web_Tokens.md)
- [RFC 7515 JSON Web Signature (JWS)](https://tools.ietf.org/html/rfc7515)
- [RFC 7519 JSON Web Token (JWT)](https://tools.ietf.org/html/rfc7519)
- [OWASP JSON Web Token Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)