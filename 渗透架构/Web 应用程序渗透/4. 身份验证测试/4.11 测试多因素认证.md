# 测试多因素认证

## 概述

许多应用程序采用多因素认证（MFA）作为保护登录流程的额外安全层。这也被称为双因素认证（2FA）或两步验证（2SV）——尽管这些术语在严格意义上并不完全相同。MFA 意味着要求用户在登录时提供*至少*两种不同的[认证因素](#mfa类型)。

MFA 不仅为认证功能增加了复杂性，同时也对其他安全相关领域（如凭据管理和密码恢复）带来影响，因此必须以正确且稳健的方式实现。

## 测试目标

- 识别应用程序使用的 MFA 类型。
- 判断 MFA 实现是否稳健安全。
- 尝试绕过 MFA 机制。

## 测试方法

### MFA 类型

MFA 要求认证时至少需要以下因素中的*两种*：

| 因素类型 | 示例 |
|--------|----------|
| 知识因子（您知道的信息） | 密码、PIN 码和安全问题。 |
| 持有因子（您拥有的物品） | 硬件或软件令牌、证书、电子邮件\*、短信和电话呼叫。 |
| 生物特征因子（您的特征） | 指纹、面部识别、虹膜扫描、掌纹扫描和行为特征。 |
| 位置因子 | 源 IP 地址范围、地理位置。 |

\* 只有当电子邮件账户本身受到 MFA 保护时，电子邮件才能真正算作"持有因子"。因此，它应被视为比证书或 TOTP 等其他替代方案更弱的方式，并且在某些定义下可能不被接受为 MFA。

请注意，要求单一因素的多个实例（例如同时需要密码和 PIN 码）**并不构成 MFA**，尽管它可能比简单密码提供一些安全优势，并可能被视为两步验证（2SV）。

由于在基于浏览器的环境中实现生物识别技术的复杂性，"生物特征因子"很少用于 Web 应用程序，尽管通过 WebAuthn 等标准已开始被采纳。最常见的第二因素是"持有因子"。

### 检查 MFA 绕过漏洞

测试 MFA 的第一步是识别应用程序中的所有认证功能，可能包括：

- 主登录页面。
- 安全关键功能（例如禁用 MFA 或更改密码）。
- 联合登录提供商。
- API 端点（来自主 Web 界面和移动应用）。
- 替代（非 HTTP）协议。
- 测试或调试功能。

应审查所有不同的登录方法，以确保 MFA 被一致地强制执行。如果某些方法不需要 MFA，那么这些方法可能提供简单的绕过途径。

如果认证过程包含多个步骤，则可能在完成认证过程的第一步（输入用户名和密码）后，通过强制跳转到应用程序或直接发起 API 请求，而不完成第二阶段（输入 MFA 验证码）来绕过 MFA。

如果认证使用的是允许自定义认证流程（或策略）的 OpenID Connect (OIDC) 提供商（例如 Azure B2C），则可能定义了多个流程，其中某些流程可能不需要 MFA。例如，如果应用程序使用名为 `B2C_1_SignInWithMFA` 的流程进行认证，则可以尝试将其篡改为 `B2C_1_SignIn`、`B2C_1_SignInWithoutMFA` 或其他类似值。

在某些情况下，可能还实现了有意的 MFA 绕过机制，例如在以下情况下不要求 MFA：

- 来自特定 IP 地址（可能通过 `X-Forwarded-For` HTTP 头部进行欺骗）。
- 当设置了特定的 HTTP 头部时（例如 `X-Debug` 等非标准头部）。
- 对于特定的硬编码账户（例如 "root" 或 "breakglass" 账户）。

在应用程序同时支持本地登录和联合登录的情况下，如果这两种账户类型之间没有严格的隔离，则可能绕过 MFA。例如，如果用户注册了一个本地账户并为其配置了 MFA，但其在联合登录提供商处的账户未配置 MFA，攻击者可能通过攻破用户在联合登录提供商处的账户，在目标应用程序上使用相同的电子邮件地址重新注册（或链接）一个联合账户，从而绕过 MFA。

最后，如果 MFA 是在与主应用程序不同的系统上实现的（例如在反向代理上，以保护本身不支持 MFA 的遗留应用程序），则如[WSTG 映射应用程序架构](../01-Information_Gathering/10-Map_Application_Architecture.md#内容分发网络-cdn)指南中所述，通过直接连接到后端应用服务器可能绕过 MFA。

### 检查 MFA 管理功能

需要测试用户账户内用于管理 MFA 的功能是否存在漏洞，包括：

- 用户是否需要进行重新认证才能移除或更改 MFA 设置？
- MFA 管理功能是否易受[WSTG 跨站请求伪造](../06-Session_Management_Testing/05-Testing_for_Cross_Site_Request_Forgery.md)攻击？
- 能否通过[WSTG 不安全的直接对象引用（IDOR）漏洞](../05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References.md)修改其他用户的 MFA 设置？

### 检查 MFA 恢复选项

许多应用程序会提供一种方式，让用户在无法使用第二因素认证时（例如丢失手机）恢复账户访问权限。这些机制通常会成为应用程序的显著弱点，因为它们实际上允许绕过第二认证因素。

#### 恢复代码

部分应用程序在用户启用 MFA 时会提供一组恢复代码或备份代码用于登录。需要检查这些代码是否满足以下安全要求：

- 具备足够的长度和复杂度以防暴力破解攻击
- 采用安全方式生成
- 仅能单次使用
- 设有暴力破解防护机制（如账户锁定）
- 使用恢复代码时通过邮件、短信等方式通知用户

更多详细信息请参阅[OWASP 忘记密码备忘单中的“备份代码”章节](https://cheatsheetseries.owasp.org/cheatsheets/Forgot_Password_Cheat_Sheet.html#backup-codes)。

#### MFA 重置流程

如果应用程序实现了 MFA 重置流程，应按照与[WSTG 密码重置流程](09-Testing_for_Weak_Password_Change_or_Reset_Functionalities.md)相同的方式进行测试。关键是要确保该流程的安全性*至少*与应用程序的 MFA 实现强度相当。

#### 替代认证方式

部分应用程序允许用户通过其他方式验证身份，例如使用[WSTG 安全问题](08-Testing_for_Weak_Security_Question_Answer.md)。这通常意味着显著的安全弱点，因为安全问题提供的安全级别远低于 MFA。

### 一次性密码
最常见的 MFA 形式是一次性密码（OTP），通常是六位数字代码（但长度可能更长或更短）。这些代码可以由服务器和用户共同生成（例如通过验证器应用程序），或由服务器生成后发送给用户。OTP 可通过多种方式提供给用户，包括：

| 类型 | 描述 |
|------|-------------|
| 基于 HMAC 的一次性密码（HOTP） | 基于密钥和共享计数器的 HMAC 生成验证码 |
| 基于时间的一次性密码（TOTP） | 基于密钥和当前时间的 HMAC 生成验证码 |
| 邮件 | 通过电子邮件发送验证码 |
| 短信 | 通过短信发送验证码 |
| 电话 | 通过语音通话向手机号码发送验证码 |

一次性密码（OTP）通常会在用户提供用户名和密码后输入。应执行多项检查，包括：

- 多次 MFA 失败后账户是否会被锁定？
- 不同账户多次MFA失败后用户IP地址是否会被封禁？
- 失败的MFA尝试是否被记录？
- 表单是否易受注入攻击，包括[WSTG SQL通配符注入](../07-输入验证测试/05-Testing_for_SQL_Injection.md#sql通配符注入)？

根据使用的OTP类型，还需进行以下特定检查：

- OTP的发送方式（邮件、短信、电话等）
    - 是否有频率限制防止短信/电话轰炸产生费用？
- OTP的强度如何（长度和密钥空间）？
- OTP的有效期多长？
- 是否允许多个OTP同时有效？
- OTP能否重复使用？
- OTP是否与正确用户账户绑定？是否可能在其他账户上使用这些OTP进行认证？

#### HOTP 和 TOTP

HOTP 和 TOTP 代码都基于服务器与用户之间共享的密钥。对于 TOTP 代码，这通常以二维码的形式提供给用户，供他们使用身份验证器应用程序扫描（但也可以作为文本密钥提供，以便他们手动输入）。

当密钥在服务器端生成时，应检查以确保其长度和复杂度足够（[RFC 4226](https://www.rfc-editor.org/rfc/rfc4226#section-4) 建议至少 160 位），并且是使用[OWASP CS 安全随机函数](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation)生成的。

当密钥可以由用户提供时，应强制执行适当的最小长度限制，并检查输入是否存在常见的注入攻击。

TOTP 代码通常有效期为 30 秒，但有些应用程序选择接受多个代码（例如前一个、当前和下一个代码），以处理服务器系统时间与用户设备时间之间的差异。有些应用程序可能允许接受当前代码前后多个代码，这可能会使攻击者更容易猜测或暴力破解代码。下表显示了在攻击者能够每秒发出 10 个请求的情况下，对于只接受当前代码或接受多个代码的应用程序，成功暴力破解 OTP 代码的概率（计算依据参见[此文章](https://www.codasecurity.co.uk/articles/mfa-testing#case-study---brute-forcing-totp)）。

| 有效代码数量 | 1 小时后成功率 | 4 小时后成功率 | 12 小时后成功率 | 24 小时后成功率 |
|-------------|---------------------------|----------------------------|-----------------------------|-----------------------------|
| 1 | 4%  | 13% | 35% | 58% |
| 3 | 10% | 35% | 72% | 92% |
| 5 | 16% | 51% | 88% | 99% |
| 7 | 22% | 63% | 95% | 99% |

#### 邮件、短信和电话

当代码由服务器生成并发送给客户端时，应考虑以下方面：

- 传输机制（邮件、短信或语音）是否足够安全以适用于该应用？
- 代码长度和复杂度是否足够？
- 代码是否使用[安全随机函数（OWSAP CS）](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#secure-random-number-generation)生成？
- 代码的有效期多长？
- 是否允许多个代码同时有效，或者生成新代码会使旧代码失效？
    - 这是否可能被用来通过重复请求代码来阻止访问账户？
- 是否有足够的频率限制来防止攻击者请求大量代码？
    - 大量邮件代码可能导致服务器因发送垃圾邮件而被阻止。
    - 大量短信或语音通话可能会产生费用，或用于骚扰用户。

### 移动应用和推送通知

作为OTP代码的替代方案，可以向用户手机发送推送通知，用户可以选择批准或拒绝。这种方法较少见，因为它要求用户安装特定应用的身份验证器。

要正确评估其安全性，需要将测试范围扩展到涵盖移动应用及其使用的任何支持API或服务；这意味着这通常超出了传统Web应用测试的范围。但是，仍可在不测试移动应用的情况下执行一些简单检查，包括：

- 通知是否提供足够的上下文信息（IP地址、地理位置等），以便用户做出批准或拒绝的明智决定？
- 是否存在任何挑战应答机制（例如在网站上提供代码要求用户在应用中输入——通常称为"数字匹配"或"数字挑战"）？
- 是否有频率限制或机制来防止用户被垃圾通知骚扰（以免用户盲目接受某个通知）？

### IP地址和位置过滤

位置（"您所在的位置"）有时会与MFA结合使用，尽管这是否构成适当的认证因素存在争议。在Web应用环境中，这通常意味着限制特定IP地址的访问，或者只要用户从受信任的IP地址连接就不要求第二因素认证。常见场景是：当用户从办公室IP范围连接时仅需密码认证，而从其他地方连接时则需要OTP代码。

根据具体实现方式，用户可能通过设置`X-Forwarded-For`头来伪造受信任的IP地址，从而绕过此检查。请注意，如果应用程序未正确清理此头的内容，还可能在此处实施SQL注入等攻击。如果应用支持IPv6，则也应检查确保对这些连接应用了适当的限制。

此外，应审查受信任的IP地址以确保不存在以下薄弱环节：
- 可能被非受信用户访问的IP地址（如办公室访客无线网络）
- 可能发生变化的动态分配IP地址
- 攻击者可托管自己系统的公共网络范围（如Azure或AWS）

### 证书和智能卡

传输层安全（TLS）通常用于加密客户端和服务器之间的流量，并为客户端提供确认服务器身份的机制（通过将证书上的通用名（CN）或主体替代名（SAN）与请求的域名进行比较）。然而，它也可以为服务器提供确认客户端身份的机制，称为客户端证书认证或双向TLS（mTLS）。客户端证书认证的完整讨论超出了本指南的范围，但其关键原则是用户出示数字证书（存储在机器上或智能卡中），由服务器进行验证。

测试的第一步是确定目标应用程序是否限制受信任颁发证书的证书颁发机构（CA）。该信息可使用各种工具获取，或通过手动检查TLS握手过程。最简单的方法是使用OpenSSL的`s_client`命令：

```bash
$ openssl s_client -connect example:443
[...]
Acceptable client certificate CA names
C = US, ST = Example, L = Example, O = Example Org, CN = Example Org Root Certificate Authority
Client Certificate Types: RSA sign, DSA sign, ECDSA sign
```

若不存在限制条件，则可能允许使用其他 CA 签发的证书进行认证。若存在限制但实现不当，则可能创建一个具有正确名称（如上例中的“Example Org Root Certificate Authority”）的本地 CA，并使用该新 CA 为客户端证书签名。

若能够获取有效证书，还需验证该证书仅能用于被授权用户（例如，不允许使用颁发给 Alice 的证书以 Bob 的账户身份认证）。此外，应检查证书是否既未过期也未撤销。

## 相关测试案例

- [测试弱锁定机制（WSTG）](03-Testing_for_Weak_Lock_Out_Mechanism.md)
- [测试弱密码更改或重置功能（WSTG）](09-Testing_for_Weak_Password_Change_or_Reset_Functionalities.md)

## 修复措施

确保：
- 为应用程序的所有相关账户和功能实施多因素认证（MFA）
- 支持的MFA方法适合该应用程序
- 用于实现MFA的机制得到适当保护，并能抵御暴力破解攻击
- 对所有MFA相关活动进行适当的审计和日志记录

更多建议请参阅[OWASP多因素认证备忘单](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html)

## 参考文献

- [WSTG-ATHN-11](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/04-Authentication_Testing/11-Testing_Multi-Factor_Authentication.md)
- [OWASP多因素认证备忘单](https://cheatsheetseries.owasp.org/cheatsheets/Multifactor_Authentication_Cheat_Sheet.html)
