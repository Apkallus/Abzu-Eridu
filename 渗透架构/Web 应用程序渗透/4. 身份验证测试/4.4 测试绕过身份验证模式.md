# 测试绕过身份验证模式

## 摘要

在计算机安全领域，身份验证是尝试确认通信发送方数字身份的过程。一个常见的例子是登录过程。测试身份验证方案意味着理解身份验证过程的工作原理，并利用这些信息来绕过身份验证机制。

虽然大多数应用程序需要通过身份验证才能访问私有信息或执行任务，但并非每种身份验证方法都能提供足够的安全性。对安全威胁的疏忽、忽视或低估往往导致身份验证方案可能被轻易绕过，例如直接跳过登录页面访问本应在身份验证后才能进入的内部页面。

此外，通过篡改请求欺骗应用程序使其认为用户已完成身份验证，也常可绕过身份验证措施。具体手段包括修改URL参数、操纵表单或伪造会话等。

与身份验证方案相关的问题可能出现在软件开发生命周期（SDLC）的不同阶段：
- **设计阶段**：错误可能包括错误定义需保护的应用程序模块、未选择强加密协议保护凭证传输等。
- **开发阶段**：错误可能包括输入验证功能实现不正确或未遵循特定语言的安全实践。
- **应用部署阶段**：由于缺乏所需技术技能或文档不完善，应用设置可能出现问题。

## 测试目标

- 确保所有需要身份验证的服务都实施了身份验证机制。

## 测试方法

Web应用程序使用的认证方案存在多种绕过方法：

- 参数修改
- 会话ID预测
- SQL注入

### 参数修改

认证设计中的另一个问题是：当应用程序基于固定参数值验证登录是否成功时，用户可通过修改这些参数在未提供有效凭证的情况下访问受保护区域。以下示例中，"authenticated"参数被改为"yes"，使得用户获得访问权限。此例中参数位于URL中，但使用代理也可修改参数（尤其是当参数以POST请求的表单元素形式发送或存储在Cookie中时）。

```html
https://www.site.com/page.asp?authenticated=no

raven@blackbox /home $nc www.site.com 80
GET /page.asp?authenticated=yes HTTP/1.0

HTTP/1.1 200 OK
Date: Sat, 11 Nov 2006 10:22:44 GMT
Server: Apache
Connection: close
Content-Type: text/html; charset=iso-8859-1

<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML><HEAD>
</HEAD><BODY>
<H1>You Are Authenticated</H1>
</BODY></HTML>
```

![参数修改后的请求](images/Basm-parammod.jpg)\
*图 WSTG 4.4.4-1：参数修改后的请求*

### 会话ID预测

许多Web应用程序通过使用会话标识符（Session ID）来管理认证。因此，如果会话ID的生成是可预测的，恶意用户就有可能找到有效的会话ID，从而未经授权访问应用程序并冒充已认证用户。

下图中，Cookie内的值呈线性递增，因此攻击者很容易猜测出有效的会话ID。
![Cookie值随时间变化](images/Basm-sessid.jpg)\
*图 WSTG 4.4.4-2：Cookie值随时间变化*

下图中，Cookie内的值仅部分发生变化，因此可以将暴力攻击限制到下图所示的指定字段。
![部分变化的Cookie值](images/Basm-sessid2.jpg)\
*图 WSTG 4.4.4-3：部分变化的Cookie值*

### SQL注入（HTML表单认证）

SQL注入是一种广为人知的攻击技术。本节不会详细描述该技术，因为本指南中有多个章节在超出本节范围的背景下解释了注入技术。
![SQL注入](images/Basm-sqlinj.jpg)\
*图 WSTG 4.4.4-4：SQL注入*

下图表明，通过简单的SQL注入攻击，有时可以绕过认证表单。
![简单的SQL注入攻击](images/Basm-sqlinj2.gif)\
*图 WSTG 4.4.4-5：简单的SQL注入攻击*

### PHP 松散比较

如果攻击者能够通过利用先前发现的漏洞（例如目录遍历）或从代码仓库（开源应用）获取应用程序源代码，则可能针对认证过程的实现发起精细攻击。

在以下示例（PHPBB 2.0.12 - 认证绕过漏洞）中，第2行的 `unserialize()` 函数会解析用户提供的Cookie并在 `$sessiondata` 数组中设置值。第7行将后端数据库中存储的用户MD5密码哈希值（`$auto_login_key`）与用户提供的值（`$sessiondata['autologinid']`）进行比较。

```php
1. if (isset($HTTP_COOKIE_VARS[$cookiename . '_sid'])) {
2.     $sessiondata = isset($HTTP_COOKIE_VARS[$cookiename . '_data']) ? unserialize(stripslashes($HTTP_COOKIE_VARS[$cookiename . '_data'])) : array();
3.     $sessionmethod = SESSION_METHOD_COOKIE;
4. }
5. $auto_login_key = $userdata['user_password'];
6. // We have to login automagically
7. if( $sessiondata['autologinid'] == $auto_login_key )
8. {
9.     // autologinid matches password
10.     $login = 1;
11.     $enable_autologin = 1;
12. }

```

在PHP中，字符串值与 `true` 布尔值之间的比较结果始终为 `true`（因为字符串包含值），因此通过向 `unserialize()` 函数提供以下序列化字符串，可以绕过认证控制并以管理员身份登录（其 `userid` 为2）：

```php
a:2:{s:11:"autologinid";b:1;s:6:"userid";s:1:"2";}  
// original value: a:2:{s:11:"autologinid";s:32:"8b8e9715d12e4ca12c4c3eb4865aaf6a";s:6:"userid";s:4:"1337";}
```

以下是我们在此字符串中执行的操作解析：
1. 将 `autologinid` 设置为布尔值 `true`：通过将密码哈希的MD5值（`s:32:"8b8e9715d12e4ca12c4c3eb4865aaf6a"`）替换为 `b:1` 实现
2. 将 `userid` 设置为管理员ID：通过将常规用户ID（`s:4:"1337"`）替换为 `s:1:"2"` 实现（此处用户id可预测，且管理员账户通常为最初创建的几个）

## Tools

- [WebGoat](https://owasp.org/www-project-webgoat/)
- [Zed Attack Proxy (ZAP)](https://www.zaproxy.org)

## References

- [WSTG-ATHN-04](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/04-Authentication_Testing/04-Testing_for_Bypassing_Authentication_Schema.md#php-loose-comparison)
- [Niels Teusink: phpBB 2.0.12 authentication bypass](http://blog.teusink.net/2008/12/classic-bug-phpbb-2012-authentication.html)
- [David Endler: "Session ID Brute Force Exploitation and Prediction"](https://www.cgisecurity.com/lib/SessionIDs.pdf)