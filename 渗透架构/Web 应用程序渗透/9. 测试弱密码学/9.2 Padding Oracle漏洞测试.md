# Padding Oracle漏洞测试

## 概述

填充预言机（padding oracle）是应用程序的一种功能，它解密客户端提供的加密数据（例如存储在客户端的内部会话状态），并在解密后泄露填充有效性的状态。填充预言机的存在允许攻击者在不知晓加密操作所用密钥的情况下，解密加密数据并加密任意数据。如果应用程序假定加密数据具有完整性，这可能导致敏感数据泄露或权限提升漏洞。

分组密码仅对特定大小的数据块进行加密。常用密码的块大小为8和16字节。当数据大小与所用密码块大小的整数倍不匹配时，必须采用特定方式进行填充，以便解密方能够去除填充。常用的填充方案是PKCS#7，该方案使用填充长度值填充剩余字节。例如：
如果填充长度为5字节，则明文字段后重复五次字节值`0x05`。

当填充不符合所用填充方案的语法时，会出现错误状态。如果应用程序针对客户端提供的加密数据泄露此特定填充错误状态，则存在填充预言机。这可能通过直接暴露异常（例如Java中的`BadPaddingException`）、发送给客户端的响应存在细微差异，或通过其他侧信道（如时序行为）发生。

密码学的某些操作模式允许位翻转攻击，即翻转密文中的某个位会导致明文中相应位也被翻转。在CBC加密数据中翻转第n个块的某个位，会导致解密后第(n+1)个块的相同位被翻转。通过此操作，解密后的第n个密文块将被破坏。

填充预言机攻击使攻击者能够在不知晓加密密钥和所用密码的情况下，通过向填充预言机发送精心篡改的密文并观察其返回结果来解密加密数据。这会导致加密数据的机密性丧失。例如，在会话数据存储在客户端的情况下，攻击者可以获取应用程序内部状态和结构的信息。

填充预言机攻击还使攻击者能够在不知晓所用密钥和密码的情况下加密任意明文。如果应用程序假定解密数据具有完整性和真实性，攻击者可能能够操纵内部会话状态，并可能获得更高权限。

## 测试目标

- 识别依赖填充的加密消息
- 尝试破解加密消息的填充机制，并分析返回的错误信息以进行深入分析

## 测试方法

### 黑盒测试

首先需要识别可能存在填充预言机的输入点。通常需满足以下条件：

1. 数据经过加密（通常表现为随机字符序列）
2. 采用分组密码：解码后（常使用Base64编码）的密文长度是常见密码块大小（如8或16字节）的整数倍。不同密文（例如通过不同会话或会话状态操纵获取）在长度上存在公约数

例如：
Base64解码`Dg6W8OiWMIdVokIDH15T/A==`后得到`0e 0e 96 f0 e8 96 30 87 55 a2 42 03 1f 5e 53 fc`。该数据表现为随机字符序列且长度为16字节。

若识别出此类输入值候选，需验证应用程序对加密值进行位级篡改的响应行为。通常该Base64编码值包含前置的初始化向量（IV）和密文。设明文为`p`，密码块大小为`n`，则块数量为`b = ceil( length(p) / n)`。由于初始化向量存在，加密字符串长度将为`y=(b+1)*n`。为验证预言机存在，可解码字符串后翻转倒数第二个块`b-1`的最后一位（位于`y-n-1`字节的最低有效位），重新编码后发送。接着对原始字符串解码，翻转块`b-2`的最后一位（位于`y-2*n-1`字节的最低有效位），重新编码后发送。

<!--  -->
此处缺乏信息，应当结合portswigger的主题文章
<!--  -->

若已知加密字符串为单块（IV存储于服务器或应用程序使用不安全的硬编码IV），则需依次执行多位翻转。替代方案可前置随机块，通过位翻转使新增块的末字节遍历所有可能值（0至255）。

测试及基准值应至少触发解密期间及解密后的三种不同状态：
- 密文解密成功，结果数据正确
- 密文解密成功，但结果数据混乱导致应用程序逻辑产生异常或错误处理
- 因填充错误导致密文解密失败

需仔细对比响应结果，重点排查声明填充异常的提示信息。若出现此类消息，则应用程序存在填充预言机。若通过隐式方式（如差异化的错误消息、时序侧信道）观测到上述三种状态，则该处极可能存在填充预言机。建议通过实际执行填充预言机攻击进行最终确认。

例如：

- 当解密密文的填充损坏时，ASP.NET会抛出`System.Security.Cryptography.CryptographicException: Padding is invalid and cannot be removed.`（填充无效且无法移除）
- 在Java中会抛出`javax.crypto.BadPaddingException`异常
- 解密错误或类似情况可能构成填充预言机

> 安全实现应检查完整性并仅产生两种响应：`成功`与`失败`，不存在可用于判断内部错误状态的侧信道

### 灰盒测试

验证所有处理来自客户端加密数据（应仅服务器可知）的解码环节。此类代码需满足以下条件：
1. 密文完整性应通过安全机制验证，如HMAC或经过认证的密码操作模式（GCM或CCM）
2. 解密及后续处理过程中的所有错误状态均采用统一处理机制

### 示例4

[解密过程可视化示例](https://erlend.oftedal.no/blog/poet/)

## Tools

- [Bletchley](https://code.blindspotsecurity.com/trac/bletchley)
- [PadBuster](https://github.com/GDSSecurity/PadBuster)
- [Poracle](https://github.com/iagox86/Poracle)
- [python-paddingoracle](https://github.com/mwielgoszewski/python-paddingoracle)

## References

- [WSTG-CRYP-02](https://github.com/OWASP/wstg/blob/master/document/4-Web_Application_Security_Testing/09-Testing_for_Weak_Cryptography/02-Testing_for_Padding_Oracle.md)
- [Wikipedia - Padding Oracle Attack](https://en.wikipedia.org/wiki/Padding_oracle_attack)
- [Juliano Rizzo, Thai Duong, "Practical Padding Oracle Attacks"](https://www.usenix.org/event/woot10/tech/full_papers/Rizzo.pdf)