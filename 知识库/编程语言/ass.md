### 系统调用

使用 `syscall`（即*系统调用*指令）来与操作系统交互（当然是通过 CPU）。

每个系统调用由一个*系统调用号*（从 0 开始向上计数）来指示，你的程序通过将其系统调用号移动到 `rax` 寄存器并调用 `syscall` 指令来调用特定的系统调用。
例如，如果我们想调用系统调用 42（一个你稍后会了解的系统调用！），我们会编写两条指令：

```assembly
mov rax, 42
syscall
```

系统调用编号：
- `exit`  60
- `alarm` 37`  
    在操作系统中设置一个定时器，当经过指定的秒数后，Linux 将终止该程序。

### 参数传递

参数通过寄存器传递给系统调用，系统调用可以接受多个参数。
系统调用的第一个参数通过寄存器 `rdi` 传递。

`exit` 仅接受一个参数：退出码。

### 构建可执行文件

要构建可执行二进制文件，您需要：

1. 将汇编代码写入文件（通常使用 `.S` 或 `.s` 后缀。本例中将使用 `program.s`）。
2. 将汇编文件汇编成*目标文件*（使用 `as` 命令）。
3. 将一个或多个可重定位目标文件链接成最终的可执行二进制文件（使用 `ld` 命令）！

**汇编**
通过在汇编代码开头添加一条伪指令 `.intel_syntax noprefix` 告诉汇编器您将使用Intel汇编语法，特别是无需为每条指令添加额外前缀的变体。

```sh
hacker@dojo:~$ as -o program.o program.s
```

此处，`as` 工具读取 `program.s`，将其汇编成二进制代码，并输出一个名为 `program.o` 的*目标文件*。

**链接**
在典型的开发工作流中，源代码被编译，汇编代码被汇编成目标文件，通常会有多个这样的文件（通常，程序中的每个源代码文件会编译成其自己的目标文件）。
然后将它们*链接*在一起形成一个可执行文件。
即使只有一个文件，我们仍然需要链接它，以准备最终的可执行文件。
这是通过 `ld`（源自术语"链接编辑器"）命令完成的，如下所示：

```sh
hacker@dojo:~$ ld -o program program.o
ld: warning: cannot find entry symbol _start; defaulting to 0000000000401000
```

这将创建一个名为 `program` 的文件，然后我们就可以运行它了！

`ld` 打印了一个关于 `entry symbol _start` 的警告。
`_start` 符号本质上是给 `ld` 的一个说明，指出当ELF文件被执行时，程序执行应从何处开始。
该警告表明，在未指定 `_start` 的情况下，执行将从代码的开头开始。

如果您想消除此错误，可以在代码中指定 `_start` 符号，如下所示：

```asm
.intel_syntax noprefix
.global _start
_start:
THE CODE
```

`.global _start` 指示 `as` 使 `_start` 标签在链接器级别*全局可见*，而不仅仅在目标文件级别局部可见。
`_start:` 添加了一个名为 `_start` 的*标签*，指向您代码的开头。
